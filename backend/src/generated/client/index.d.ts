
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Hardware
 * 
 */
export type Hardware = $Result.DefaultSelection<Prisma.$HardwarePayload>
/**
 * Model AddressBook
 * 
 */
export type AddressBook = $Result.DefaultSelection<Prisma.$AddressBookPayload>
/**
 * Model DNS
 * 
 */
export type DNS = $Result.DefaultSelection<Prisma.$DNSPayload>
/**
 * Model AccountBook
 * 
 */
export type AccountBook = $Result.DefaultSelection<Prisma.$AccountBookPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Memory
 * 
 */
export type Memory = $Result.DefaultSelection<Prisma.$MemoryPayload>
/**
 * Model Computer
 * 
 */
export type Computer = $Result.DefaultSelection<Prisma.$ComputerPayload>
/**
 * Model Quests
 * 
 */
export type Quests = $Result.DefaultSelection<Prisma.$QuestsPayload>
/**
 * Model UserQuests
 * 
 */
export type UserQuests = $Result.DefaultSelection<Prisma.$UserQuestsPayload>
/**
 * Model Software
 * 
 */
export type Software = $Result.DefaultSelection<Prisma.$SoftwarePayload>
/**
 * Model Process
 * 
 */
export type Process = $Result.DefaultSelection<Prisma.$ProcessPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model Logs
 * 
 */
export type Logs = $Result.DefaultSelection<Prisma.$LogsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Groups: {
  User: 'User',
  Guest: 'Guest',
  Admin: 'Admin'
};

export type Groups = (typeof Groups)[keyof typeof Groups]


export const HardwareTypes: {
  CPU: 'CPU',
  GPU: 'GPU',
  RAM: 'RAM',
  HDD: 'HDD',
  Upload: 'Upload',
  Download: 'Download'
};

export type HardwareTypes = (typeof HardwareTypes)[keyof typeof HardwareTypes]


export const AccessLevel: {
  GOD: 'GOD',
  FTP: 'FTP'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]

}

export type Groups = $Enums.Groups

export const Groups: typeof $Enums.Groups

export type HardwareTypes = $Enums.HardwareTypes

export const HardwareTypes: typeof $Enums.HardwareTypes

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.hardware`: Exposes CRUD operations for the **Hardware** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hardware
    * const hardware = await prisma.hardware.findMany()
    * ```
    */
  get hardware(): Prisma.HardwareDelegate<ExtArgs>;

  /**
   * `prisma.addressBook`: Exposes CRUD operations for the **AddressBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddressBooks
    * const addressBooks = await prisma.addressBook.findMany()
    * ```
    */
  get addressBook(): Prisma.AddressBookDelegate<ExtArgs>;

  /**
   * `prisma.dNS`: Exposes CRUD operations for the **DNS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DNS
    * const dNS = await prisma.dNS.findMany()
    * ```
    */
  get dNS(): Prisma.DNSDelegate<ExtArgs>;

  /**
   * `prisma.accountBook`: Exposes CRUD operations for the **AccountBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountBooks
    * const accountBooks = await prisma.accountBook.findMany()
    * ```
    */
  get accountBook(): Prisma.AccountBookDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.memory`: Exposes CRUD operations for the **Memory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memories
    * const memories = await prisma.memory.findMany()
    * ```
    */
  get memory(): Prisma.MemoryDelegate<ExtArgs>;

  /**
   * `prisma.computer`: Exposes CRUD operations for the **Computer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Computers
    * const computers = await prisma.computer.findMany()
    * ```
    */
  get computer(): Prisma.ComputerDelegate<ExtArgs>;

  /**
   * `prisma.quests`: Exposes CRUD operations for the **Quests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quests.findMany()
    * ```
    */
  get quests(): Prisma.QuestsDelegate<ExtArgs>;

  /**
   * `prisma.userQuests`: Exposes CRUD operations for the **UserQuests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuests
    * const userQuests = await prisma.userQuests.findMany()
    * ```
    */
  get userQuests(): Prisma.UserQuestsDelegate<ExtArgs>;

  /**
   * `prisma.software`: Exposes CRUD operations for the **Software** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Software
    * const software = await prisma.software.findMany()
    * ```
    */
  get software(): Prisma.SoftwareDelegate<ExtArgs>;

  /**
   * `prisma.process`: Exposes CRUD operations for the **Process** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processes
    * const processes = await prisma.process.findMany()
    * ```
    */
  get process(): Prisma.ProcessDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.LogsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Game: 'Game',
    Session: 'Session',
    Hardware: 'Hardware',
    AddressBook: 'AddressBook',
    DNS: 'DNS',
    AccountBook: 'AccountBook',
    Profile: 'Profile',
    Memory: 'Memory',
    Computer: 'Computer',
    Quests: 'Quests',
    UserQuests: 'UserQuests',
    Software: 'Software',
    Process: 'Process',
    Notifications: 'Notifications',
    Logs: 'Logs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'game' | 'session' | 'hardware' | 'addressBook' | 'dNS' | 'accountBook' | 'profile' | 'memory' | 'computer' | 'quests' | 'userQuests' | 'software' | 'process' | 'notifications' | 'logs'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>,
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Hardware: {
        payload: Prisma.$HardwarePayload<ExtArgs>
        fields: Prisma.HardwareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HardwareFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HardwareFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          findFirst: {
            args: Prisma.HardwareFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HardwareFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          findMany: {
            args: Prisma.HardwareFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>[]
          }
          create: {
            args: Prisma.HardwareCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          createMany: {
            args: Prisma.HardwareCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HardwareDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          update: {
            args: Prisma.HardwareUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          deleteMany: {
            args: Prisma.HardwareDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HardwareUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HardwareUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          aggregate: {
            args: Prisma.HardwareAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHardware>
          }
          groupBy: {
            args: Prisma.HardwareGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HardwareGroupByOutputType>[]
          }
          count: {
            args: Prisma.HardwareCountArgs<ExtArgs>,
            result: $Utils.Optional<HardwareCountAggregateOutputType> | number
          }
        }
      }
      AddressBook: {
        payload: Prisma.$AddressBookPayload<ExtArgs>
        fields: Prisma.AddressBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressBookFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressBookFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          findFirst: {
            args: Prisma.AddressBookFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressBookFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          findMany: {
            args: Prisma.AddressBookFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>[]
          }
          create: {
            args: Prisma.AddressBookCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          createMany: {
            args: Prisma.AddressBookCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressBookDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          update: {
            args: Prisma.AddressBookUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          deleteMany: {
            args: Prisma.AddressBookDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressBookUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressBookUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          aggregate: {
            args: Prisma.AddressBookAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddressBook>
          }
          groupBy: {
            args: Prisma.AddressBookGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressBookCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressBookCountAggregateOutputType> | number
          }
        }
      }
      DNS: {
        payload: Prisma.$DNSPayload<ExtArgs>
        fields: Prisma.DNSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DNSFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DNSFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          findFirst: {
            args: Prisma.DNSFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DNSFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          findMany: {
            args: Prisma.DNSFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>[]
          }
          create: {
            args: Prisma.DNSCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          createMany: {
            args: Prisma.DNSCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DNSDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          update: {
            args: Prisma.DNSUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          deleteMany: {
            args: Prisma.DNSDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DNSUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DNSUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          aggregate: {
            args: Prisma.DNSAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDNS>
          }
          groupBy: {
            args: Prisma.DNSGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DNSGroupByOutputType>[]
          }
          count: {
            args: Prisma.DNSCountArgs<ExtArgs>,
            result: $Utils.Optional<DNSCountAggregateOutputType> | number
          }
        }
      }
      AccountBook: {
        payload: Prisma.$AccountBookPayload<ExtArgs>
        fields: Prisma.AccountBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountBookFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountBookFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          findFirst: {
            args: Prisma.AccountBookFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountBookFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          findMany: {
            args: Prisma.AccountBookFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>[]
          }
          create: {
            args: Prisma.AccountBookCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          createMany: {
            args: Prisma.AccountBookCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountBookDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          update: {
            args: Prisma.AccountBookUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          deleteMany: {
            args: Prisma.AccountBookDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountBookUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountBookUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          aggregate: {
            args: Prisma.AccountBookAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccountBook>
          }
          groupBy: {
            args: Prisma.AccountBookGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountBookCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountBookCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Memory: {
        payload: Prisma.$MemoryPayload<ExtArgs>
        fields: Prisma.MemoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          findFirst: {
            args: Prisma.MemoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          findMany: {
            args: Prisma.MemoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>[]
          }
          create: {
            args: Prisma.MemoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          createMany: {
            args: Prisma.MemoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          update: {
            args: Prisma.MemoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          deleteMany: {
            args: Prisma.MemoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          aggregate: {
            args: Prisma.MemoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMemory>
          }
          groupBy: {
            args: Prisma.MemoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemoryCountArgs<ExtArgs>,
            result: $Utils.Optional<MemoryCountAggregateOutputType> | number
          }
        }
      }
      Computer: {
        payload: Prisma.$ComputerPayload<ExtArgs>
        fields: Prisma.ComputerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComputerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComputerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          findFirst: {
            args: Prisma.ComputerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComputerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          findMany: {
            args: Prisma.ComputerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>[]
          }
          create: {
            args: Prisma.ComputerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          createMany: {
            args: Prisma.ComputerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ComputerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          update: {
            args: Prisma.ComputerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          deleteMany: {
            args: Prisma.ComputerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ComputerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ComputerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          aggregate: {
            args: Prisma.ComputerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComputer>
          }
          groupBy: {
            args: Prisma.ComputerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComputerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComputerCountArgs<ExtArgs>,
            result: $Utils.Optional<ComputerCountAggregateOutputType> | number
          }
        }
      }
      Quests: {
        payload: Prisma.$QuestsPayload<ExtArgs>
        fields: Prisma.QuestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          findFirst: {
            args: Prisma.QuestsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          findMany: {
            args: Prisma.QuestsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>[]
          }
          create: {
            args: Prisma.QuestsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          createMany: {
            args: Prisma.QuestsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.QuestsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          update: {
            args: Prisma.QuestsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          deleteMany: {
            args: Prisma.QuestsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuestsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuestsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          aggregate: {
            args: Prisma.QuestsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuests>
          }
          groupBy: {
            args: Prisma.QuestsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestsCountArgs<ExtArgs>,
            result: $Utils.Optional<QuestsCountAggregateOutputType> | number
          }
        }
      }
      UserQuests: {
        payload: Prisma.$UserQuestsPayload<ExtArgs>
        fields: Prisma.UserQuestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuestsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuestsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          findFirst: {
            args: Prisma.UserQuestsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuestsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          findMany: {
            args: Prisma.UserQuestsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>[]
          }
          create: {
            args: Prisma.UserQuestsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          createMany: {
            args: Prisma.UserQuestsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserQuestsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          update: {
            args: Prisma.UserQuestsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          deleteMany: {
            args: Prisma.UserQuestsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuestsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserQuestsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          aggregate: {
            args: Prisma.UserQuestsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserQuests>
          }
          groupBy: {
            args: Prisma.UserQuestsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserQuestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuestsCountArgs<ExtArgs>,
            result: $Utils.Optional<UserQuestsCountAggregateOutputType> | number
          }
        }
      }
      Software: {
        payload: Prisma.$SoftwarePayload<ExtArgs>
        fields: Prisma.SoftwareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoftwareFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoftwareFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          findFirst: {
            args: Prisma.SoftwareFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoftwareFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          findMany: {
            args: Prisma.SoftwareFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>[]
          }
          create: {
            args: Prisma.SoftwareCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          createMany: {
            args: Prisma.SoftwareCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SoftwareDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          update: {
            args: Prisma.SoftwareUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          deleteMany: {
            args: Prisma.SoftwareDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SoftwareUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SoftwareUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          aggregate: {
            args: Prisma.SoftwareAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSoftware>
          }
          groupBy: {
            args: Prisma.SoftwareGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SoftwareGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoftwareCountArgs<ExtArgs>,
            result: $Utils.Optional<SoftwareCountAggregateOutputType> | number
          }
        }
      }
      Process: {
        payload: Prisma.$ProcessPayload<ExtArgs>
        fields: Prisma.ProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findFirst: {
            args: Prisma.ProcessFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findMany: {
            args: Prisma.ProcessFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          create: {
            args: Prisma.ProcessCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          createMany: {
            args: Prisma.ProcessCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProcessDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          update: {
            args: Prisma.ProcessUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          deleteMany: {
            args: Prisma.ProcessDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProcessUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          aggregate: {
            args: Prisma.ProcessAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProcess>
          }
          groupBy: {
            args: Prisma.ProcessGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessCountArgs<ExtArgs>,
            result: $Utils.Optional<ProcessCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      Logs: {
        payload: Prisma.$LogsPayload<ExtArgs>
        fields: Prisma.LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findFirst: {
            args: Prisma.LogsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findMany: {
            args: Prisma.LogsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          create: {
            args: Prisma.LogsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          createMany: {
            args: Prisma.LogsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          update: {
            args: Prisma.LogsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          deleteMany: {
            args: Prisma.LogsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.LogsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogsCountArgs<ExtArgs>,
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    session: number
    computer: number
    software: number
    memory: number
    process: number
    userQuests: number
    addressBook: number
    accountBook: number
    logs: number
    dns: number
    profile: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UserCountOutputTypeCountSessionArgs
    computer?: boolean | UserCountOutputTypeCountComputerArgs
    software?: boolean | UserCountOutputTypeCountSoftwareArgs
    memory?: boolean | UserCountOutputTypeCountMemoryArgs
    process?: boolean | UserCountOutputTypeCountProcessArgs
    userQuests?: boolean | UserCountOutputTypeCountUserQuestsArgs
    addressBook?: boolean | UserCountOutputTypeCountAddressBookArgs
    accountBook?: boolean | UserCountOutputTypeCountAccountBookArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    dns?: boolean | UserCountOutputTypeCountDnsArgs
    profile?: boolean | UserCountOutputTypeCountProfileArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComputerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComputerWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }



  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    software: number
    hardware: number
    computer: number
    memory: number
    process: number
    quests: number
    userQuests: number
    logs: number
    addressBook: number
    accountBook: number
    dns: number
    profile: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    software?: boolean | GameCountOutputTypeCountSoftwareArgs
    hardware?: boolean | GameCountOutputTypeCountHardwareArgs
    computer?: boolean | GameCountOutputTypeCountComputerArgs
    memory?: boolean | GameCountOutputTypeCountMemoryArgs
    process?: boolean | GameCountOutputTypeCountProcessArgs
    quests?: boolean | GameCountOutputTypeCountQuestsArgs
    userQuests?: boolean | GameCountOutputTypeCountUserQuestsArgs
    logs?: boolean | GameCountOutputTypeCountLogsArgs
    addressBook?: boolean | GameCountOutputTypeCountAddressBookArgs
    accountBook?: boolean | GameCountOutputTypeCountAccountBookArgs
    dns?: boolean | GameCountOutputTypeCountDnsArgs
    profile?: boolean | GameCountOutputTypeCountProfileArgs
  }

  // Custom InputTypes

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountSoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountHardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HardwareWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountComputerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComputerWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountMemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestsWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountUserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountAddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountDnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
  }


  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }



  /**
   * Count Type MemoryCountOutputType
   */

  export type MemoryCountOutputType = {
    accountBook: number
  }

  export type MemoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | MemoryCountOutputTypeCountAccountBookArgs
  }

  // Custom InputTypes

  /**
   * MemoryCountOutputType without action
   */
  export type MemoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryCountOutputType
     */
    select?: MemoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MemoryCountOutputType without action
   */
  export type MemoryCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }



  /**
   * Count Type ComputerCountOutputType
   */

  export type ComputerCountOutputType = {
    dns: number
    hardware: number
    software: number
    memory: number
    process: number
    addressBook: number
    accountBook: number
    logs: number
  }

  export type ComputerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dns?: boolean | ComputerCountOutputTypeCountDnsArgs
    hardware?: boolean | ComputerCountOutputTypeCountHardwareArgs
    software?: boolean | ComputerCountOutputTypeCountSoftwareArgs
    memory?: boolean | ComputerCountOutputTypeCountMemoryArgs
    process?: boolean | ComputerCountOutputTypeCountProcessArgs
    addressBook?: boolean | ComputerCountOutputTypeCountAddressBookArgs
    accountBook?: boolean | ComputerCountOutputTypeCountAccountBookArgs
    logs?: boolean | ComputerCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComputerCountOutputType
     */
    select?: ComputerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountDnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountHardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HardwareWhereInput
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountSoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountMemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountAddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }


  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }



  /**
   * Count Type QuestsCountOutputType
   */

  export type QuestsCountOutputType = {
    userQuests: number
  }

  export type QuestsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userQuests?: boolean | QuestsCountOutputTypeCountUserQuestsArgs
  }

  // Custom InputTypes

  /**
   * QuestsCountOutputType without action
   */
  export type QuestsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestsCountOutputType
     */
    select?: QuestsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * QuestsCountOutputType without action
   */
  export type QuestsCountOutputTypeCountUserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    salt: string | null
    lastAction: Date | null
    created: Date | null
    refreshToken: string | null
    group: $Enums.Groups | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    salt: string | null
    lastAction: Date | null
    created: Date | null
    refreshToken: string | null
    group: $Enums.Groups | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    salt: number
    lastAction: number
    created: number
    refreshToken: number
    group: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    salt?: true
    lastAction?: true
    created?: true
    refreshToken?: true
    group?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    salt?: true
    lastAction?: true
    created?: true
    refreshToken?: true
    group?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    salt?: true
    lastAction?: true
    created?: true
    refreshToken?: true
    group?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    password: string
    salt: string
    lastAction: Date
    created: Date
    refreshToken: string | null
    group: $Enums.Groups
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    salt?: boolean
    lastAction?: boolean
    created?: boolean
    refreshToken?: boolean
    group?: boolean
    session?: boolean | User$sessionArgs<ExtArgs>
    computer?: boolean | User$computerArgs<ExtArgs>
    software?: boolean | User$softwareArgs<ExtArgs>
    memory?: boolean | User$memoryArgs<ExtArgs>
    process?: boolean | User$processArgs<ExtArgs>
    userQuests?: boolean | User$userQuestsArgs<ExtArgs>
    addressBook?: boolean | User$addressBookArgs<ExtArgs>
    accountBook?: boolean | User$accountBookArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    dns?: boolean | User$dnsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    salt?: boolean
    lastAction?: boolean
    created?: boolean
    refreshToken?: boolean
    group?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | User$sessionArgs<ExtArgs>
    computer?: boolean | User$computerArgs<ExtArgs>
    software?: boolean | User$softwareArgs<ExtArgs>
    memory?: boolean | User$memoryArgs<ExtArgs>
    process?: boolean | User$processArgs<ExtArgs>
    userQuests?: boolean | User$userQuestsArgs<ExtArgs>
    addressBook?: boolean | User$addressBookArgs<ExtArgs>
    accountBook?: boolean | User$accountBookArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    dns?: boolean | User$dnsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>[]
      computer: Prisma.$ComputerPayload<ExtArgs>[]
      software: Prisma.$SoftwarePayload<ExtArgs>[]
      memory: Prisma.$MemoryPayload<ExtArgs>[]
      process: Prisma.$ProcessPayload<ExtArgs>[]
      userQuests: Prisma.$UserQuestsPayload<ExtArgs>[]
      addressBook: Prisma.$AddressBookPayload<ExtArgs>[]
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
      logs: Prisma.$LogsPayload<ExtArgs>[]
      dns: Prisma.$DNSPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs>[]
      notifications: Prisma.$NotificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      password: string
      salt: string
      lastAction: Date
      created: Date
      refreshToken: string | null
      group: $Enums.Groups
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    session<T extends User$sessionArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    computer<T extends User$computerArgs<ExtArgs> = {}>(args?: Subset<T, User$computerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findMany'> | Null>;

    software<T extends User$softwareArgs<ExtArgs> = {}>(args?: Subset<T, User$softwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findMany'> | Null>;

    memory<T extends User$memoryArgs<ExtArgs> = {}>(args?: Subset<T, User$memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    process<T extends User$processArgs<ExtArgs> = {}>(args?: Subset<T, User$processArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findMany'> | Null>;

    userQuests<T extends User$userQuestsArgs<ExtArgs> = {}>(args?: Subset<T, User$userQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findMany'> | Null>;

    addressBook<T extends User$addressBookArgs<ExtArgs> = {}>(args?: Subset<T, User$addressBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    accountBook<T extends User$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, User$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findMany'> | Null>;

    dns<T extends User$dnsArgs<ExtArgs> = {}>(args?: Subset<T, User$dnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findMany'> | Null>;

    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findMany'> | Null>;

    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly salt: FieldRef<"User", 'String'>
    readonly lastAction: FieldRef<"User", 'DateTime'>
    readonly created: FieldRef<"User", 'DateTime'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly group: FieldRef<"User", 'Groups'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.session
   */
  export type User$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * User.computer
   */
  export type User$computerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    where?: ComputerWhereInput
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    cursor?: ComputerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }


  /**
   * User.software
   */
  export type User$softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    cursor?: SoftwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * User.memory
   */
  export type User$memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    cursor?: MemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }


  /**
   * User.process
   */
  export type User$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }


  /**
   * User.userQuests
   */
  export type User$userQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    cursor?: UserQuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }


  /**
   * User.addressBook
   */
  export type User$addressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    cursor?: AddressBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }


  /**
   * User.accountBook
   */
  export type User$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }


  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * User.dns
   */
  export type User$dnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    cursor?: DNSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }


  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    name: string | null
    started: Date | null
    ended: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    started: Date | null
    ended: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    name: number
    started: number
    ended: number
    _all: number
  }


  export type GameMinAggregateInputType = {
    id?: true
    name?: true
    started?: true
    ended?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    name?: true
    started?: true
    ended?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    name?: true
    started?: true
    ended?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    name: string
    started: Date
    ended: Date | null
    _count: GameCountAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    started?: boolean
    ended?: boolean
    software?: boolean | Game$softwareArgs<ExtArgs>
    hardware?: boolean | Game$hardwareArgs<ExtArgs>
    computer?: boolean | Game$computerArgs<ExtArgs>
    memory?: boolean | Game$memoryArgs<ExtArgs>
    process?: boolean | Game$processArgs<ExtArgs>
    quests?: boolean | Game$questsArgs<ExtArgs>
    userQuests?: boolean | Game$userQuestsArgs<ExtArgs>
    logs?: boolean | Game$logsArgs<ExtArgs>
    addressBook?: boolean | Game$addressBookArgs<ExtArgs>
    accountBook?: boolean | Game$accountBookArgs<ExtArgs>
    dns?: boolean | Game$dnsArgs<ExtArgs>
    profile?: boolean | Game$profileArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    name?: boolean
    started?: boolean
    ended?: boolean
  }

  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    software?: boolean | Game$softwareArgs<ExtArgs>
    hardware?: boolean | Game$hardwareArgs<ExtArgs>
    computer?: boolean | Game$computerArgs<ExtArgs>
    memory?: boolean | Game$memoryArgs<ExtArgs>
    process?: boolean | Game$processArgs<ExtArgs>
    quests?: boolean | Game$questsArgs<ExtArgs>
    userQuests?: boolean | Game$userQuestsArgs<ExtArgs>
    logs?: boolean | Game$logsArgs<ExtArgs>
    addressBook?: boolean | Game$addressBookArgs<ExtArgs>
    accountBook?: boolean | Game$accountBookArgs<ExtArgs>
    dns?: boolean | Game$dnsArgs<ExtArgs>
    profile?: boolean | Game$profileArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      software: Prisma.$SoftwarePayload<ExtArgs>[]
      hardware: Prisma.$HardwarePayload<ExtArgs>[]
      computer: Prisma.$ComputerPayload<ExtArgs>[]
      memory: Prisma.$MemoryPayload<ExtArgs>[]
      process: Prisma.$ProcessPayload<ExtArgs>[]
      quests: Prisma.$QuestsPayload<ExtArgs>[]
      userQuests: Prisma.$UserQuestsPayload<ExtArgs>[]
      logs: Prisma.$LogsPayload<ExtArgs>[]
      addressBook: Prisma.$AddressBookPayload<ExtArgs>[]
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
      dns: Prisma.$DNSPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      started: Date
      ended: Date | null
    }, ExtArgs["result"]["game"]>
    composites: {}
  }


  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Game that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
    **/
    create<T extends GameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GameCreateArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Games.
     *     @param {GameCreateManyArgs} args - Arguments to create many Games.
     *     @example
     *     // Create many Games
     *     const game = await prisma.game.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
    **/
    delete<T extends GameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GameDeleteArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GameUpdateArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
    **/
    upsert<T extends GameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GameUpsertArgs<ExtArgs>>
    ): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    software<T extends Game$softwareArgs<ExtArgs> = {}>(args?: Subset<T, Game$softwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findMany'> | Null>;

    hardware<T extends Game$hardwareArgs<ExtArgs> = {}>(args?: Subset<T, Game$hardwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'findMany'> | Null>;

    computer<T extends Game$computerArgs<ExtArgs> = {}>(args?: Subset<T, Game$computerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findMany'> | Null>;

    memory<T extends Game$memoryArgs<ExtArgs> = {}>(args?: Subset<T, Game$memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    process<T extends Game$processArgs<ExtArgs> = {}>(args?: Subset<T, Game$processArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findMany'> | Null>;

    quests<T extends Game$questsArgs<ExtArgs> = {}>(args?: Subset<T, Game$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'findMany'> | Null>;

    userQuests<T extends Game$userQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Game$userQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findMany'> | Null>;

    logs<T extends Game$logsArgs<ExtArgs> = {}>(args?: Subset<T, Game$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findMany'> | Null>;

    addressBook<T extends Game$addressBookArgs<ExtArgs> = {}>(args?: Subset<T, Game$addressBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    accountBook<T extends Game$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, Game$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    dns<T extends Game$dnsArgs<ExtArgs> = {}>(args?: Subset<T, Game$dnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findMany'> | Null>;

    profile<T extends Game$profileArgs<ExtArgs> = {}>(args?: Subset<T, Game$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Game model
   */ 
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly name: FieldRef<"Game", 'String'>
    readonly started: FieldRef<"Game", 'DateTime'>
    readonly ended: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }


  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }


  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }


  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }


  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }


  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }


  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }


  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }


  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }


  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }


  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
  }


  /**
   * Game.software
   */
  export type Game$softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    cursor?: SoftwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Game.hardware
   */
  export type Game$hardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    where?: HardwareWhereInput
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    cursor?: HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }


  /**
   * Game.computer
   */
  export type Game$computerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    where?: ComputerWhereInput
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    cursor?: ComputerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }


  /**
   * Game.memory
   */
  export type Game$memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    cursor?: MemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }


  /**
   * Game.process
   */
  export type Game$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }


  /**
   * Game.quests
   */
  export type Game$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    where?: QuestsWhereInput
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    cursor?: QuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }


  /**
   * Game.userQuests
   */
  export type Game$userQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    cursor?: UserQuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }


  /**
   * Game.logs
   */
  export type Game$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Game.addressBook
   */
  export type Game$addressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    cursor?: AddressBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }


  /**
   * Game.accountBook
   */
  export type Game$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }


  /**
   * Game.dns
   */
  export type Game$dnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    cursor?: DNSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }


  /**
   * Game.profile
   */
  export type Game$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude<ExtArgs> | null
  }



  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    token: string | null
    lastAction: Date | null
    created: Date | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    token: string | null
    lastAction: Date | null
    created: Date | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    lastAction: number
    created: number
    expires: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    lastAction?: true
    created?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    lastAction?: true
    created?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    lastAction?: true
    created?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: number
    token: string
    lastAction: Date
    created: Date
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    lastAction?: boolean
    created?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    lastAction?: boolean
    created?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      token: string
      lastAction: Date
      created: Date
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }


  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly token: FieldRef<"Session", 'String'>
    readonly lastAction: FieldRef<"Session", 'DateTime'>
    readonly created: FieldRef<"Session", 'DateTime'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
  }



  /**
   * Model Hardware
   */

  export type AggregateHardware = {
    _count: HardwareCountAggregateOutputType | null
    _avg: HardwareAvgAggregateOutputType | null
    _sum: HardwareSumAggregateOutputType | null
    _min: HardwareMinAggregateOutputType | null
    _max: HardwareMaxAggregateOutputType | null
  }

  export type HardwareAvgAggregateOutputType = {
    id: number | null
    strength: number | null
  }

  export type HardwareSumAggregateOutputType = {
    id: number | null
    strength: number | null
  }

  export type HardwareMinAggregateOutputType = {
    id: number | null
    computerId: string | null
    gameId: string | null
    type: $Enums.HardwareTypes | null
    strength: number | null
  }

  export type HardwareMaxAggregateOutputType = {
    id: number | null
    computerId: string | null
    gameId: string | null
    type: $Enums.HardwareTypes | null
    strength: number | null
  }

  export type HardwareCountAggregateOutputType = {
    id: number
    computerId: number
    gameId: number
    type: number
    strength: number
    _all: number
  }


  export type HardwareAvgAggregateInputType = {
    id?: true
    strength?: true
  }

  export type HardwareSumAggregateInputType = {
    id?: true
    strength?: true
  }

  export type HardwareMinAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    type?: true
    strength?: true
  }

  export type HardwareMaxAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    type?: true
    strength?: true
  }

  export type HardwareCountAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    type?: true
    strength?: true
    _all?: true
  }

  export type HardwareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hardware to aggregate.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hardware
    **/
    _count?: true | HardwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HardwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HardwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HardwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HardwareMaxAggregateInputType
  }

  export type GetHardwareAggregateType<T extends HardwareAggregateArgs> = {
        [P in keyof T & keyof AggregateHardware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHardware[P]>
      : GetScalarType<T[P], AggregateHardware[P]>
  }




  export type HardwareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HardwareWhereInput
    orderBy?: HardwareOrderByWithAggregationInput | HardwareOrderByWithAggregationInput[]
    by: HardwareScalarFieldEnum[] | HardwareScalarFieldEnum
    having?: HardwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HardwareCountAggregateInputType | true
    _avg?: HardwareAvgAggregateInputType
    _sum?: HardwareSumAggregateInputType
    _min?: HardwareMinAggregateInputType
    _max?: HardwareMaxAggregateInputType
  }

  export type HardwareGroupByOutputType = {
    id: number
    computerId: string
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
    _count: HardwareCountAggregateOutputType | null
    _avg: HardwareAvgAggregateOutputType | null
    _sum: HardwareSumAggregateOutputType | null
    _min: HardwareMinAggregateOutputType | null
    _max: HardwareMaxAggregateOutputType | null
  }

  type GetHardwareGroupByPayload<T extends HardwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HardwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HardwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HardwareGroupByOutputType[P]>
            : GetScalarType<T[P], HardwareGroupByOutputType[P]>
        }
      >
    >


  export type HardwareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    strength?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hardware"]>

  export type HardwareSelectScalar = {
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    strength?: boolean
  }

  export type HardwareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $HardwarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hardware"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      computerId: string
      gameId: string
      type: $Enums.HardwareTypes
      strength: number
    }, ExtArgs["result"]["hardware"]>
    composites: {}
  }


  type HardwareGetPayload<S extends boolean | null | undefined | HardwareDefaultArgs> = $Result.GetResult<Prisma.$HardwarePayload, S>

  type HardwareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HardwareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HardwareCountAggregateInputType | true
    }

  export interface HardwareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hardware'], meta: { name: 'Hardware' } }
    /**
     * Find zero or one Hardware that matches the filter.
     * @param {HardwareFindUniqueArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HardwareFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HardwareFindUniqueArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Hardware that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HardwareFindUniqueOrThrowArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HardwareFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HardwareFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindFirstArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HardwareFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HardwareFindFirstArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Hardware that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindFirstOrThrowArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HardwareFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HardwareFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hardware
     * const hardware = await prisma.hardware.findMany()
     * 
     * // Get first 10 Hardware
     * const hardware = await prisma.hardware.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hardwareWithIdOnly = await prisma.hardware.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HardwareFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HardwareFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Hardware.
     * @param {HardwareCreateArgs} args - Arguments to create a Hardware.
     * @example
     * // Create one Hardware
     * const Hardware = await prisma.hardware.create({
     *   data: {
     *     // ... data to create a Hardware
     *   }
     * })
     * 
    **/
    create<T extends HardwareCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HardwareCreateArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Hardware.
     *     @param {HardwareCreateManyArgs} args - Arguments to create many Hardware.
     *     @example
     *     // Create many Hardware
     *     const hardware = await prisma.hardware.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HardwareCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HardwareCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hardware.
     * @param {HardwareDeleteArgs} args - Arguments to delete one Hardware.
     * @example
     * // Delete one Hardware
     * const Hardware = await prisma.hardware.delete({
     *   where: {
     *     // ... filter to delete one Hardware
     *   }
     * })
     * 
    **/
    delete<T extends HardwareDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HardwareDeleteArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Hardware.
     * @param {HardwareUpdateArgs} args - Arguments to update one Hardware.
     * @example
     * // Update one Hardware
     * const hardware = await prisma.hardware.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HardwareUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HardwareUpdateArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Hardware.
     * @param {HardwareDeleteManyArgs} args - Arguments to filter Hardware to delete.
     * @example
     * // Delete a few Hardware
     * const { count } = await prisma.hardware.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HardwareDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HardwareDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hardware
     * const hardware = await prisma.hardware.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HardwareUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HardwareUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hardware.
     * @param {HardwareUpsertArgs} args - Arguments to update or create a Hardware.
     * @example
     * // Update or create a Hardware
     * const hardware = await prisma.hardware.upsert({
     *   create: {
     *     // ... data to create a Hardware
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hardware we want to update
     *   }
     * })
    **/
    upsert<T extends HardwareUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HardwareUpsertArgs<ExtArgs>>
    ): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCountArgs} args - Arguments to filter Hardware to count.
     * @example
     * // Count the number of Hardware
     * const count = await prisma.hardware.count({
     *   where: {
     *     // ... the filter for the Hardware we want to count
     *   }
     * })
    **/
    count<T extends HardwareCountArgs>(
      args?: Subset<T, HardwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HardwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HardwareAggregateArgs>(args: Subset<T, HardwareAggregateArgs>): Prisma.PrismaPromise<GetHardwareAggregateType<T>>

    /**
     * Group by Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HardwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HardwareGroupByArgs['orderBy'] }
        : { orderBy?: HardwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HardwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHardwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hardware model
   */
  readonly fields: HardwareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hardware.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HardwareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Hardware model
   */ 
  interface HardwareFieldRefs {
    readonly id: FieldRef<"Hardware", 'Int'>
    readonly computerId: FieldRef<"Hardware", 'String'>
    readonly gameId: FieldRef<"Hardware", 'String'>
    readonly type: FieldRef<"Hardware", 'HardwareTypes'>
    readonly strength: FieldRef<"Hardware", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * Hardware findUnique
   */
  export type HardwareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where: HardwareWhereUniqueInput
  }


  /**
   * Hardware findUniqueOrThrow
   */
  export type HardwareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where: HardwareWhereUniqueInput
  }


  /**
   * Hardware findFirst
   */
  export type HardwareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware.
     */
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }


  /**
   * Hardware findFirstOrThrow
   */
  export type HardwareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware.
     */
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }


  /**
   * Hardware findMany
   */
  export type HardwareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }


  /**
   * Hardware create
   */
  export type HardwareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * The data needed to create a Hardware.
     */
    data: XOR<HardwareCreateInput, HardwareUncheckedCreateInput>
  }


  /**
   * Hardware createMany
   */
  export type HardwareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hardware.
     */
    data: HardwareCreateManyInput | HardwareCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Hardware update
   */
  export type HardwareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * The data needed to update a Hardware.
     */
    data: XOR<HardwareUpdateInput, HardwareUncheckedUpdateInput>
    /**
     * Choose, which Hardware to update.
     */
    where: HardwareWhereUniqueInput
  }


  /**
   * Hardware updateMany
   */
  export type HardwareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hardware.
     */
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyInput>
    /**
     * Filter which Hardware to update
     */
    where?: HardwareWhereInput
  }


  /**
   * Hardware upsert
   */
  export type HardwareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * The filter to search for the Hardware to update in case it exists.
     */
    where: HardwareWhereUniqueInput
    /**
     * In case the Hardware found by the `where` argument doesn't exist, create a new Hardware with this data.
     */
    create: XOR<HardwareCreateInput, HardwareUncheckedCreateInput>
    /**
     * In case the Hardware was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HardwareUpdateInput, HardwareUncheckedUpdateInput>
  }


  /**
   * Hardware delete
   */
  export type HardwareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter which Hardware to delete.
     */
    where: HardwareWhereUniqueInput
  }


  /**
   * Hardware deleteMany
   */
  export type HardwareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hardware to delete
     */
    where?: HardwareWhereInput
  }


  /**
   * Hardware without action
   */
  export type HardwareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
  }



  /**
   * Model AddressBook
   */

  export type AggregateAddressBook = {
    _count: AddressBookCountAggregateOutputType | null
    _avg: AddressBookAvgAggregateOutputType | null
    _sum: AddressBookSumAggregateOutputType | null
    _min: AddressBookMinAggregateOutputType | null
    _max: AddressBookMaxAggregateOutputType | null
  }

  export type AddressBookAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressBookSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressBookMinAggregateOutputType = {
    id: number | null
    userId: number | null
    access: $Enums.AccessLevel | null
    computerId: string | null
    ip: string | null
    gameId: string | null
  }

  export type AddressBookMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    access: $Enums.AccessLevel | null
    computerId: string | null
    ip: string | null
    gameId: string | null
  }

  export type AddressBookCountAggregateOutputType = {
    id: number
    userId: number
    access: number
    computerId: number
    ip: number
    data: number
    gameId: number
    _all: number
  }


  export type AddressBookAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressBookSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressBookMinAggregateInputType = {
    id?: true
    userId?: true
    access?: true
    computerId?: true
    ip?: true
    gameId?: true
  }

  export type AddressBookMaxAggregateInputType = {
    id?: true
    userId?: true
    access?: true
    computerId?: true
    ip?: true
    gameId?: true
  }

  export type AddressBookCountAggregateInputType = {
    id?: true
    userId?: true
    access?: true
    computerId?: true
    ip?: true
    data?: true
    gameId?: true
    _all?: true
  }

  export type AddressBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressBook to aggregate.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddressBooks
    **/
    _count?: true | AddressBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressBookMaxAggregateInputType
  }

  export type GetAddressBookAggregateType<T extends AddressBookAggregateArgs> = {
        [P in keyof T & keyof AggregateAddressBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddressBook[P]>
      : GetScalarType<T[P], AggregateAddressBook[P]>
  }




  export type AddressBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithAggregationInput | AddressBookOrderByWithAggregationInput[]
    by: AddressBookScalarFieldEnum[] | AddressBookScalarFieldEnum
    having?: AddressBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressBookCountAggregateInputType | true
    _avg?: AddressBookAvgAggregateInputType
    _sum?: AddressBookSumAggregateInputType
    _min?: AddressBookMinAggregateInputType
    _max?: AddressBookMaxAggregateInputType
  }

  export type AddressBookGroupByOutputType = {
    id: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data: JsonValue
    gameId: string
    _count: AddressBookCountAggregateOutputType | null
    _avg: AddressBookAvgAggregateOutputType | null
    _sum: AddressBookSumAggregateOutputType | null
    _min: AddressBookMinAggregateOutputType | null
    _max: AddressBookMaxAggregateOutputType | null
  }

  type GetAddressBookGroupByPayload<T extends AddressBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressBookGroupByOutputType[P]>
            : GetScalarType<T[P], AddressBookGroupByOutputType[P]>
        }
      >
    >


  export type AddressBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    access?: boolean
    computerId?: boolean
    ip?: boolean
    data?: boolean
    gameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addressBook"]>

  export type AddressBookSelectScalar = {
    id?: boolean
    userId?: boolean
    access?: boolean
    computerId?: boolean
    ip?: boolean
    data?: boolean
    gameId?: boolean
  }

  export type AddressBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $AddressBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddressBook"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      access: $Enums.AccessLevel
      computerId: string
      ip: string
      data: Prisma.JsonValue
      gameId: string
    }, ExtArgs["result"]["addressBook"]>
    composites: {}
  }


  type AddressBookGetPayload<S extends boolean | null | undefined | AddressBookDefaultArgs> = $Result.GetResult<Prisma.$AddressBookPayload, S>

  type AddressBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressBookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressBookCountAggregateInputType | true
    }

  export interface AddressBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddressBook'], meta: { name: 'AddressBook' } }
    /**
     * Find zero or one AddressBook that matches the filter.
     * @param {AddressBookFindUniqueArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressBookFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressBookFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AddressBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressBookFindUniqueOrThrowArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressBookFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressBookFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AddressBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookFindFirstArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressBookFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressBookFindFirstArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AddressBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookFindFirstOrThrowArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressBookFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressBookFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AddressBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddressBooks
     * const addressBooks = await prisma.addressBook.findMany()
     * 
     * // Get first 10 AddressBooks
     * const addressBooks = await prisma.addressBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressBookWithIdOnly = await prisma.addressBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressBookFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressBookFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AddressBook.
     * @param {AddressBookCreateArgs} args - Arguments to create a AddressBook.
     * @example
     * // Create one AddressBook
     * const AddressBook = await prisma.addressBook.create({
     *   data: {
     *     // ... data to create a AddressBook
     *   }
     * })
     * 
    **/
    create<T extends AddressBookCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressBookCreateArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AddressBooks.
     *     @param {AddressBookCreateManyArgs} args - Arguments to create many AddressBooks.
     *     @example
     *     // Create many AddressBooks
     *     const addressBook = await prisma.addressBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressBookCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressBookCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddressBook.
     * @param {AddressBookDeleteArgs} args - Arguments to delete one AddressBook.
     * @example
     * // Delete one AddressBook
     * const AddressBook = await prisma.addressBook.delete({
     *   where: {
     *     // ... filter to delete one AddressBook
     *   }
     * })
     * 
    **/
    delete<T extends AddressBookDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressBookDeleteArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AddressBook.
     * @param {AddressBookUpdateArgs} args - Arguments to update one AddressBook.
     * @example
     * // Update one AddressBook
     * const addressBook = await prisma.addressBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressBookUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressBookUpdateArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AddressBooks.
     * @param {AddressBookDeleteManyArgs} args - Arguments to filter AddressBooks to delete.
     * @example
     * // Delete a few AddressBooks
     * const { count } = await prisma.addressBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressBookDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressBookDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddressBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddressBooks
     * const addressBook = await prisma.addressBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressBookUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressBookUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddressBook.
     * @param {AddressBookUpsertArgs} args - Arguments to update or create a AddressBook.
     * @example
     * // Update or create a AddressBook
     * const addressBook = await prisma.addressBook.upsert({
     *   create: {
     *     // ... data to create a AddressBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddressBook we want to update
     *   }
     * })
    **/
    upsert<T extends AddressBookUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressBookUpsertArgs<ExtArgs>>
    ): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AddressBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookCountArgs} args - Arguments to filter AddressBooks to count.
     * @example
     * // Count the number of AddressBooks
     * const count = await prisma.addressBook.count({
     *   where: {
     *     // ... the filter for the AddressBooks we want to count
     *   }
     * })
    **/
    count<T extends AddressBookCountArgs>(
      args?: Subset<T, AddressBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddressBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressBookAggregateArgs>(args: Subset<T, AddressBookAggregateArgs>): Prisma.PrismaPromise<GetAddressBookAggregateType<T>>

    /**
     * Group by AddressBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressBookGroupByArgs['orderBy'] }
        : { orderBy?: AddressBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddressBook model
   */
  readonly fields: AddressBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddressBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AddressBook model
   */ 
  interface AddressBookFieldRefs {
    readonly id: FieldRef<"AddressBook", 'Int'>
    readonly userId: FieldRef<"AddressBook", 'Int'>
    readonly access: FieldRef<"AddressBook", 'AccessLevel'>
    readonly computerId: FieldRef<"AddressBook", 'String'>
    readonly ip: FieldRef<"AddressBook", 'String'>
    readonly data: FieldRef<"AddressBook", 'Json'>
    readonly gameId: FieldRef<"AddressBook", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AddressBook findUnique
   */
  export type AddressBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where: AddressBookWhereUniqueInput
  }


  /**
   * AddressBook findUniqueOrThrow
   */
  export type AddressBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where: AddressBookWhereUniqueInput
  }


  /**
   * AddressBook findFirst
   */
  export type AddressBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressBooks.
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressBooks.
     */
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }


  /**
   * AddressBook findFirstOrThrow
   */
  export type AddressBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressBooks.
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressBooks.
     */
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }


  /**
   * AddressBook findMany
   */
  export type AddressBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBooks to fetch.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddressBooks.
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }


  /**
   * AddressBook create
   */
  export type AddressBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * The data needed to create a AddressBook.
     */
    data: XOR<AddressBookCreateInput, AddressBookUncheckedCreateInput>
  }


  /**
   * AddressBook createMany
   */
  export type AddressBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddressBooks.
     */
    data: AddressBookCreateManyInput | AddressBookCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AddressBook update
   */
  export type AddressBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * The data needed to update a AddressBook.
     */
    data: XOR<AddressBookUpdateInput, AddressBookUncheckedUpdateInput>
    /**
     * Choose, which AddressBook to update.
     */
    where: AddressBookWhereUniqueInput
  }


  /**
   * AddressBook updateMany
   */
  export type AddressBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddressBooks.
     */
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyInput>
    /**
     * Filter which AddressBooks to update
     */
    where?: AddressBookWhereInput
  }


  /**
   * AddressBook upsert
   */
  export type AddressBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * The filter to search for the AddressBook to update in case it exists.
     */
    where: AddressBookWhereUniqueInput
    /**
     * In case the AddressBook found by the `where` argument doesn't exist, create a new AddressBook with this data.
     */
    create: XOR<AddressBookCreateInput, AddressBookUncheckedCreateInput>
    /**
     * In case the AddressBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressBookUpdateInput, AddressBookUncheckedUpdateInput>
  }


  /**
   * AddressBook delete
   */
  export type AddressBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter which AddressBook to delete.
     */
    where: AddressBookWhereUniqueInput
  }


  /**
   * AddressBook deleteMany
   */
  export type AddressBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressBooks to delete
     */
    where?: AddressBookWhereInput
  }


  /**
   * AddressBook without action
   */
  export type AddressBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
  }



  /**
   * Model DNS
   */

  export type AggregateDNS = {
    _count: DNSCountAggregateOutputType | null
    _avg: DNSAvgAggregateOutputType | null
    _sum: DNSSumAggregateOutputType | null
    _min: DNSMinAggregateOutputType | null
    _max: DNSMaxAggregateOutputType | null
  }

  export type DNSAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DNSSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DNSMinAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    website: string | null
    tags: string | null
    description: string | null
    updated: Date | null
    created: Date | null
  }

  export type DNSMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    website: string | null
    tags: string | null
    description: string | null
    updated: Date | null
    created: Date | null
  }

  export type DNSCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    gameId: number
    website: number
    tags: number
    description: number
    updated: number
    created: number
    _all: number
  }


  export type DNSAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DNSSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DNSMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    website?: true
    tags?: true
    description?: true
    updated?: true
    created?: true
  }

  export type DNSMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    website?: true
    tags?: true
    description?: true
    updated?: true
    created?: true
  }

  export type DNSCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    website?: true
    tags?: true
    description?: true
    updated?: true
    created?: true
    _all?: true
  }

  export type DNSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DNS to aggregate.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DNS
    **/
    _count?: true | DNSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DNSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DNSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DNSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DNSMaxAggregateInputType
  }

  export type GetDNSAggregateType<T extends DNSAggregateArgs> = {
        [P in keyof T & keyof AggregateDNS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDNS[P]>
      : GetScalarType<T[P], AggregateDNS[P]>
  }




  export type DNSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithAggregationInput | DNSOrderByWithAggregationInput[]
    by: DNSScalarFieldEnum[] | DNSScalarFieldEnum
    having?: DNSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DNSCountAggregateInputType | true
    _avg?: DNSAvgAggregateInputType
    _sum?: DNSSumAggregateInputType
    _min?: DNSMinAggregateInputType
    _max?: DNSMaxAggregateInputType
  }

  export type DNSGroupByOutputType = {
    id: number
    userId: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description: string
    updated: Date
    created: Date
    _count: DNSCountAggregateOutputType | null
    _avg: DNSAvgAggregateOutputType | null
    _sum: DNSSumAggregateOutputType | null
    _min: DNSMinAggregateOutputType | null
    _max: DNSMaxAggregateOutputType | null
  }

  type GetDNSGroupByPayload<T extends DNSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DNSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DNSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DNSGroupByOutputType[P]>
            : GetScalarType<T[P], DNSGroupByOutputType[P]>
        }
      >
    >


  export type DNSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    website?: boolean
    tags?: boolean
    description?: boolean
    updated?: boolean
    created?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dNS"]>

  export type DNSSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    website?: boolean
    tags?: boolean
    description?: boolean
    updated?: boolean
    created?: boolean
  }

  export type DNSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $DNSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DNS"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      computerId: string
      gameId: string
      website: string
      tags: string
      description: string
      updated: Date
      created: Date
    }, ExtArgs["result"]["dNS"]>
    composites: {}
  }


  type DNSGetPayload<S extends boolean | null | undefined | DNSDefaultArgs> = $Result.GetResult<Prisma.$DNSPayload, S>

  type DNSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DNSFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DNSCountAggregateInputType | true
    }

  export interface DNSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DNS'], meta: { name: 'DNS' } }
    /**
     * Find zero or one DNS that matches the filter.
     * @param {DNSFindUniqueArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DNSFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DNSFindUniqueArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DNS that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DNSFindUniqueOrThrowArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DNSFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DNSFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSFindFirstArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DNSFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DNSFindFirstArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DNS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSFindFirstOrThrowArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DNSFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DNSFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DNS
     * const dNS = await prisma.dNS.findMany()
     * 
     * // Get first 10 DNS
     * const dNS = await prisma.dNS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dNSWithIdOnly = await prisma.dNS.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DNSFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DNSFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DNS.
     * @param {DNSCreateArgs} args - Arguments to create a DNS.
     * @example
     * // Create one DNS
     * const DNS = await prisma.dNS.create({
     *   data: {
     *     // ... data to create a DNS
     *   }
     * })
     * 
    **/
    create<T extends DNSCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DNSCreateArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DNS.
     *     @param {DNSCreateManyArgs} args - Arguments to create many DNS.
     *     @example
     *     // Create many DNS
     *     const dNS = await prisma.dNS.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DNSCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DNSCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DNS.
     * @param {DNSDeleteArgs} args - Arguments to delete one DNS.
     * @example
     * // Delete one DNS
     * const DNS = await prisma.dNS.delete({
     *   where: {
     *     // ... filter to delete one DNS
     *   }
     * })
     * 
    **/
    delete<T extends DNSDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DNSDeleteArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DNS.
     * @param {DNSUpdateArgs} args - Arguments to update one DNS.
     * @example
     * // Update one DNS
     * const dNS = await prisma.dNS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DNSUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DNSUpdateArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DNS.
     * @param {DNSDeleteManyArgs} args - Arguments to filter DNS to delete.
     * @example
     * // Delete a few DNS
     * const { count } = await prisma.dNS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DNSDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DNSDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DNS
     * const dNS = await prisma.dNS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DNSUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DNSUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DNS.
     * @param {DNSUpsertArgs} args - Arguments to update or create a DNS.
     * @example
     * // Update or create a DNS
     * const dNS = await prisma.dNS.upsert({
     *   create: {
     *     // ... data to create a DNS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DNS we want to update
     *   }
     * })
    **/
    upsert<T extends DNSUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DNSUpsertArgs<ExtArgs>>
    ): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSCountArgs} args - Arguments to filter DNS to count.
     * @example
     * // Count the number of DNS
     * const count = await prisma.dNS.count({
     *   where: {
     *     // ... the filter for the DNS we want to count
     *   }
     * })
    **/
    count<T extends DNSCountArgs>(
      args?: Subset<T, DNSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DNSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DNSAggregateArgs>(args: Subset<T, DNSAggregateArgs>): Prisma.PrismaPromise<GetDNSAggregateType<T>>

    /**
     * Group by DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DNSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DNSGroupByArgs['orderBy'] }
        : { orderBy?: DNSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DNSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDNSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DNS model
   */
  readonly fields: DNSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DNS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DNSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DNS model
   */ 
  interface DNSFieldRefs {
    readonly id: FieldRef<"DNS", 'Int'>
    readonly userId: FieldRef<"DNS", 'Int'>
    readonly computerId: FieldRef<"DNS", 'String'>
    readonly gameId: FieldRef<"DNS", 'String'>
    readonly website: FieldRef<"DNS", 'String'>
    readonly tags: FieldRef<"DNS", 'String'>
    readonly description: FieldRef<"DNS", 'String'>
    readonly updated: FieldRef<"DNS", 'DateTime'>
    readonly created: FieldRef<"DNS", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DNS findUnique
   */
  export type DNSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where: DNSWhereUniqueInput
  }


  /**
   * DNS findUniqueOrThrow
   */
  export type DNSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where: DNSWhereUniqueInput
  }


  /**
   * DNS findFirst
   */
  export type DNSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DNS.
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DNS.
     */
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }


  /**
   * DNS findFirstOrThrow
   */
  export type DNSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DNS.
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DNS.
     */
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }


  /**
   * DNS findMany
   */
  export type DNSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DNS.
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }


  /**
   * DNS create
   */
  export type DNSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * The data needed to create a DNS.
     */
    data: XOR<DNSCreateInput, DNSUncheckedCreateInput>
  }


  /**
   * DNS createMany
   */
  export type DNSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DNS.
     */
    data: DNSCreateManyInput | DNSCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DNS update
   */
  export type DNSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * The data needed to update a DNS.
     */
    data: XOR<DNSUpdateInput, DNSUncheckedUpdateInput>
    /**
     * Choose, which DNS to update.
     */
    where: DNSWhereUniqueInput
  }


  /**
   * DNS updateMany
   */
  export type DNSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DNS.
     */
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyInput>
    /**
     * Filter which DNS to update
     */
    where?: DNSWhereInput
  }


  /**
   * DNS upsert
   */
  export type DNSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * The filter to search for the DNS to update in case it exists.
     */
    where: DNSWhereUniqueInput
    /**
     * In case the DNS found by the `where` argument doesn't exist, create a new DNS with this data.
     */
    create: XOR<DNSCreateInput, DNSUncheckedCreateInput>
    /**
     * In case the DNS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DNSUpdateInput, DNSUncheckedUpdateInput>
  }


  /**
   * DNS delete
   */
  export type DNSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter which DNS to delete.
     */
    where: DNSWhereUniqueInput
  }


  /**
   * DNS deleteMany
   */
  export type DNSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DNS to delete
     */
    where?: DNSWhereInput
  }


  /**
   * DNS without action
   */
  export type DNSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
  }



  /**
   * Model AccountBook
   */

  export type AggregateAccountBook = {
    _count: AccountBookCountAggregateOutputType | null
    _avg: AccountBookAvgAggregateOutputType | null
    _sum: AccountBookSumAggregateOutputType | null
    _min: AccountBookMinAggregateOutputType | null
    _max: AccountBookMaxAggregateOutputType | null
  }

  export type AccountBookAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccountBookSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccountBookMinAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    memoryId: string | null
    gameId: string | null
  }

  export type AccountBookMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    memoryId: string | null
    gameId: string | null
  }

  export type AccountBookCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    memoryId: number
    data: number
    gameId: number
    _all: number
  }


  export type AccountBookAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountBookSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountBookMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    memoryId?: true
    gameId?: true
  }

  export type AccountBookMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    memoryId?: true
    gameId?: true
  }

  export type AccountBookCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    memoryId?: true
    data?: true
    gameId?: true
    _all?: true
  }

  export type AccountBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBook to aggregate.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountBooks
    **/
    _count?: true | AccountBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountBookMaxAggregateInputType
  }

  export type GetAccountBookAggregateType<T extends AccountBookAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountBook[P]>
      : GetScalarType<T[P], AggregateAccountBook[P]>
  }




  export type AccountBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithAggregationInput | AccountBookOrderByWithAggregationInput[]
    by: AccountBookScalarFieldEnum[] | AccountBookScalarFieldEnum
    having?: AccountBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountBookCountAggregateInputType | true
    _avg?: AccountBookAvgAggregateInputType
    _sum?: AccountBookSumAggregateInputType
    _min?: AccountBookMinAggregateInputType
    _max?: AccountBookMaxAggregateInputType
  }

  export type AccountBookGroupByOutputType = {
    id: number
    userId: number
    computerId: string
    memoryId: string
    data: JsonValue
    gameId: string
    _count: AccountBookCountAggregateOutputType | null
    _avg: AccountBookAvgAggregateOutputType | null
    _sum: AccountBookSumAggregateOutputType | null
    _min: AccountBookMinAggregateOutputType | null
    _max: AccountBookMaxAggregateOutputType | null
  }

  type GetAccountBookGroupByPayload<T extends AccountBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountBookGroupByOutputType[P]>
            : GetScalarType<T[P], AccountBookGroupByOutputType[P]>
        }
      >
    >


  export type AccountBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    memoryId?: boolean
    data?: boolean
    gameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    memory?: boolean | MemoryDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountBook"]>

  export type AccountBookSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    memoryId?: boolean
    data?: boolean
    gameId?: boolean
  }

  export type AccountBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    memory?: boolean | MemoryDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $AccountBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountBook"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      computer: Prisma.$ComputerPayload<ExtArgs>
      memory: Prisma.$MemoryPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      computerId: string
      memoryId: string
      data: Prisma.JsonValue
      gameId: string
    }, ExtArgs["result"]["accountBook"]>
    composites: {}
  }


  type AccountBookGetPayload<S extends boolean | null | undefined | AccountBookDefaultArgs> = $Result.GetResult<Prisma.$AccountBookPayload, S>

  type AccountBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountBookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountBookCountAggregateInputType | true
    }

  export interface AccountBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountBook'], meta: { name: 'AccountBook' } }
    /**
     * Find zero or one AccountBook that matches the filter.
     * @param {AccountBookFindUniqueArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountBookFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountBookFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AccountBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountBookFindUniqueOrThrowArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountBookFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountBookFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AccountBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookFindFirstArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountBookFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountBookFindFirstArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AccountBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookFindFirstOrThrowArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountBookFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountBookFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AccountBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountBooks
     * const accountBooks = await prisma.accountBook.findMany()
     * 
     * // Get first 10 AccountBooks
     * const accountBooks = await prisma.accountBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountBookWithIdOnly = await prisma.accountBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountBookFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountBookFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AccountBook.
     * @param {AccountBookCreateArgs} args - Arguments to create a AccountBook.
     * @example
     * // Create one AccountBook
     * const AccountBook = await prisma.accountBook.create({
     *   data: {
     *     // ... data to create a AccountBook
     *   }
     * })
     * 
    **/
    create<T extends AccountBookCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountBookCreateArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AccountBooks.
     *     @param {AccountBookCreateManyArgs} args - Arguments to create many AccountBooks.
     *     @example
     *     // Create many AccountBooks
     *     const accountBook = await prisma.accountBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountBookCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountBookCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountBook.
     * @param {AccountBookDeleteArgs} args - Arguments to delete one AccountBook.
     * @example
     * // Delete one AccountBook
     * const AccountBook = await prisma.accountBook.delete({
     *   where: {
     *     // ... filter to delete one AccountBook
     *   }
     * })
     * 
    **/
    delete<T extends AccountBookDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountBookDeleteArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AccountBook.
     * @param {AccountBookUpdateArgs} args - Arguments to update one AccountBook.
     * @example
     * // Update one AccountBook
     * const accountBook = await prisma.accountBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountBookUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountBookUpdateArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AccountBooks.
     * @param {AccountBookDeleteManyArgs} args - Arguments to filter AccountBooks to delete.
     * @example
     * // Delete a few AccountBooks
     * const { count } = await prisma.accountBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountBookDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountBookDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountBooks
     * const accountBook = await prisma.accountBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountBookUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountBookUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountBook.
     * @param {AccountBookUpsertArgs} args - Arguments to update or create a AccountBook.
     * @example
     * // Update or create a AccountBook
     * const accountBook = await prisma.accountBook.upsert({
     *   create: {
     *     // ... data to create a AccountBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountBook we want to update
     *   }
     * })
    **/
    upsert<T extends AccountBookUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountBookUpsertArgs<ExtArgs>>
    ): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AccountBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookCountArgs} args - Arguments to filter AccountBooks to count.
     * @example
     * // Count the number of AccountBooks
     * const count = await prisma.accountBook.count({
     *   where: {
     *     // ... the filter for the AccountBooks we want to count
     *   }
     * })
    **/
    count<T extends AccountBookCountArgs>(
      args?: Subset<T, AccountBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountBookAggregateArgs>(args: Subset<T, AccountBookAggregateArgs>): Prisma.PrismaPromise<GetAccountBookAggregateType<T>>

    /**
     * Group by AccountBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountBookGroupByArgs['orderBy'] }
        : { orderBy?: AccountBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountBook model
   */
  readonly fields: AccountBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    memory<T extends MemoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemoryDefaultArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AccountBook model
   */ 
  interface AccountBookFieldRefs {
    readonly id: FieldRef<"AccountBook", 'Int'>
    readonly userId: FieldRef<"AccountBook", 'Int'>
    readonly computerId: FieldRef<"AccountBook", 'String'>
    readonly memoryId: FieldRef<"AccountBook", 'String'>
    readonly data: FieldRef<"AccountBook", 'Json'>
    readonly gameId: FieldRef<"AccountBook", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AccountBook findUnique
   */
  export type AccountBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where: AccountBookWhereUniqueInput
  }


  /**
   * AccountBook findUniqueOrThrow
   */
  export type AccountBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where: AccountBookWhereUniqueInput
  }


  /**
   * AccountBook findFirst
   */
  export type AccountBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBooks.
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBooks.
     */
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }


  /**
   * AccountBook findFirstOrThrow
   */
  export type AccountBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBooks.
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBooks.
     */
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }


  /**
   * AccountBook findMany
   */
  export type AccountBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBooks to fetch.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountBooks.
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }


  /**
   * AccountBook create
   */
  export type AccountBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountBook.
     */
    data: XOR<AccountBookCreateInput, AccountBookUncheckedCreateInput>
  }


  /**
   * AccountBook createMany
   */
  export type AccountBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountBooks.
     */
    data: AccountBookCreateManyInput | AccountBookCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AccountBook update
   */
  export type AccountBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountBook.
     */
    data: XOR<AccountBookUpdateInput, AccountBookUncheckedUpdateInput>
    /**
     * Choose, which AccountBook to update.
     */
    where: AccountBookWhereUniqueInput
  }


  /**
   * AccountBook updateMany
   */
  export type AccountBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountBooks.
     */
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyInput>
    /**
     * Filter which AccountBooks to update
     */
    where?: AccountBookWhereInput
  }


  /**
   * AccountBook upsert
   */
  export type AccountBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountBook to update in case it exists.
     */
    where: AccountBookWhereUniqueInput
    /**
     * In case the AccountBook found by the `where` argument doesn't exist, create a new AccountBook with this data.
     */
    create: XOR<AccountBookCreateInput, AccountBookUncheckedCreateInput>
    /**
     * In case the AccountBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountBookUpdateInput, AccountBookUncheckedUpdateInput>
  }


  /**
   * AccountBook delete
   */
  export type AccountBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter which AccountBook to delete.
     */
    where: AccountBookWhereUniqueInput
  }


  /**
   * AccountBook deleteMany
   */
  export type AccountBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBooks to delete
     */
    where?: AccountBookWhereInput
  }


  /**
   * AccountBook without action
   */
  export type AccountBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
  }



  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    data: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    data?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: number
    userId: number
    gameId: string
    data: JsonValue
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    data?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    data?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      gameId: string
      data: Prisma.JsonValue
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }


  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'Int'>
    readonly userId: FieldRef<"Profile", 'Int'>
    readonly gameId: FieldRef<"Profile", 'String'>
    readonly data: FieldRef<"Profile", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
  }



  /**
   * Model Memory
   */

  export type AggregateMemory = {
    _count: MemoryCountAggregateOutputType | null
    _avg: MemoryAvgAggregateOutputType | null
    _sum: MemorySumAggregateOutputType | null
    _min: MemoryMinAggregateOutputType | null
    _max: MemoryMaxAggregateOutputType | null
  }

  export type MemoryAvgAggregateOutputType = {
    userId: number | null
    value: number | null
  }

  export type MemorySumAggregateOutputType = {
    userId: number | null
    value: number | null
  }

  export type MemoryMinAggregateOutputType = {
    id: string | null
    computerId: string | null
    gameId: string | null
    userId: number | null
    type: string | null
    key: string | null
    value: number | null
  }

  export type MemoryMaxAggregateOutputType = {
    id: string | null
    computerId: string | null
    gameId: string | null
    userId: number | null
    type: string | null
    key: string | null
    value: number | null
  }

  export type MemoryCountAggregateOutputType = {
    id: number
    computerId: number
    gameId: number
    userId: number
    type: number
    key: number
    value: number
    data: number
    _all: number
  }


  export type MemoryAvgAggregateInputType = {
    userId?: true
    value?: true
  }

  export type MemorySumAggregateInputType = {
    userId?: true
    value?: true
  }

  export type MemoryMinAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    userId?: true
    type?: true
    key?: true
    value?: true
  }

  export type MemoryMaxAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    userId?: true
    type?: true
    key?: true
    value?: true
  }

  export type MemoryCountAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    userId?: true
    type?: true
    key?: true
    value?: true
    data?: true
    _all?: true
  }

  export type MemoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memory to aggregate.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memories
    **/
    _count?: true | MemoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemoryMaxAggregateInputType
  }

  export type GetMemoryAggregateType<T extends MemoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMemory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemory[P]>
      : GetScalarType<T[P], AggregateMemory[P]>
  }




  export type MemoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithAggregationInput | MemoryOrderByWithAggregationInput[]
    by: MemoryScalarFieldEnum[] | MemoryScalarFieldEnum
    having?: MemoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemoryCountAggregateInputType | true
    _avg?: MemoryAvgAggregateInputType
    _sum?: MemorySumAggregateInputType
    _min?: MemoryMinAggregateInputType
    _max?: MemoryMaxAggregateInputType
  }

  export type MemoryGroupByOutputType = {
    id: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value: number | null
    data: JsonValue
    _count: MemoryCountAggregateOutputType | null
    _avg: MemoryAvgAggregateOutputType | null
    _sum: MemorySumAggregateOutputType | null
    _min: MemoryMinAggregateOutputType | null
    _max: MemoryMaxAggregateOutputType | null
  }

  type GetMemoryGroupByPayload<T extends MemoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemoryGroupByOutputType[P]>
            : GetScalarType<T[P], MemoryGroupByOutputType[P]>
        }
      >
    >


  export type MemorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    data?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountBook?: boolean | Memory$accountBookArgs<ExtArgs>
    _count?: boolean | MemoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memory"]>

  export type MemorySelectScalar = {
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    data?: boolean
  }

  export type MemoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountBook?: boolean | Memory$accountBookArgs<ExtArgs>
    _count?: boolean | MemoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MemoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Memory"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      computerId: string
      gameId: string
      userId: number
      type: string
      key: string
      value: number | null
      data: Prisma.JsonValue
    }, ExtArgs["result"]["memory"]>
    composites: {}
  }


  type MemoryGetPayload<S extends boolean | null | undefined | MemoryDefaultArgs> = $Result.GetResult<Prisma.$MemoryPayload, S>

  type MemoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemoryCountAggregateInputType | true
    }

  export interface MemoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Memory'], meta: { name: 'Memory' } }
    /**
     * Find zero or one Memory that matches the filter.
     * @param {MemoryFindUniqueArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemoryFindUniqueArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Memory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemoryFindUniqueOrThrowArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Memory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryFindFirstArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemoryFindFirstArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Memory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryFindFirstOrThrowArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Memories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memories
     * const memories = await prisma.memory.findMany()
     * 
     * // Get first 10 Memories
     * const memories = await prisma.memory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memoryWithIdOnly = await prisma.memory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Memory.
     * @param {MemoryCreateArgs} args - Arguments to create a Memory.
     * @example
     * // Create one Memory
     * const Memory = await prisma.memory.create({
     *   data: {
     *     // ... data to create a Memory
     *   }
     * })
     * 
    **/
    create<T extends MemoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemoryCreateArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Memories.
     *     @param {MemoryCreateManyArgs} args - Arguments to create many Memories.
     *     @example
     *     // Create many Memories
     *     const memory = await prisma.memory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Memory.
     * @param {MemoryDeleteArgs} args - Arguments to delete one Memory.
     * @example
     * // Delete one Memory
     * const Memory = await prisma.memory.delete({
     *   where: {
     *     // ... filter to delete one Memory
     *   }
     * })
     * 
    **/
    delete<T extends MemoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemoryDeleteArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Memory.
     * @param {MemoryUpdateArgs} args - Arguments to update one Memory.
     * @example
     * // Update one Memory
     * const memory = await prisma.memory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemoryUpdateArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Memories.
     * @param {MemoryDeleteManyArgs} args - Arguments to filter Memories to delete.
     * @example
     * // Delete a few Memories
     * const { count } = await prisma.memory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memories
     * const memory = await prisma.memory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Memory.
     * @param {MemoryUpsertArgs} args - Arguments to update or create a Memory.
     * @example
     * // Update or create a Memory
     * const memory = await prisma.memory.upsert({
     *   create: {
     *     // ... data to create a Memory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Memory we want to update
     *   }
     * })
    **/
    upsert<T extends MemoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemoryUpsertArgs<ExtArgs>>
    ): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryCountArgs} args - Arguments to filter Memories to count.
     * @example
     * // Count the number of Memories
     * const count = await prisma.memory.count({
     *   where: {
     *     // ... the filter for the Memories we want to count
     *   }
     * })
    **/
    count<T extends MemoryCountArgs>(
      args?: Subset<T, MemoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemoryAggregateArgs>(args: Subset<T, MemoryAggregateArgs>): Prisma.PrismaPromise<GetMemoryAggregateType<T>>

    /**
     * Group by Memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemoryGroupByArgs['orderBy'] }
        : { orderBy?: MemoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Memory model
   */
  readonly fields: MemoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Memory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    accountBook<T extends Memory$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, Memory$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Memory model
   */ 
  interface MemoryFieldRefs {
    readonly id: FieldRef<"Memory", 'String'>
    readonly computerId: FieldRef<"Memory", 'String'>
    readonly gameId: FieldRef<"Memory", 'String'>
    readonly userId: FieldRef<"Memory", 'Int'>
    readonly type: FieldRef<"Memory", 'String'>
    readonly key: FieldRef<"Memory", 'String'>
    readonly value: FieldRef<"Memory", 'Float'>
    readonly data: FieldRef<"Memory", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Memory findUnique
   */
  export type MemoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where: MemoryWhereUniqueInput
  }


  /**
   * Memory findUniqueOrThrow
   */
  export type MemoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where: MemoryWhereUniqueInput
  }


  /**
   * Memory findFirst
   */
  export type MemoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memories.
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memories.
     */
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }


  /**
   * Memory findFirstOrThrow
   */
  export type MemoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memories.
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memories.
     */
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }


  /**
   * Memory findMany
   */
  export type MemoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memories to fetch.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memories.
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }


  /**
   * Memory create
   */
  export type MemoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Memory.
     */
    data: XOR<MemoryCreateInput, MemoryUncheckedCreateInput>
  }


  /**
   * Memory createMany
   */
  export type MemoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memories.
     */
    data: MemoryCreateManyInput | MemoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Memory update
   */
  export type MemoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Memory.
     */
    data: XOR<MemoryUpdateInput, MemoryUncheckedUpdateInput>
    /**
     * Choose, which Memory to update.
     */
    where: MemoryWhereUniqueInput
  }


  /**
   * Memory updateMany
   */
  export type MemoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memories.
     */
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyInput>
    /**
     * Filter which Memories to update
     */
    where?: MemoryWhereInput
  }


  /**
   * Memory upsert
   */
  export type MemoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Memory to update in case it exists.
     */
    where: MemoryWhereUniqueInput
    /**
     * In case the Memory found by the `where` argument doesn't exist, create a new Memory with this data.
     */
    create: XOR<MemoryCreateInput, MemoryUncheckedCreateInput>
    /**
     * In case the Memory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemoryUpdateInput, MemoryUncheckedUpdateInput>
  }


  /**
   * Memory delete
   */
  export type MemoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter which Memory to delete.
     */
    where: MemoryWhereUniqueInput
  }


  /**
   * Memory deleteMany
   */
  export type MemoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memories to delete
     */
    where?: MemoryWhereInput
  }


  /**
   * Memory.accountBook
   */
  export type Memory$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }


  /**
   * Memory without action
   */
  export type MemoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
  }



  /**
   * Model Computer
   */

  export type AggregateComputer = {
    _count: ComputerCountAggregateOutputType | null
    _avg: ComputerAvgAggregateOutputType | null
    _sum: ComputerSumAggregateOutputType | null
    _min: ComputerMinAggregateOutputType | null
    _max: ComputerMaxAggregateOutputType | null
  }

  export type ComputerAvgAggregateOutputType = {
    userId: number | null
  }

  export type ComputerSumAggregateOutputType = {
    userId: number | null
  }

  export type ComputerMinAggregateOutputType = {
    id: string | null
    userId: number | null
    type: string | null
    gameId: string | null
    ip: string | null
    created: Date | null
    updated: Date | null
  }

  export type ComputerMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    type: string | null
    gameId: string | null
    ip: string | null
    created: Date | null
    updated: Date | null
  }

  export type ComputerCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    gameId: number
    ip: number
    data: number
    created: number
    updated: number
    _all: number
  }


  export type ComputerAvgAggregateInputType = {
    userId?: true
  }

  export type ComputerSumAggregateInputType = {
    userId?: true
  }

  export type ComputerMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    gameId?: true
    ip?: true
    created?: true
    updated?: true
  }

  export type ComputerMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    gameId?: true
    ip?: true
    created?: true
    updated?: true
  }

  export type ComputerCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    gameId?: true
    ip?: true
    data?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type ComputerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Computer to aggregate.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Computers
    **/
    _count?: true | ComputerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComputerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComputerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComputerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComputerMaxAggregateInputType
  }

  export type GetComputerAggregateType<T extends ComputerAggregateArgs> = {
        [P in keyof T & keyof AggregateComputer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComputer[P]>
      : GetScalarType<T[P], AggregateComputer[P]>
  }




  export type ComputerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComputerWhereInput
    orderBy?: ComputerOrderByWithAggregationInput | ComputerOrderByWithAggregationInput[]
    by: ComputerScalarFieldEnum[] | ComputerScalarFieldEnum
    having?: ComputerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComputerCountAggregateInputType | true
    _avg?: ComputerAvgAggregateInputType
    _sum?: ComputerSumAggregateInputType
    _min?: ComputerMinAggregateInputType
    _max?: ComputerMaxAggregateInputType
  }

  export type ComputerGroupByOutputType = {
    id: string
    userId: number
    type: string
    gameId: string
    ip: string
    data: JsonValue
    created: Date
    updated: Date
    _count: ComputerCountAggregateOutputType | null
    _avg: ComputerAvgAggregateOutputType | null
    _sum: ComputerSumAggregateOutputType | null
    _min: ComputerMinAggregateOutputType | null
    _max: ComputerMaxAggregateOutputType | null
  }

  type GetComputerGroupByPayload<T extends ComputerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComputerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComputerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComputerGroupByOutputType[P]>
            : GetScalarType<T[P], ComputerGroupByOutputType[P]>
        }
      >
    >


  export type ComputerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    gameId?: boolean
    ip?: boolean
    data?: boolean
    created?: boolean
    updated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    dns?: boolean | Computer$dnsArgs<ExtArgs>
    hardware?: boolean | Computer$hardwareArgs<ExtArgs>
    software?: boolean | Computer$softwareArgs<ExtArgs>
    memory?: boolean | Computer$memoryArgs<ExtArgs>
    process?: boolean | Computer$processArgs<ExtArgs>
    addressBook?: boolean | Computer$addressBookArgs<ExtArgs>
    accountBook?: boolean | Computer$accountBookArgs<ExtArgs>
    logs?: boolean | Computer$logsArgs<ExtArgs>
    _count?: boolean | ComputerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["computer"]>

  export type ComputerSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    gameId?: boolean
    ip?: boolean
    data?: boolean
    created?: boolean
    updated?: boolean
  }

  export type ComputerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    dns?: boolean | Computer$dnsArgs<ExtArgs>
    hardware?: boolean | Computer$hardwareArgs<ExtArgs>
    software?: boolean | Computer$softwareArgs<ExtArgs>
    memory?: boolean | Computer$memoryArgs<ExtArgs>
    process?: boolean | Computer$processArgs<ExtArgs>
    addressBook?: boolean | Computer$addressBookArgs<ExtArgs>
    accountBook?: boolean | Computer$accountBookArgs<ExtArgs>
    logs?: boolean | Computer$logsArgs<ExtArgs>
    _count?: boolean | ComputerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ComputerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Computer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      dns: Prisma.$DNSPayload<ExtArgs>[]
      hardware: Prisma.$HardwarePayload<ExtArgs>[]
      software: Prisma.$SoftwarePayload<ExtArgs>[]
      memory: Prisma.$MemoryPayload<ExtArgs>[]
      process: Prisma.$ProcessPayload<ExtArgs>[]
      addressBook: Prisma.$AddressBookPayload<ExtArgs>[]
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
      logs: Prisma.$LogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      type: string
      gameId: string
      ip: string
      data: Prisma.JsonValue
      created: Date
      updated: Date
    }, ExtArgs["result"]["computer"]>
    composites: {}
  }


  type ComputerGetPayload<S extends boolean | null | undefined | ComputerDefaultArgs> = $Result.GetResult<Prisma.$ComputerPayload, S>

  type ComputerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComputerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComputerCountAggregateInputType | true
    }

  export interface ComputerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Computer'], meta: { name: 'Computer' } }
    /**
     * Find zero or one Computer that matches the filter.
     * @param {ComputerFindUniqueArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComputerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ComputerFindUniqueArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Computer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ComputerFindUniqueOrThrowArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ComputerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComputerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Computer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerFindFirstArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComputerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ComputerFindFirstArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Computer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerFindFirstOrThrowArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ComputerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComputerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Computers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Computers
     * const computers = await prisma.computer.findMany()
     * 
     * // Get first 10 Computers
     * const computers = await prisma.computer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const computerWithIdOnly = await prisma.computer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ComputerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComputerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Computer.
     * @param {ComputerCreateArgs} args - Arguments to create a Computer.
     * @example
     * // Create one Computer
     * const Computer = await prisma.computer.create({
     *   data: {
     *     // ... data to create a Computer
     *   }
     * })
     * 
    **/
    create<T extends ComputerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ComputerCreateArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Computers.
     *     @param {ComputerCreateManyArgs} args - Arguments to create many Computers.
     *     @example
     *     // Create many Computers
     *     const computer = await prisma.computer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComputerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComputerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Computer.
     * @param {ComputerDeleteArgs} args - Arguments to delete one Computer.
     * @example
     * // Delete one Computer
     * const Computer = await prisma.computer.delete({
     *   where: {
     *     // ... filter to delete one Computer
     *   }
     * })
     * 
    **/
    delete<T extends ComputerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ComputerDeleteArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Computer.
     * @param {ComputerUpdateArgs} args - Arguments to update one Computer.
     * @example
     * // Update one Computer
     * const computer = await prisma.computer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComputerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ComputerUpdateArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Computers.
     * @param {ComputerDeleteManyArgs} args - Arguments to filter Computers to delete.
     * @example
     * // Delete a few Computers
     * const { count } = await prisma.computer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComputerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComputerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Computers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Computers
     * const computer = await prisma.computer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComputerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ComputerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Computer.
     * @param {ComputerUpsertArgs} args - Arguments to update or create a Computer.
     * @example
     * // Update or create a Computer
     * const computer = await prisma.computer.upsert({
     *   create: {
     *     // ... data to create a Computer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Computer we want to update
     *   }
     * })
    **/
    upsert<T extends ComputerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ComputerUpsertArgs<ExtArgs>>
    ): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Computers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerCountArgs} args - Arguments to filter Computers to count.
     * @example
     * // Count the number of Computers
     * const count = await prisma.computer.count({
     *   where: {
     *     // ... the filter for the Computers we want to count
     *   }
     * })
    **/
    count<T extends ComputerCountArgs>(
      args?: Subset<T, ComputerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComputerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Computer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComputerAggregateArgs>(args: Subset<T, ComputerAggregateArgs>): Prisma.PrismaPromise<GetComputerAggregateType<T>>

    /**
     * Group by Computer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComputerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComputerGroupByArgs['orderBy'] }
        : { orderBy?: ComputerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComputerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComputerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Computer model
   */
  readonly fields: ComputerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Computer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComputerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dns<T extends Computer$dnsArgs<ExtArgs> = {}>(args?: Subset<T, Computer$dnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, 'findMany'> | Null>;

    hardware<T extends Computer$hardwareArgs<ExtArgs> = {}>(args?: Subset<T, Computer$hardwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, 'findMany'> | Null>;

    software<T extends Computer$softwareArgs<ExtArgs> = {}>(args?: Subset<T, Computer$softwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findMany'> | Null>;

    memory<T extends Computer$memoryArgs<ExtArgs> = {}>(args?: Subset<T, Computer$memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    process<T extends Computer$processArgs<ExtArgs> = {}>(args?: Subset<T, Computer$processArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findMany'> | Null>;

    addressBook<T extends Computer$addressBookArgs<ExtArgs> = {}>(args?: Subset<T, Computer$addressBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    accountBook<T extends Computer$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, Computer$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    logs<T extends Computer$logsArgs<ExtArgs> = {}>(args?: Subset<T, Computer$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Computer model
   */ 
  interface ComputerFieldRefs {
    readonly id: FieldRef<"Computer", 'String'>
    readonly userId: FieldRef<"Computer", 'Int'>
    readonly type: FieldRef<"Computer", 'String'>
    readonly gameId: FieldRef<"Computer", 'String'>
    readonly ip: FieldRef<"Computer", 'String'>
    readonly data: FieldRef<"Computer", 'Json'>
    readonly created: FieldRef<"Computer", 'DateTime'>
    readonly updated: FieldRef<"Computer", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Computer findUnique
   */
  export type ComputerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where: ComputerWhereUniqueInput
  }


  /**
   * Computer findUniqueOrThrow
   */
  export type ComputerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where: ComputerWhereUniqueInput
  }


  /**
   * Computer findFirst
   */
  export type ComputerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Computers.
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Computers.
     */
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }


  /**
   * Computer findFirstOrThrow
   */
  export type ComputerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Computers.
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Computers.
     */
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }


  /**
   * Computer findMany
   */
  export type ComputerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computers to fetch.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Computers.
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }


  /**
   * Computer create
   */
  export type ComputerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * The data needed to create a Computer.
     */
    data: XOR<ComputerCreateInput, ComputerUncheckedCreateInput>
  }


  /**
   * Computer createMany
   */
  export type ComputerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Computers.
     */
    data: ComputerCreateManyInput | ComputerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Computer update
   */
  export type ComputerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * The data needed to update a Computer.
     */
    data: XOR<ComputerUpdateInput, ComputerUncheckedUpdateInput>
    /**
     * Choose, which Computer to update.
     */
    where: ComputerWhereUniqueInput
  }


  /**
   * Computer updateMany
   */
  export type ComputerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Computers.
     */
    data: XOR<ComputerUpdateManyMutationInput, ComputerUncheckedUpdateManyInput>
    /**
     * Filter which Computers to update
     */
    where?: ComputerWhereInput
  }


  /**
   * Computer upsert
   */
  export type ComputerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * The filter to search for the Computer to update in case it exists.
     */
    where: ComputerWhereUniqueInput
    /**
     * In case the Computer found by the `where` argument doesn't exist, create a new Computer with this data.
     */
    create: XOR<ComputerCreateInput, ComputerUncheckedCreateInput>
    /**
     * In case the Computer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComputerUpdateInput, ComputerUncheckedUpdateInput>
  }


  /**
   * Computer delete
   */
  export type ComputerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter which Computer to delete.
     */
    where: ComputerWhereUniqueInput
  }


  /**
   * Computer deleteMany
   */
  export type ComputerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Computers to delete
     */
    where?: ComputerWhereInput
  }


  /**
   * Computer.dns
   */
  export type Computer$dnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DNSInclude<ExtArgs> | null
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    cursor?: DNSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }


  /**
   * Computer.hardware
   */
  export type Computer$hardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HardwareInclude<ExtArgs> | null
    where?: HardwareWhereInput
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    cursor?: HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }


  /**
   * Computer.software
   */
  export type Computer$softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    cursor?: SoftwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Computer.memory
   */
  export type Computer$memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemoryInclude<ExtArgs> | null
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    cursor?: MemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }


  /**
   * Computer.process
   */
  export type Computer$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }


  /**
   * Computer.addressBook
   */
  export type Computer$addressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressBookInclude<ExtArgs> | null
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    cursor?: AddressBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }


  /**
   * Computer.accountBook
   */
  export type Computer$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }


  /**
   * Computer.logs
   */
  export type Computer$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Computer without action
   */
  export type ComputerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComputerInclude<ExtArgs> | null
  }



  /**
   * Model Quests
   */

  export type AggregateQuests = {
    _count: QuestsCountAggregateOutputType | null
    _min: QuestsMinAggregateOutputType | null
    _max: QuestsMaxAggregateOutputType | null
  }

  export type QuestsMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    type: string | null
    title: string | null
    open: boolean | null
  }

  export type QuestsMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    type: string | null
    title: string | null
    open: boolean | null
  }

  export type QuestsCountAggregateOutputType = {
    id: number
    gameId: number
    type: number
    title: number
    reward: number
    open: number
    _all: number
  }


  export type QuestsMinAggregateInputType = {
    id?: true
    gameId?: true
    type?: true
    title?: true
    open?: true
  }

  export type QuestsMaxAggregateInputType = {
    id?: true
    gameId?: true
    type?: true
    title?: true
    open?: true
  }

  export type QuestsCountAggregateInputType = {
    id?: true
    gameId?: true
    type?: true
    title?: true
    reward?: true
    open?: true
    _all?: true
  }

  export type QuestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to aggregate.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quests
    **/
    _count?: true | QuestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestsMaxAggregateInputType
  }

  export type GetQuestsAggregateType<T extends QuestsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuests[P]>
      : GetScalarType<T[P], AggregateQuests[P]>
  }




  export type QuestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestsWhereInput
    orderBy?: QuestsOrderByWithAggregationInput | QuestsOrderByWithAggregationInput[]
    by: QuestsScalarFieldEnum[] | QuestsScalarFieldEnum
    having?: QuestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestsCountAggregateInputType | true
    _min?: QuestsMinAggregateInputType
    _max?: QuestsMaxAggregateInputType
  }

  export type QuestsGroupByOutputType = {
    id: string
    gameId: string
    type: string
    title: string
    reward: JsonValue | null
    open: boolean
    _count: QuestsCountAggregateOutputType | null
    _min: QuestsMinAggregateOutputType | null
    _max: QuestsMaxAggregateOutputType | null
  }

  type GetQuestsGroupByPayload<T extends QuestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestsGroupByOutputType[P]>
        }
      >
    >


  export type QuestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    type?: boolean
    title?: boolean
    reward?: boolean
    open?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    userQuests?: boolean | Quests$userQuestsArgs<ExtArgs>
    _count?: boolean | QuestsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quests"]>

  export type QuestsSelectScalar = {
    id?: boolean
    gameId?: boolean
    type?: boolean
    title?: boolean
    reward?: boolean
    open?: boolean
  }

  export type QuestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    userQuests?: boolean | Quests$userQuestsArgs<ExtArgs>
    _count?: boolean | QuestsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $QuestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quests"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      userQuests: Prisma.$UserQuestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      type: string
      title: string
      reward: Prisma.JsonValue | null
      open: boolean
    }, ExtArgs["result"]["quests"]>
    composites: {}
  }


  type QuestsGetPayload<S extends boolean | null | undefined | QuestsDefaultArgs> = $Result.GetResult<Prisma.$QuestsPayload, S>

  type QuestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestsCountAggregateInputType | true
    }

  export interface QuestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quests'], meta: { name: 'Quests' } }
    /**
     * Find zero or one Quests that matches the filter.
     * @param {QuestsFindUniqueArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuestsFindUniqueArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Quests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestsFindUniqueOrThrowArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsFindFirstArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestsFindFirstArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Quests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsFindFirstOrThrowArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quests.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questsWithIdOnly = await prisma.quests.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Quests.
     * @param {QuestsCreateArgs} args - Arguments to create a Quests.
     * @example
     * // Create one Quests
     * const Quests = await prisma.quests.create({
     *   data: {
     *     // ... data to create a Quests
     *   }
     * })
     * 
    **/
    create<T extends QuestsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestsCreateArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Quests.
     *     @param {QuestsCreateManyArgs} args - Arguments to create many Quests.
     *     @example
     *     // Create many Quests
     *     const quests = await prisma.quests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quests.
     * @param {QuestsDeleteArgs} args - Arguments to delete one Quests.
     * @example
     * // Delete one Quests
     * const Quests = await prisma.quests.delete({
     *   where: {
     *     // ... filter to delete one Quests
     *   }
     * })
     * 
    **/
    delete<T extends QuestsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuestsDeleteArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Quests.
     * @param {QuestsUpdateArgs} args - Arguments to update one Quests.
     * @example
     * // Update one Quests
     * const quests = await prisma.quests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestsUpdateArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Quests.
     * @param {QuestsDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quests = await prisma.quests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quests.
     * @param {QuestsUpsertArgs} args - Arguments to update or create a Quests.
     * @example
     * // Update or create a Quests
     * const quests = await prisma.quests.upsert({
     *   create: {
     *     // ... data to create a Quests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quests we want to update
     *   }
     * })
    **/
    upsert<T extends QuestsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuestsUpsertArgs<ExtArgs>>
    ): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quests.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends QuestsCountArgs>(
      args?: Subset<T, QuestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestsAggregateArgs>(args: Subset<T, QuestsAggregateArgs>): Prisma.PrismaPromise<GetQuestsAggregateType<T>>

    /**
     * Group by Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestsGroupByArgs['orderBy'] }
        : { orderBy?: QuestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quests model
   */
  readonly fields: QuestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userQuests<T extends Quests$userQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Quests$userQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Quests model
   */ 
  interface QuestsFieldRefs {
    readonly id: FieldRef<"Quests", 'String'>
    readonly gameId: FieldRef<"Quests", 'String'>
    readonly type: FieldRef<"Quests", 'String'>
    readonly title: FieldRef<"Quests", 'String'>
    readonly reward: FieldRef<"Quests", 'Json'>
    readonly open: FieldRef<"Quests", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Quests findUnique
   */
  export type QuestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where: QuestsWhereUniqueInput
  }


  /**
   * Quests findUniqueOrThrow
   */
  export type QuestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where: QuestsWhereUniqueInput
  }


  /**
   * Quests findFirst
   */
  export type QuestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }


  /**
   * Quests findFirstOrThrow
   */
  export type QuestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }


  /**
   * Quests findMany
   */
  export type QuestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quests.
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }


  /**
   * Quests create
   */
  export type QuestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * The data needed to create a Quests.
     */
    data: XOR<QuestsCreateInput, QuestsUncheckedCreateInput>
  }


  /**
   * Quests createMany
   */
  export type QuestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quests.
     */
    data: QuestsCreateManyInput | QuestsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Quests update
   */
  export type QuestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * The data needed to update a Quests.
     */
    data: XOR<QuestsUpdateInput, QuestsUncheckedUpdateInput>
    /**
     * Choose, which Quests to update.
     */
    where: QuestsWhereUniqueInput
  }


  /**
   * Quests updateMany
   */
  export type QuestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestsUpdateManyMutationInput, QuestsUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestsWhereInput
  }


  /**
   * Quests upsert
   */
  export type QuestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * The filter to search for the Quests to update in case it exists.
     */
    where: QuestsWhereUniqueInput
    /**
     * In case the Quests found by the `where` argument doesn't exist, create a new Quests with this data.
     */
    create: XOR<QuestsCreateInput, QuestsUncheckedCreateInput>
    /**
     * In case the Quests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestsUpdateInput, QuestsUncheckedUpdateInput>
  }


  /**
   * Quests delete
   */
  export type QuestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter which Quests to delete.
     */
    where: QuestsWhereUniqueInput
  }


  /**
   * Quests deleteMany
   */
  export type QuestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to delete
     */
    where?: QuestsWhereInput
  }


  /**
   * Quests.userQuests
   */
  export type Quests$userQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    cursor?: UserQuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }


  /**
   * Quests without action
   */
  export type QuestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestsInclude<ExtArgs> | null
  }



  /**
   * Model UserQuests
   */

  export type AggregateUserQuests = {
    _count: UserQuestsCountAggregateOutputType | null
    _avg: UserQuestsAvgAggregateOutputType | null
    _sum: UserQuestsSumAggregateOutputType | null
    _min: UserQuestsMinAggregateOutputType | null
    _max: UserQuestsMaxAggregateOutputType | null
  }

  export type UserQuestsAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserQuestsSumAggregateOutputType = {
    userId: number | null
  }

  export type UserQuestsMinAggregateOutputType = {
    id: string | null
    questsId: string | null
    userId: number | null
    gameId: string | null
    completed: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type UserQuestsMaxAggregateOutputType = {
    id: string | null
    questsId: string | null
    userId: number | null
    gameId: string | null
    completed: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type UserQuestsCountAggregateOutputType = {
    id: number
    questsId: number
    userId: number
    gameId: number
    completed: number
    created: number
    updated: number
    _all: number
  }


  export type UserQuestsAvgAggregateInputType = {
    userId?: true
  }

  export type UserQuestsSumAggregateInputType = {
    userId?: true
  }

  export type UserQuestsMinAggregateInputType = {
    id?: true
    questsId?: true
    userId?: true
    gameId?: true
    completed?: true
    created?: true
    updated?: true
  }

  export type UserQuestsMaxAggregateInputType = {
    id?: true
    questsId?: true
    userId?: true
    gameId?: true
    completed?: true
    created?: true
    updated?: true
  }

  export type UserQuestsCountAggregateInputType = {
    id?: true
    questsId?: true
    userId?: true
    gameId?: true
    completed?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type UserQuestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuests to aggregate.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuests
    **/
    _count?: true | UserQuestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuestsMaxAggregateInputType
  }

  export type GetUserQuestsAggregateType<T extends UserQuestsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuests[P]>
      : GetScalarType<T[P], AggregateUserQuests[P]>
  }




  export type UserQuestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithAggregationInput | UserQuestsOrderByWithAggregationInput[]
    by: UserQuestsScalarFieldEnum[] | UserQuestsScalarFieldEnum
    having?: UserQuestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuestsCountAggregateInputType | true
    _avg?: UserQuestsAvgAggregateInputType
    _sum?: UserQuestsSumAggregateInputType
    _min?: UserQuestsMinAggregateInputType
    _max?: UserQuestsMaxAggregateInputType
  }

  export type UserQuestsGroupByOutputType = {
    id: string
    questsId: string
    userId: number
    gameId: string
    completed: boolean
    created: Date
    updated: Date
    _count: UserQuestsCountAggregateOutputType | null
    _avg: UserQuestsAvgAggregateOutputType | null
    _sum: UserQuestsSumAggregateOutputType | null
    _min: UserQuestsMinAggregateOutputType | null
    _max: UserQuestsMaxAggregateOutputType | null
  }

  type GetUserQuestsGroupByPayload<T extends UserQuestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuestsGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuestsGroupByOutputType[P]>
        }
      >
    >


  export type UserQuestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questsId?: boolean
    userId?: boolean
    gameId?: boolean
    completed?: boolean
    created?: boolean
    updated?: boolean
    quest?: boolean | QuestsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuests"]>

  export type UserQuestsSelectScalar = {
    id?: boolean
    questsId?: boolean
    userId?: boolean
    gameId?: boolean
    completed?: boolean
    created?: boolean
    updated?: boolean
  }

  export type UserQuestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quest?: boolean | QuestsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $UserQuestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuests"
    objects: {
      quest: Prisma.$QuestsPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questsId: string
      userId: number
      gameId: string
      completed: boolean
      created: Date
      updated: Date
    }, ExtArgs["result"]["userQuests"]>
    composites: {}
  }


  type UserQuestsGetPayload<S extends boolean | null | undefined | UserQuestsDefaultArgs> = $Result.GetResult<Prisma.$UserQuestsPayload, S>

  type UserQuestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserQuestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserQuestsCountAggregateInputType | true
    }

  export interface UserQuestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuests'], meta: { name: 'UserQuests' } }
    /**
     * Find zero or one UserQuests that matches the filter.
     * @param {UserQuestsFindUniqueArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserQuestsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserQuests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserQuestsFindUniqueOrThrowArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserQuestsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsFindFirstArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserQuestsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestsFindFirstArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserQuests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsFindFirstOrThrowArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserQuestsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuests
     * const userQuests = await prisma.userQuests.findMany()
     * 
     * // Get first 10 UserQuests
     * const userQuests = await prisma.userQuests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userQuestsWithIdOnly = await prisma.userQuests.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserQuestsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserQuests.
     * @param {UserQuestsCreateArgs} args - Arguments to create a UserQuests.
     * @example
     * // Create one UserQuests
     * const UserQuests = await prisma.userQuests.create({
     *   data: {
     *     // ... data to create a UserQuests
     *   }
     * })
     * 
    **/
    create<T extends UserQuestsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestsCreateArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserQuests.
     *     @param {UserQuestsCreateManyArgs} args - Arguments to create many UserQuests.
     *     @example
     *     // Create many UserQuests
     *     const userQuests = await prisma.userQuests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserQuestsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserQuests.
     * @param {UserQuestsDeleteArgs} args - Arguments to delete one UserQuests.
     * @example
     * // Delete one UserQuests
     * const UserQuests = await prisma.userQuests.delete({
     *   where: {
     *     // ... filter to delete one UserQuests
     *   }
     * })
     * 
    **/
    delete<T extends UserQuestsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestsDeleteArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserQuests.
     * @param {UserQuestsUpdateArgs} args - Arguments to update one UserQuests.
     * @example
     * // Update one UserQuests
     * const userQuests = await prisma.userQuests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserQuestsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestsUpdateArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserQuests.
     * @param {UserQuestsDeleteManyArgs} args - Arguments to filter UserQuests to delete.
     * @example
     * // Delete a few UserQuests
     * const { count } = await prisma.userQuests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserQuestsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuests
     * const userQuests = await prisma.userQuests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserQuestsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserQuests.
     * @param {UserQuestsUpsertArgs} args - Arguments to update or create a UserQuests.
     * @example
     * // Update or create a UserQuests
     * const userQuests = await prisma.userQuests.upsert({
     *   create: {
     *     // ... data to create a UserQuests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuests we want to update
     *   }
     * })
    **/
    upsert<T extends UserQuestsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestsUpsertArgs<ExtArgs>>
    ): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsCountArgs} args - Arguments to filter UserQuests to count.
     * @example
     * // Count the number of UserQuests
     * const count = await prisma.userQuests.count({
     *   where: {
     *     // ... the filter for the UserQuests we want to count
     *   }
     * })
    **/
    count<T extends UserQuestsCountArgs>(
      args?: Subset<T, UserQuestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuestsAggregateArgs>(args: Subset<T, UserQuestsAggregateArgs>): Prisma.PrismaPromise<GetUserQuestsAggregateType<T>>

    /**
     * Group by UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuestsGroupByArgs['orderBy'] }
        : { orderBy?: UserQuestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuests model
   */
  readonly fields: UserQuestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    quest<T extends QuestsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestsDefaultArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserQuests model
   */ 
  interface UserQuestsFieldRefs {
    readonly id: FieldRef<"UserQuests", 'String'>
    readonly questsId: FieldRef<"UserQuests", 'String'>
    readonly userId: FieldRef<"UserQuests", 'Int'>
    readonly gameId: FieldRef<"UserQuests", 'String'>
    readonly completed: FieldRef<"UserQuests", 'Boolean'>
    readonly created: FieldRef<"UserQuests", 'DateTime'>
    readonly updated: FieldRef<"UserQuests", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * UserQuests findUnique
   */
  export type UserQuestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where: UserQuestsWhereUniqueInput
  }


  /**
   * UserQuests findUniqueOrThrow
   */
  export type UserQuestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where: UserQuestsWhereUniqueInput
  }


  /**
   * UserQuests findFirst
   */
  export type UserQuestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuests.
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuests.
     */
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }


  /**
   * UserQuests findFirstOrThrow
   */
  export type UserQuestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuests.
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuests.
     */
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }


  /**
   * UserQuests findMany
   */
  export type UserQuestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuests.
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }


  /**
   * UserQuests create
   */
  export type UserQuestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserQuests.
     */
    data: XOR<UserQuestsCreateInput, UserQuestsUncheckedCreateInput>
  }


  /**
   * UserQuests createMany
   */
  export type UserQuestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuests.
     */
    data: UserQuestsCreateManyInput | UserQuestsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserQuests update
   */
  export type UserQuestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserQuests.
     */
    data: XOR<UserQuestsUpdateInput, UserQuestsUncheckedUpdateInput>
    /**
     * Choose, which UserQuests to update.
     */
    where: UserQuestsWhereUniqueInput
  }


  /**
   * UserQuests updateMany
   */
  export type UserQuestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuests.
     */
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyInput>
    /**
     * Filter which UserQuests to update
     */
    where?: UserQuestsWhereInput
  }


  /**
   * UserQuests upsert
   */
  export type UserQuestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserQuests to update in case it exists.
     */
    where: UserQuestsWhereUniqueInput
    /**
     * In case the UserQuests found by the `where` argument doesn't exist, create a new UserQuests with this data.
     */
    create: XOR<UserQuestsCreateInput, UserQuestsUncheckedCreateInput>
    /**
     * In case the UserQuests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuestsUpdateInput, UserQuestsUncheckedUpdateInput>
  }


  /**
   * UserQuests delete
   */
  export type UserQuestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter which UserQuests to delete.
     */
    where: UserQuestsWhereUniqueInput
  }


  /**
   * UserQuests deleteMany
   */
  export type UserQuestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuests to delete
     */
    where?: UserQuestsWhereInput
  }


  /**
   * UserQuests without action
   */
  export type UserQuestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserQuestsInclude<ExtArgs> | null
  }



  /**
   * Model Software
   */

  export type AggregateSoftware = {
    _count: SoftwareCountAggregateOutputType | null
    _avg: SoftwareAvgAggregateOutputType | null
    _sum: SoftwareSumAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  export type SoftwareAvgAggregateOutputType = {
    userId: number | null
    level: number | null
    size: number | null
    opacity: number | null
  }

  export type SoftwareSumAggregateOutputType = {
    userId: number | null
    level: number | null
    size: number | null
    opacity: number | null
  }

  export type SoftwareMinAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    type: string | null
    level: number | null
    size: number | null
    opacity: number | null
    installed: boolean | null
    executed: Date | null
    created: Date | null
    updated: Date | null
  }

  export type SoftwareMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    type: string | null
    level: number | null
    size: number | null
    opacity: number | null
    installed: boolean | null
    executed: Date | null
    created: Date | null
    updated: Date | null
  }

  export type SoftwareCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    gameId: number
    type: number
    level: number
    size: number
    opacity: number
    installed: number
    executed: number
    created: number
    updated: number
    data: number
    _all: number
  }


  export type SoftwareAvgAggregateInputType = {
    userId?: true
    level?: true
    size?: true
    opacity?: true
  }

  export type SoftwareSumAggregateInputType = {
    userId?: true
    level?: true
    size?: true
    opacity?: true
  }

  export type SoftwareMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    type?: true
    level?: true
    size?: true
    opacity?: true
    installed?: true
    executed?: true
    created?: true
    updated?: true
  }

  export type SoftwareMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    type?: true
    level?: true
    size?: true
    opacity?: true
    installed?: true
    executed?: true
    created?: true
    updated?: true
  }

  export type SoftwareCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    type?: true
    level?: true
    size?: true
    opacity?: true
    installed?: true
    executed?: true
    created?: true
    updated?: true
    data?: true
    _all?: true
  }

  export type SoftwareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Software to aggregate.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Software
    **/
    _count?: true | SoftwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoftwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoftwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoftwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoftwareMaxAggregateInputType
  }

  export type GetSoftwareAggregateType<T extends SoftwareAggregateArgs> = {
        [P in keyof T & keyof AggregateSoftware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoftware[P]>
      : GetScalarType<T[P], AggregateSoftware[P]>
  }




  export type SoftwareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithAggregationInput | SoftwareOrderByWithAggregationInput[]
    by: SoftwareScalarFieldEnum[] | SoftwareScalarFieldEnum
    having?: SoftwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoftwareCountAggregateInputType | true
    _avg?: SoftwareAvgAggregateInputType
    _sum?: SoftwareSumAggregateInputType
    _min?: SoftwareMinAggregateInputType
    _max?: SoftwareMaxAggregateInputType
  }

  export type SoftwareGroupByOutputType = {
    id: string
    userId: number
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed: Date
    created: Date
    updated: Date
    data: JsonValue
    _count: SoftwareCountAggregateOutputType | null
    _avg: SoftwareAvgAggregateOutputType | null
    _sum: SoftwareSumAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  type GetSoftwareGroupByPayload<T extends SoftwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoftwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoftwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
            : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
        }
      >
    >


  export type SoftwareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    level?: boolean
    size?: boolean
    opacity?: boolean
    installed?: boolean
    executed?: boolean
    created?: boolean
    updated?: boolean
    data?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["software"]>

  export type SoftwareSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    level?: boolean
    size?: boolean
    opacity?: boolean
    installed?: boolean
    executed?: boolean
    created?: boolean
    updated?: boolean
    data?: boolean
  }

  export type SoftwareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $SoftwarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Software"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      computerId: string
      gameId: string
      type: string
      level: number
      size: number
      opacity: number
      installed: boolean
      executed: Date
      created: Date
      updated: Date
      data: Prisma.JsonValue
    }, ExtArgs["result"]["software"]>
    composites: {}
  }


  type SoftwareGetPayload<S extends boolean | null | undefined | SoftwareDefaultArgs> = $Result.GetResult<Prisma.$SoftwarePayload, S>

  type SoftwareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SoftwareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoftwareCountAggregateInputType | true
    }

  export interface SoftwareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Software'], meta: { name: 'Software' } }
    /**
     * Find zero or one Software that matches the filter.
     * @param {SoftwareFindUniqueArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SoftwareFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareFindUniqueArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Software that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SoftwareFindUniqueOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SoftwareFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindFirstArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SoftwareFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindFirstArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Software that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindFirstOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SoftwareFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Software
     * const software = await prisma.software.findMany()
     * 
     * // Get first 10 Software
     * const software = await prisma.software.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const softwareWithIdOnly = await prisma.software.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SoftwareFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Software.
     * @param {SoftwareCreateArgs} args - Arguments to create a Software.
     * @example
     * // Create one Software
     * const Software = await prisma.software.create({
     *   data: {
     *     // ... data to create a Software
     *   }
     * })
     * 
    **/
    create<T extends SoftwareCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareCreateArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Software.
     *     @param {SoftwareCreateManyArgs} args - Arguments to create many Software.
     *     @example
     *     // Create many Software
     *     const software = await prisma.software.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SoftwareCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Software.
     * @param {SoftwareDeleteArgs} args - Arguments to delete one Software.
     * @example
     * // Delete one Software
     * const Software = await prisma.software.delete({
     *   where: {
     *     // ... filter to delete one Software
     *   }
     * })
     * 
    **/
    delete<T extends SoftwareDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareDeleteArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Software.
     * @param {SoftwareUpdateArgs} args - Arguments to update one Software.
     * @example
     * // Update one Software
     * const software = await prisma.software.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SoftwareUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareUpdateArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Software.
     * @param {SoftwareDeleteManyArgs} args - Arguments to filter Software to delete.
     * @example
     * // Delete a few Software
     * const { count } = await prisma.software.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SoftwareDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftwareDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Software
     * const software = await prisma.software.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SoftwareUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Software.
     * @param {SoftwareUpsertArgs} args - Arguments to update or create a Software.
     * @example
     * // Update or create a Software
     * const software = await prisma.software.upsert({
     *   create: {
     *     // ... data to create a Software
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Software we want to update
     *   }
     * })
    **/
    upsert<T extends SoftwareUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SoftwareUpsertArgs<ExtArgs>>
    ): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareCountArgs} args - Arguments to filter Software to count.
     * @example
     * // Count the number of Software
     * const count = await prisma.software.count({
     *   where: {
     *     // ... the filter for the Software we want to count
     *   }
     * })
    **/
    count<T extends SoftwareCountArgs>(
      args?: Subset<T, SoftwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoftwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoftwareAggregateArgs>(args: Subset<T, SoftwareAggregateArgs>): Prisma.PrismaPromise<GetSoftwareAggregateType<T>>

    /**
     * Group by Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoftwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoftwareGroupByArgs['orderBy'] }
        : { orderBy?: SoftwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoftwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoftwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Software model
   */
  readonly fields: SoftwareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Software.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoftwareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Software model
   */ 
  interface SoftwareFieldRefs {
    readonly id: FieldRef<"Software", 'String'>
    readonly userId: FieldRef<"Software", 'Int'>
    readonly computerId: FieldRef<"Software", 'String'>
    readonly gameId: FieldRef<"Software", 'String'>
    readonly type: FieldRef<"Software", 'String'>
    readonly level: FieldRef<"Software", 'Float'>
    readonly size: FieldRef<"Software", 'Float'>
    readonly opacity: FieldRef<"Software", 'Float'>
    readonly installed: FieldRef<"Software", 'Boolean'>
    readonly executed: FieldRef<"Software", 'DateTime'>
    readonly created: FieldRef<"Software", 'DateTime'>
    readonly updated: FieldRef<"Software", 'DateTime'>
    readonly data: FieldRef<"Software", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Software findUnique
   */
  export type SoftwareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software findUniqueOrThrow
   */
  export type SoftwareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software findFirst
   */
  export type SoftwareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Software findFirstOrThrow
   */
  export type SoftwareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Software findMany
   */
  export type SoftwareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }


  /**
   * Software create
   */
  export type SoftwareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The data needed to create a Software.
     */
    data: XOR<SoftwareCreateInput, SoftwareUncheckedCreateInput>
  }


  /**
   * Software createMany
   */
  export type SoftwareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Software.
     */
    data: SoftwareCreateManyInput | SoftwareCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Software update
   */
  export type SoftwareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The data needed to update a Software.
     */
    data: XOR<SoftwareUpdateInput, SoftwareUncheckedUpdateInput>
    /**
     * Choose, which Software to update.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software updateMany
   */
  export type SoftwareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Software.
     */
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyInput>
    /**
     * Filter which Software to update
     */
    where?: SoftwareWhereInput
  }


  /**
   * Software upsert
   */
  export type SoftwareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The filter to search for the Software to update in case it exists.
     */
    where: SoftwareWhereUniqueInput
    /**
     * In case the Software found by the `where` argument doesn't exist, create a new Software with this data.
     */
    create: XOR<SoftwareCreateInput, SoftwareUncheckedCreateInput>
    /**
     * In case the Software was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoftwareUpdateInput, SoftwareUncheckedUpdateInput>
  }


  /**
   * Software delete
   */
  export type SoftwareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter which Software to delete.
     */
    where: SoftwareWhereUniqueInput
  }


  /**
   * Software deleteMany
   */
  export type SoftwareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Software to delete
     */
    where?: SoftwareWhereInput
  }


  /**
   * Software without action
   */
  export type SoftwareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftwareInclude<ExtArgs> | null
  }



  /**
   * Model Process
   */

  export type AggregateProcess = {
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  export type ProcessAvgAggregateOutputType = {
    userId: number | null
  }

  export type ProcessSumAggregateOutputType = {
    userId: number | null
  }

  export type ProcessMinAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    ip: string | null
    gameId: string | null
    type: string | null
    started: Date | null
    completion: Date | null
  }

  export type ProcessMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    ip: string | null
    gameId: string | null
    type: string | null
    started: Date | null
    completion: Date | null
  }

  export type ProcessCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    ip: number
    gameId: number
    type: number
    started: number
    completion: number
    data: number
    _all: number
  }


  export type ProcessAvgAggregateInputType = {
    userId?: true
  }

  export type ProcessSumAggregateInputType = {
    userId?: true
  }

  export type ProcessMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    ip?: true
    gameId?: true
    type?: true
    started?: true
    completion?: true
  }

  export type ProcessMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    ip?: true
    gameId?: true
    type?: true
    started?: true
    completion?: true
  }

  export type ProcessCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    ip?: true
    gameId?: true
    type?: true
    started?: true
    completion?: true
    data?: true
    _all?: true
  }

  export type ProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Process to aggregate.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processes
    **/
    _count?: true | ProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessMaxAggregateInputType
  }

  export type GetProcessAggregateType<T extends ProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcess[P]>
      : GetScalarType<T[P], AggregateProcess[P]>
  }




  export type ProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithAggregationInput | ProcessOrderByWithAggregationInput[]
    by: ProcessScalarFieldEnum[] | ProcessScalarFieldEnum
    having?: ProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCountAggregateInputType | true
    _avg?: ProcessAvgAggregateInputType
    _sum?: ProcessSumAggregateInputType
    _min?: ProcessMinAggregateInputType
    _max?: ProcessMaxAggregateInputType
  }

  export type ProcessGroupByOutputType = {
    id: string
    userId: number
    computerId: string
    ip: string | null
    gameId: string
    type: string
    started: Date
    completion: Date
    data: JsonValue
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  type GetProcessGroupByPayload<T extends ProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessGroupByOutputType[P]>
        }
      >
    >


  export type ProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    ip?: boolean
    gameId?: boolean
    type?: boolean
    started?: boolean
    completion?: boolean
    data?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    ip?: boolean
    gameId?: boolean
    type?: boolean
    started?: boolean
    completion?: boolean
    data?: boolean
  }

  export type ProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $ProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Process"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      computerId: string
      ip: string | null
      gameId: string
      type: string
      started: Date
      completion: Date
      data: Prisma.JsonValue
    }, ExtArgs["result"]["process"]>
    composites: {}
  }


  type ProcessGetPayload<S extends boolean | null | undefined | ProcessDefaultArgs> = $Result.GetResult<Prisma.$ProcessPayload, S>

  type ProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessCountAggregateInputType | true
    }

  export interface ProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Process'], meta: { name: 'Process' } }
    /**
     * Find zero or one Process that matches the filter.
     * @param {ProcessFindUniqueArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProcessFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProcessFindUniqueArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Process that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProcessFindUniqueOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProcessFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProcessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Process that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProcessFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProcessFindFirstArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Process that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProcessFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProcessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Processes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processes
     * const processes = await prisma.process.findMany()
     * 
     * // Get first 10 Processes
     * const processes = await prisma.process.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processWithIdOnly = await prisma.process.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProcessFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProcessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Process.
     * @param {ProcessCreateArgs} args - Arguments to create a Process.
     * @example
     * // Create one Process
     * const Process = await prisma.process.create({
     *   data: {
     *     // ... data to create a Process
     *   }
     * })
     * 
    **/
    create<T extends ProcessCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProcessCreateArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Processes.
     *     @param {ProcessCreateManyArgs} args - Arguments to create many Processes.
     *     @example
     *     // Create many Processes
     *     const process = await prisma.process.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProcessCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProcessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Process.
     * @param {ProcessDeleteArgs} args - Arguments to delete one Process.
     * @example
     * // Delete one Process
     * const Process = await prisma.process.delete({
     *   where: {
     *     // ... filter to delete one Process
     *   }
     * })
     * 
    **/
    delete<T extends ProcessDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProcessDeleteArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Process.
     * @param {ProcessUpdateArgs} args - Arguments to update one Process.
     * @example
     * // Update one Process
     * const process = await prisma.process.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProcessUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProcessUpdateArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Processes.
     * @param {ProcessDeleteManyArgs} args - Arguments to filter Processes to delete.
     * @example
     * // Delete a few Processes
     * const { count } = await prisma.process.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProcessDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProcessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProcessUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProcessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Process.
     * @param {ProcessUpsertArgs} args - Arguments to update or create a Process.
     * @example
     * // Update or create a Process
     * const process = await prisma.process.upsert({
     *   create: {
     *     // ... data to create a Process
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Process we want to update
     *   }
     * })
    **/
    upsert<T extends ProcessUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProcessUpsertArgs<ExtArgs>>
    ): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCountArgs} args - Arguments to filter Processes to count.
     * @example
     * // Count the number of Processes
     * const count = await prisma.process.count({
     *   where: {
     *     // ... the filter for the Processes we want to count
     *   }
     * })
    **/
    count<T extends ProcessCountArgs>(
      args?: Subset<T, ProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessAggregateArgs>(args: Subset<T, ProcessAggregateArgs>): Prisma.PrismaPromise<GetProcessAggregateType<T>>

    /**
     * Group by Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessGroupByArgs['orderBy'] }
        : { orderBy?: ProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Process model
   */
  readonly fields: ProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Process.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Process model
   */ 
  interface ProcessFieldRefs {
    readonly id: FieldRef<"Process", 'String'>
    readonly userId: FieldRef<"Process", 'Int'>
    readonly computerId: FieldRef<"Process", 'String'>
    readonly ip: FieldRef<"Process", 'String'>
    readonly gameId: FieldRef<"Process", 'String'>
    readonly type: FieldRef<"Process", 'String'>
    readonly started: FieldRef<"Process", 'DateTime'>
    readonly completion: FieldRef<"Process", 'DateTime'>
    readonly data: FieldRef<"Process", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Process findUnique
   */
  export type ProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }


  /**
   * Process findUniqueOrThrow
   */
  export type ProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }


  /**
   * Process findFirst
   */
  export type ProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }


  /**
   * Process findFirstOrThrow
   */
  export type ProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }


  /**
   * Process findMany
   */
  export type ProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Processes to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }


  /**
   * Process create
   */
  export type ProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a Process.
     */
    data: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
  }


  /**
   * Process createMany
   */
  export type ProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Process update
   */
  export type ProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a Process.
     */
    data: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
    /**
     * Choose, which Process to update.
     */
    where: ProcessWhereUniqueInput
  }


  /**
   * Process updateMany
   */
  export type ProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
  }


  /**
   * Process upsert
   */
  export type ProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the Process to update in case it exists.
     */
    where: ProcessWhereUniqueInput
    /**
     * In case the Process found by the `where` argument doesn't exist, create a new Process with this data.
     */
    create: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
    /**
     * In case the Process was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
  }


  /**
   * Process delete
   */
  export type ProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter which Process to delete.
     */
    where: ProcessWhereUniqueInput
  }


  /**
   * Process deleteMany
   */
  export type ProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processes to delete
     */
    where?: ProcessWhereInput
  }


  /**
   * Process without action
   */
  export type ProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessInclude<ExtArgs> | null
  }



  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    read: boolean | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    read: boolean | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    content: number
    read: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    read?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    read?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    read?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    userId: number
    type: string
    content: JsonValue
    read: boolean
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
  }

  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      content: Prisma.JsonValue
      read: boolean
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }


  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
    **/
    create<T extends NotificationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notifications = await prisma.notifications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
    **/
    delete<T extends NotificationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notifications model
   */ 
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'Int'>
    readonly userId: FieldRef<"Notifications", 'Int'>
    readonly type: FieldRef<"Notifications", 'String'>
    readonly content: FieldRef<"Notifications", 'Json'>
    readonly read: FieldRef<"Notifications", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }


  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }


  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }


  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }


  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
  }


  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }


  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
  }


  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationsInclude<ExtArgs> | null
  }



  /**
   * Model Logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    senderId: string | null
    senderIp: string | null
    gameId: string | null
    message: string | null
    created: Date | null
  }

  export type LogsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    senderId: string | null
    senderIp: string | null
    gameId: string | null
    message: string | null
    created: Date | null
  }

  export type LogsCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    senderId: number
    senderIp: number
    gameId: number
    message: number
    created: number
    _all: number
  }


  export type LogsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogsMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    senderId?: true
    senderIp?: true
    gameId?: true
    message?: true
    created?: true
  }

  export type LogsMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    senderId?: true
    senderIp?: true
    gameId?: true
    message?: true
    created?: true
  }

  export type LogsCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    senderId?: true
    senderIp?: true
    gameId?: true
    message?: true
    created?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to aggregate.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithAggregationInput | LogsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _avg?: LogsAvgAggregateInputType
    _sum?: LogsSumAggregateInputType
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    id: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created: Date
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    senderId?: boolean
    senderIp?: boolean
    gameId?: boolean
    message?: boolean
    created?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    senderId?: boolean
    senderIp?: boolean
    gameId?: boolean
    message?: boolean
    created?: boolean
  }

  export type LogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }


  export type $LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logs"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      computerId: string
      senderId: string
      senderIp: string
      gameId: string
      message: string
      created: Date
    }, ExtArgs["result"]["logs"]>
    composites: {}
  }


  type LogsGetPayload<S extends boolean | null | undefined | LogsDefaultArgs> = $Result.GetResult<Prisma.$LogsPayload, S>

  type LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logs'], meta: { name: 'Logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {LogsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogsFindUniqueArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindFirstArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsWithIdOnly = await prisma.logs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Logs.
     * @param {LogsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
    **/
    create<T extends LogsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogsCreateArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Logs.
     *     @param {LogsCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const logs = await prisma.logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs.
     * @param {LogsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
    **/
    delete<T extends LogsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogsDeleteArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Logs.
     * @param {LogsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpdateArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs.
     * @param {LogsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
    **/
    upsert<T extends LogsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpsertArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogsCountArgs>(
      args?: Subset<T, LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsGroupByArgs['orderBy'] }
        : { orderBy?: LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logs model
   */
  readonly fields: LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Logs model
   */ 
  interface LogsFieldRefs {
    readonly id: FieldRef<"Logs", 'Int'>
    readonly userId: FieldRef<"Logs", 'Int'>
    readonly computerId: FieldRef<"Logs", 'String'>
    readonly senderId: FieldRef<"Logs", 'String'>
    readonly senderIp: FieldRef<"Logs", 'String'>
    readonly gameId: FieldRef<"Logs", 'String'>
    readonly message: FieldRef<"Logs", 'String'>
    readonly created: FieldRef<"Logs", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Logs findUnique
   */
  export type LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs findUniqueOrThrow
   */
  export type LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs findFirst
   */
  export type LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs findFirstOrThrow
   */
  export type LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs findMany
   */
  export type LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs create
   */
  export type LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to create a Logs.
     */
    data: XOR<LogsCreateInput, LogsUncheckedCreateInput>
  }


  /**
   * Logs createMany
   */
  export type LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Logs update
   */
  export type LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to update a Logs.
     */
    data: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
    /**
     * Choose, which Logs to update.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs updateMany
   */
  export type LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogsWhereInput
  }


  /**
   * Logs upsert
   */
  export type LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The filter to search for the Logs to update in case it exists.
     */
    where: LogsWhereUniqueInput
    /**
     * In case the Logs found by the `where` argument doesn't exist, create a new Logs with this data.
     */
    create: XOR<LogsCreateInput, LogsUncheckedCreateInput>
    /**
     * In case the Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
  }


  /**
   * Logs delete
   */
  export type LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter which Logs to delete.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs deleteMany
   */
  export type LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogsWhereInput
  }


  /**
   * Logs without action
   */
  export type LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    salt: 'salt',
    lastAction: 'lastAction',
    created: 'created',
    refreshToken: 'refreshToken',
    group: 'group'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    started: 'started',
    ended: 'ended'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    lastAction: 'lastAction',
    created: 'created',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const HardwareScalarFieldEnum: {
    id: 'id',
    computerId: 'computerId',
    gameId: 'gameId',
    type: 'type',
    strength: 'strength'
  };

  export type HardwareScalarFieldEnum = (typeof HardwareScalarFieldEnum)[keyof typeof HardwareScalarFieldEnum]


  export const AddressBookScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    access: 'access',
    computerId: 'computerId',
    ip: 'ip',
    data: 'data',
    gameId: 'gameId'
  };

  export type AddressBookScalarFieldEnum = (typeof AddressBookScalarFieldEnum)[keyof typeof AddressBookScalarFieldEnum]


  export const DNSScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    gameId: 'gameId',
    website: 'website',
    tags: 'tags',
    description: 'description',
    updated: 'updated',
    created: 'created'
  };

  export type DNSScalarFieldEnum = (typeof DNSScalarFieldEnum)[keyof typeof DNSScalarFieldEnum]


  export const AccountBookScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    memoryId: 'memoryId',
    data: 'data',
    gameId: 'gameId'
  };

  export type AccountBookScalarFieldEnum = (typeof AccountBookScalarFieldEnum)[keyof typeof AccountBookScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    data: 'data'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const MemoryScalarFieldEnum: {
    id: 'id',
    computerId: 'computerId',
    gameId: 'gameId',
    userId: 'userId',
    type: 'type',
    key: 'key',
    value: 'value',
    data: 'data'
  };

  export type MemoryScalarFieldEnum = (typeof MemoryScalarFieldEnum)[keyof typeof MemoryScalarFieldEnum]


  export const ComputerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    gameId: 'gameId',
    ip: 'ip',
    data: 'data',
    created: 'created',
    updated: 'updated'
  };

  export type ComputerScalarFieldEnum = (typeof ComputerScalarFieldEnum)[keyof typeof ComputerScalarFieldEnum]


  export const QuestsScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    type: 'type',
    title: 'title',
    reward: 'reward',
    open: 'open'
  };

  export type QuestsScalarFieldEnum = (typeof QuestsScalarFieldEnum)[keyof typeof QuestsScalarFieldEnum]


  export const UserQuestsScalarFieldEnum: {
    id: 'id',
    questsId: 'questsId',
    userId: 'userId',
    gameId: 'gameId',
    completed: 'completed',
    created: 'created',
    updated: 'updated'
  };

  export type UserQuestsScalarFieldEnum = (typeof UserQuestsScalarFieldEnum)[keyof typeof UserQuestsScalarFieldEnum]


  export const SoftwareScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    gameId: 'gameId',
    type: 'type',
    level: 'level',
    size: 'size',
    opacity: 'opacity',
    installed: 'installed',
    executed: 'executed',
    created: 'created',
    updated: 'updated',
    data: 'data'
  };

  export type SoftwareScalarFieldEnum = (typeof SoftwareScalarFieldEnum)[keyof typeof SoftwareScalarFieldEnum]


  export const ProcessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    ip: 'ip',
    gameId: 'gameId',
    type: 'type',
    started: 'started',
    completion: 'completion',
    data: 'data'
  };

  export type ProcessScalarFieldEnum = (typeof ProcessScalarFieldEnum)[keyof typeof ProcessScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    content: 'content',
    read: 'read'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const LogsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    senderId: 'senderId',
    senderIp: 'senderIp',
    gameId: 'gameId',
    message: 'message',
    created: 'created'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Groups'
   */
  export type EnumGroupsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Groups'>
    


  /**
   * Reference to a field of type 'Groups[]'
   */
  export type ListEnumGroupsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Groups[]'>
    


  /**
   * Reference to a field of type 'HardwareTypes'
   */
  export type EnumHardwareTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HardwareTypes'>
    


  /**
   * Reference to a field of type 'HardwareTypes[]'
   */
  export type ListEnumHardwareTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HardwareTypes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    salt?: StringFilter<"User"> | string
    lastAction?: DateTimeFilter<"User"> | Date | string
    created?: DateTimeFilter<"User"> | Date | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    group?: EnumGroupsFilter<"User"> | $Enums.Groups
    session?: SessionListRelationFilter
    computer?: ComputerListRelationFilter
    software?: SoftwareListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    userQuests?: UserQuestsListRelationFilter
    addressBook?: AddressBookListRelationFilter
    accountBook?: AccountBookListRelationFilter
    logs?: LogsListRelationFilter
    dns?: DNSListRelationFilter
    profile?: ProfileListRelationFilter
    notifications?: NotificationsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    group?: SortOrder
    session?: SessionOrderByRelationAggregateInput
    computer?: ComputerOrderByRelationAggregateInput
    software?: SoftwareOrderByRelationAggregateInput
    memory?: MemoryOrderByRelationAggregateInput
    process?: ProcessOrderByRelationAggregateInput
    userQuests?: UserQuestsOrderByRelationAggregateInput
    addressBook?: AddressBookOrderByRelationAggregateInput
    accountBook?: AccountBookOrderByRelationAggregateInput
    logs?: LogsOrderByRelationAggregateInput
    dns?: DNSOrderByRelationAggregateInput
    profile?: ProfileOrderByRelationAggregateInput
    notifications?: NotificationsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    salt?: StringFilter<"User"> | string
    lastAction?: DateTimeFilter<"User"> | Date | string
    created?: DateTimeFilter<"User"> | Date | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    group?: EnumGroupsFilter<"User"> | $Enums.Groups
    session?: SessionListRelationFilter
    computer?: ComputerListRelationFilter
    software?: SoftwareListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    userQuests?: UserQuestsListRelationFilter
    addressBook?: AddressBookListRelationFilter
    accountBook?: AccountBookListRelationFilter
    logs?: LogsListRelationFilter
    dns?: DNSListRelationFilter
    profile?: ProfileListRelationFilter
    notifications?: NotificationsListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    group?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    salt?: StringWithAggregatesFilter<"User"> | string
    lastAction?: DateTimeWithAggregatesFilter<"User"> | Date | string
    created?: DateTimeWithAggregatesFilter<"User"> | Date | string
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    group?: EnumGroupsWithAggregatesFilter<"User"> | $Enums.Groups
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    started?: DateTimeFilter<"Game"> | Date | string
    ended?: DateTimeNullableFilter<"Game"> | Date | string | null
    software?: SoftwareListRelationFilter
    hardware?: HardwareListRelationFilter
    computer?: ComputerListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    quests?: QuestsListRelationFilter
    userQuests?: UserQuestsListRelationFilter
    logs?: LogsListRelationFilter
    addressBook?: AddressBookListRelationFilter
    accountBook?: AccountBookListRelationFilter
    dns?: DNSListRelationFilter
    profile?: ProfileListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrderInput | SortOrder
    software?: SoftwareOrderByRelationAggregateInput
    hardware?: HardwareOrderByRelationAggregateInput
    computer?: ComputerOrderByRelationAggregateInput
    memory?: MemoryOrderByRelationAggregateInput
    process?: ProcessOrderByRelationAggregateInput
    quests?: QuestsOrderByRelationAggregateInput
    userQuests?: UserQuestsOrderByRelationAggregateInput
    logs?: LogsOrderByRelationAggregateInput
    addressBook?: AddressBookOrderByRelationAggregateInput
    accountBook?: AccountBookOrderByRelationAggregateInput
    dns?: DNSOrderByRelationAggregateInput
    profile?: ProfileOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    name?: StringFilter<"Game"> | string
    started?: DateTimeFilter<"Game"> | Date | string
    ended?: DateTimeNullableFilter<"Game"> | Date | string | null
    software?: SoftwareListRelationFilter
    hardware?: HardwareListRelationFilter
    computer?: ComputerListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    quests?: QuestsListRelationFilter
    userQuests?: UserQuestsListRelationFilter
    logs?: LogsListRelationFilter
    addressBook?: AddressBookListRelationFilter
    accountBook?: AccountBookListRelationFilter
    dns?: DNSListRelationFilter
    profile?: ProfileListRelationFilter
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrderInput | SortOrder
    _count?: GameCountOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    name?: StringWithAggregatesFilter<"Game"> | string
    started?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    ended?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    lastAction?: DateTimeFilter<"Session"> | Date | string
    created?: DateTimeFilter<"Session"> | Date | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    lastAction?: DateTimeFilter<"Session"> | Date | string
    created?: DateTimeFilter<"Session"> | Date | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntWithAggregatesFilter<"Session"> | number
    token?: StringWithAggregatesFilter<"Session"> | string
    lastAction?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    created?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type HardwareWhereInput = {
    AND?: HardwareWhereInput | HardwareWhereInput[]
    OR?: HardwareWhereInput[]
    NOT?: HardwareWhereInput | HardwareWhereInput[]
    id?: IntFilter<"Hardware"> | number
    computerId?: StringFilter<"Hardware"> | string
    gameId?: StringFilter<"Hardware"> | string
    type?: EnumHardwareTypesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatFilter<"Hardware"> | number
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type HardwareOrderByWithRelationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type HardwareWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HardwareWhereInput | HardwareWhereInput[]
    OR?: HardwareWhereInput[]
    NOT?: HardwareWhereInput | HardwareWhereInput[]
    computerId?: StringFilter<"Hardware"> | string
    gameId?: StringFilter<"Hardware"> | string
    type?: EnumHardwareTypesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatFilter<"Hardware"> | number
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type HardwareOrderByWithAggregationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
    _count?: HardwareCountOrderByAggregateInput
    _avg?: HardwareAvgOrderByAggregateInput
    _max?: HardwareMaxOrderByAggregateInput
    _min?: HardwareMinOrderByAggregateInput
    _sum?: HardwareSumOrderByAggregateInput
  }

  export type HardwareScalarWhereWithAggregatesInput = {
    AND?: HardwareScalarWhereWithAggregatesInput | HardwareScalarWhereWithAggregatesInput[]
    OR?: HardwareScalarWhereWithAggregatesInput[]
    NOT?: HardwareScalarWhereWithAggregatesInput | HardwareScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hardware"> | number
    computerId?: StringWithAggregatesFilter<"Hardware"> | string
    gameId?: StringWithAggregatesFilter<"Hardware"> | string
    type?: EnumHardwareTypesWithAggregatesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatWithAggregatesFilter<"Hardware"> | number
  }

  export type AddressBookWhereInput = {
    AND?: AddressBookWhereInput | AddressBookWhereInput[]
    OR?: AddressBookWhereInput[]
    NOT?: AddressBookWhereInput | AddressBookWhereInput[]
    id?: IntFilter<"AddressBook"> | number
    userId?: IntFilter<"AddressBook"> | number
    access?: EnumAccessLevelFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringFilter<"AddressBook"> | string
    ip?: StringFilter<"AddressBook"> | string
    data?: JsonFilter<"AddressBook">
    gameId?: StringFilter<"AddressBook"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type AddressBookOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    user?: UserOrderByWithRelationInput
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type AddressBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressBookWhereInput | AddressBookWhereInput[]
    OR?: AddressBookWhereInput[]
    NOT?: AddressBookWhereInput | AddressBookWhereInput[]
    userId?: IntFilter<"AddressBook"> | number
    access?: EnumAccessLevelFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringFilter<"AddressBook"> | string
    ip?: StringFilter<"AddressBook"> | string
    data?: JsonFilter<"AddressBook">
    gameId?: StringFilter<"AddressBook"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type AddressBookOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    _count?: AddressBookCountOrderByAggregateInput
    _avg?: AddressBookAvgOrderByAggregateInput
    _max?: AddressBookMaxOrderByAggregateInput
    _min?: AddressBookMinOrderByAggregateInput
    _sum?: AddressBookSumOrderByAggregateInput
  }

  export type AddressBookScalarWhereWithAggregatesInput = {
    AND?: AddressBookScalarWhereWithAggregatesInput | AddressBookScalarWhereWithAggregatesInput[]
    OR?: AddressBookScalarWhereWithAggregatesInput[]
    NOT?: AddressBookScalarWhereWithAggregatesInput | AddressBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddressBook"> | number
    userId?: IntWithAggregatesFilter<"AddressBook"> | number
    access?: EnumAccessLevelWithAggregatesFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringWithAggregatesFilter<"AddressBook"> | string
    ip?: StringWithAggregatesFilter<"AddressBook"> | string
    data?: JsonWithAggregatesFilter<"AddressBook">
    gameId?: StringWithAggregatesFilter<"AddressBook"> | string
  }

  export type DNSWhereInput = {
    AND?: DNSWhereInput | DNSWhereInput[]
    OR?: DNSWhereInput[]
    NOT?: DNSWhereInput | DNSWhereInput[]
    id?: IntFilter<"DNS"> | number
    userId?: IntFilter<"DNS"> | number
    computerId?: StringFilter<"DNS"> | string
    gameId?: StringFilter<"DNS"> | string
    website?: StringFilter<"DNS"> | string
    tags?: StringFilter<"DNS"> | string
    description?: StringFilter<"DNS"> | string
    updated?: DateTimeFilter<"DNS"> | Date | string
    created?: DateTimeFilter<"DNS"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type DNSOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
    user?: UserOrderByWithRelationInput
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type DNSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DNSWhereInput | DNSWhereInput[]
    OR?: DNSWhereInput[]
    NOT?: DNSWhereInput | DNSWhereInput[]
    userId?: IntFilter<"DNS"> | number
    computerId?: StringFilter<"DNS"> | string
    gameId?: StringFilter<"DNS"> | string
    website?: StringFilter<"DNS"> | string
    tags?: StringFilter<"DNS"> | string
    description?: StringFilter<"DNS"> | string
    updated?: DateTimeFilter<"DNS"> | Date | string
    created?: DateTimeFilter<"DNS"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type DNSOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
    _count?: DNSCountOrderByAggregateInput
    _avg?: DNSAvgOrderByAggregateInput
    _max?: DNSMaxOrderByAggregateInput
    _min?: DNSMinOrderByAggregateInput
    _sum?: DNSSumOrderByAggregateInput
  }

  export type DNSScalarWhereWithAggregatesInput = {
    AND?: DNSScalarWhereWithAggregatesInput | DNSScalarWhereWithAggregatesInput[]
    OR?: DNSScalarWhereWithAggregatesInput[]
    NOT?: DNSScalarWhereWithAggregatesInput | DNSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DNS"> | number
    userId?: IntWithAggregatesFilter<"DNS"> | number
    computerId?: StringWithAggregatesFilter<"DNS"> | string
    gameId?: StringWithAggregatesFilter<"DNS"> | string
    website?: StringWithAggregatesFilter<"DNS"> | string
    tags?: StringWithAggregatesFilter<"DNS"> | string
    description?: StringWithAggregatesFilter<"DNS"> | string
    updated?: DateTimeWithAggregatesFilter<"DNS"> | Date | string
    created?: DateTimeWithAggregatesFilter<"DNS"> | Date | string
  }

  export type AccountBookWhereInput = {
    AND?: AccountBookWhereInput | AccountBookWhereInput[]
    OR?: AccountBookWhereInput[]
    NOT?: AccountBookWhereInput | AccountBookWhereInput[]
    id?: IntFilter<"AccountBook"> | number
    userId?: IntFilter<"AccountBook"> | number
    computerId?: StringFilter<"AccountBook"> | string
    memoryId?: StringFilter<"AccountBook"> | string
    data?: JsonFilter<"AccountBook">
    gameId?: StringFilter<"AccountBook"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    memory?: XOR<MemoryRelationFilter, MemoryWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type AccountBookOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    user?: UserOrderByWithRelationInput
    computer?: ComputerOrderByWithRelationInput
    memory?: MemoryOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type AccountBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountBookWhereInput | AccountBookWhereInput[]
    OR?: AccountBookWhereInput[]
    NOT?: AccountBookWhereInput | AccountBookWhereInput[]
    userId?: IntFilter<"AccountBook"> | number
    computerId?: StringFilter<"AccountBook"> | string
    memoryId?: StringFilter<"AccountBook"> | string
    data?: JsonFilter<"AccountBook">
    gameId?: StringFilter<"AccountBook"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    memory?: XOR<MemoryRelationFilter, MemoryWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type AccountBookOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    _count?: AccountBookCountOrderByAggregateInput
    _avg?: AccountBookAvgOrderByAggregateInput
    _max?: AccountBookMaxOrderByAggregateInput
    _min?: AccountBookMinOrderByAggregateInput
    _sum?: AccountBookSumOrderByAggregateInput
  }

  export type AccountBookScalarWhereWithAggregatesInput = {
    AND?: AccountBookScalarWhereWithAggregatesInput | AccountBookScalarWhereWithAggregatesInput[]
    OR?: AccountBookScalarWhereWithAggregatesInput[]
    NOT?: AccountBookScalarWhereWithAggregatesInput | AccountBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountBook"> | number
    userId?: IntWithAggregatesFilter<"AccountBook"> | number
    computerId?: StringWithAggregatesFilter<"AccountBook"> | string
    memoryId?: StringWithAggregatesFilter<"AccountBook"> | string
    data?: JsonWithAggregatesFilter<"AccountBook">
    gameId?: StringWithAggregatesFilter<"AccountBook"> | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: IntFilter<"Profile"> | number
    userId?: IntFilter<"Profile"> | number
    gameId?: StringFilter<"Profile"> | string
    data?: JsonFilter<"Profile">
    user?: XOR<UserRelationFilter, UserWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    data?: SortOrder
    user?: UserOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    userId?: IntFilter<"Profile"> | number
    gameId?: StringFilter<"Profile"> | string
    data?: JsonFilter<"Profile">
    user?: XOR<UserRelationFilter, UserWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    data?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profile"> | number
    userId?: IntWithAggregatesFilter<"Profile"> | number
    gameId?: StringWithAggregatesFilter<"Profile"> | string
    data?: JsonWithAggregatesFilter<"Profile">
  }

  export type MemoryWhereInput = {
    AND?: MemoryWhereInput | MemoryWhereInput[]
    OR?: MemoryWhereInput[]
    NOT?: MemoryWhereInput | MemoryWhereInput[]
    id?: StringFilter<"Memory"> | string
    computerId?: StringFilter<"Memory"> | string
    gameId?: StringFilter<"Memory"> | string
    userId?: IntFilter<"Memory"> | number
    type?: StringFilter<"Memory"> | string
    key?: StringFilter<"Memory"> | string
    value?: FloatNullableFilter<"Memory"> | number | null
    data?: JsonFilter<"Memory">
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    accountBook?: AccountBookListRelationFilter
  }

  export type MemoryOrderByWithRelationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    data?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    accountBook?: AccountBookOrderByRelationAggregateInput
  }

  export type MemoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemoryWhereInput | MemoryWhereInput[]
    OR?: MemoryWhereInput[]
    NOT?: MemoryWhereInput | MemoryWhereInput[]
    computerId?: StringFilter<"Memory"> | string
    gameId?: StringFilter<"Memory"> | string
    userId?: IntFilter<"Memory"> | number
    type?: StringFilter<"Memory"> | string
    key?: StringFilter<"Memory"> | string
    value?: FloatNullableFilter<"Memory"> | number | null
    data?: JsonFilter<"Memory">
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    accountBook?: AccountBookListRelationFilter
  }, "id">

  export type MemoryOrderByWithAggregationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    data?: SortOrder
    _count?: MemoryCountOrderByAggregateInput
    _avg?: MemoryAvgOrderByAggregateInput
    _max?: MemoryMaxOrderByAggregateInput
    _min?: MemoryMinOrderByAggregateInput
    _sum?: MemorySumOrderByAggregateInput
  }

  export type MemoryScalarWhereWithAggregatesInput = {
    AND?: MemoryScalarWhereWithAggregatesInput | MemoryScalarWhereWithAggregatesInput[]
    OR?: MemoryScalarWhereWithAggregatesInput[]
    NOT?: MemoryScalarWhereWithAggregatesInput | MemoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Memory"> | string
    computerId?: StringWithAggregatesFilter<"Memory"> | string
    gameId?: StringWithAggregatesFilter<"Memory"> | string
    userId?: IntWithAggregatesFilter<"Memory"> | number
    type?: StringWithAggregatesFilter<"Memory"> | string
    key?: StringWithAggregatesFilter<"Memory"> | string
    value?: FloatNullableWithAggregatesFilter<"Memory"> | number | null
    data?: JsonWithAggregatesFilter<"Memory">
  }

  export type ComputerWhereInput = {
    AND?: ComputerWhereInput | ComputerWhereInput[]
    OR?: ComputerWhereInput[]
    NOT?: ComputerWhereInput | ComputerWhereInput[]
    id?: StringFilter<"Computer"> | string
    userId?: IntFilter<"Computer"> | number
    type?: StringFilter<"Computer"> | string
    gameId?: StringFilter<"Computer"> | string
    ip?: StringFilter<"Computer"> | string
    data?: JsonFilter<"Computer">
    created?: DateTimeFilter<"Computer"> | Date | string
    updated?: DateTimeFilter<"Computer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    dns?: DNSListRelationFilter
    hardware?: HardwareListRelationFilter
    software?: SoftwareListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    addressBook?: AddressBookListRelationFilter
    accountBook?: AccountBookListRelationFilter
    logs?: LogsListRelationFilter
  }

  export type ComputerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user?: UserOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    dns?: DNSOrderByRelationAggregateInput
    hardware?: HardwareOrderByRelationAggregateInput
    software?: SoftwareOrderByRelationAggregateInput
    memory?: MemoryOrderByRelationAggregateInput
    process?: ProcessOrderByRelationAggregateInput
    addressBook?: AddressBookOrderByRelationAggregateInput
    accountBook?: AccountBookOrderByRelationAggregateInput
    logs?: LogsOrderByRelationAggregateInput
  }

  export type ComputerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComputerWhereInput | ComputerWhereInput[]
    OR?: ComputerWhereInput[]
    NOT?: ComputerWhereInput | ComputerWhereInput[]
    userId?: IntFilter<"Computer"> | number
    type?: StringFilter<"Computer"> | string
    gameId?: StringFilter<"Computer"> | string
    ip?: StringFilter<"Computer"> | string
    data?: JsonFilter<"Computer">
    created?: DateTimeFilter<"Computer"> | Date | string
    updated?: DateTimeFilter<"Computer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    dns?: DNSListRelationFilter
    hardware?: HardwareListRelationFilter
    software?: SoftwareListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    addressBook?: AddressBookListRelationFilter
    accountBook?: AccountBookListRelationFilter
    logs?: LogsListRelationFilter
  }, "id">

  export type ComputerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: ComputerCountOrderByAggregateInput
    _avg?: ComputerAvgOrderByAggregateInput
    _max?: ComputerMaxOrderByAggregateInput
    _min?: ComputerMinOrderByAggregateInput
    _sum?: ComputerSumOrderByAggregateInput
  }

  export type ComputerScalarWhereWithAggregatesInput = {
    AND?: ComputerScalarWhereWithAggregatesInput | ComputerScalarWhereWithAggregatesInput[]
    OR?: ComputerScalarWhereWithAggregatesInput[]
    NOT?: ComputerScalarWhereWithAggregatesInput | ComputerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Computer"> | string
    userId?: IntWithAggregatesFilter<"Computer"> | number
    type?: StringWithAggregatesFilter<"Computer"> | string
    gameId?: StringWithAggregatesFilter<"Computer"> | string
    ip?: StringWithAggregatesFilter<"Computer"> | string
    data?: JsonWithAggregatesFilter<"Computer">
    created?: DateTimeWithAggregatesFilter<"Computer"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Computer"> | Date | string
  }

  export type QuestsWhereInput = {
    AND?: QuestsWhereInput | QuestsWhereInput[]
    OR?: QuestsWhereInput[]
    NOT?: QuestsWhereInput | QuestsWhereInput[]
    id?: StringFilter<"Quests"> | string
    gameId?: StringFilter<"Quests"> | string
    type?: StringFilter<"Quests"> | string
    title?: StringFilter<"Quests"> | string
    reward?: JsonNullableFilter<"Quests">
    open?: BoolFilter<"Quests"> | boolean
    game?: XOR<GameRelationFilter, GameWhereInput>
    userQuests?: UserQuestsListRelationFilter
  }

  export type QuestsOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    reward?: SortOrderInput | SortOrder
    open?: SortOrder
    game?: GameOrderByWithRelationInput
    userQuests?: UserQuestsOrderByRelationAggregateInput
  }

  export type QuestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestsWhereInput | QuestsWhereInput[]
    OR?: QuestsWhereInput[]
    NOT?: QuestsWhereInput | QuestsWhereInput[]
    gameId?: StringFilter<"Quests"> | string
    type?: StringFilter<"Quests"> | string
    title?: StringFilter<"Quests"> | string
    reward?: JsonNullableFilter<"Quests">
    open?: BoolFilter<"Quests"> | boolean
    game?: XOR<GameRelationFilter, GameWhereInput>
    userQuests?: UserQuestsListRelationFilter
  }, "id">

  export type QuestsOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    reward?: SortOrderInput | SortOrder
    open?: SortOrder
    _count?: QuestsCountOrderByAggregateInput
    _max?: QuestsMaxOrderByAggregateInput
    _min?: QuestsMinOrderByAggregateInput
  }

  export type QuestsScalarWhereWithAggregatesInput = {
    AND?: QuestsScalarWhereWithAggregatesInput | QuestsScalarWhereWithAggregatesInput[]
    OR?: QuestsScalarWhereWithAggregatesInput[]
    NOT?: QuestsScalarWhereWithAggregatesInput | QuestsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quests"> | string
    gameId?: StringWithAggregatesFilter<"Quests"> | string
    type?: StringWithAggregatesFilter<"Quests"> | string
    title?: StringWithAggregatesFilter<"Quests"> | string
    reward?: JsonNullableWithAggregatesFilter<"Quests">
    open?: BoolWithAggregatesFilter<"Quests"> | boolean
  }

  export type UserQuestsWhereInput = {
    AND?: UserQuestsWhereInput | UserQuestsWhereInput[]
    OR?: UserQuestsWhereInput[]
    NOT?: UserQuestsWhereInput | UserQuestsWhereInput[]
    id?: StringFilter<"UserQuests"> | string
    questsId?: StringFilter<"UserQuests"> | string
    userId?: IntFilter<"UserQuests"> | number
    gameId?: StringFilter<"UserQuests"> | string
    completed?: BoolFilter<"UserQuests"> | boolean
    created?: DateTimeFilter<"UserQuests"> | Date | string
    updated?: DateTimeFilter<"UserQuests"> | Date | string
    quest?: XOR<QuestsRelationFilter, QuestsWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type UserQuestsOrderByWithRelationInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    quest?: QuestsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type UserQuestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserQuestsWhereInput | UserQuestsWhereInput[]
    OR?: UserQuestsWhereInput[]
    NOT?: UserQuestsWhereInput | UserQuestsWhereInput[]
    questsId?: StringFilter<"UserQuests"> | string
    userId?: IntFilter<"UserQuests"> | number
    gameId?: StringFilter<"UserQuests"> | string
    completed?: BoolFilter<"UserQuests"> | boolean
    created?: DateTimeFilter<"UserQuests"> | Date | string
    updated?: DateTimeFilter<"UserQuests"> | Date | string
    quest?: XOR<QuestsRelationFilter, QuestsWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type UserQuestsOrderByWithAggregationInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: UserQuestsCountOrderByAggregateInput
    _avg?: UserQuestsAvgOrderByAggregateInput
    _max?: UserQuestsMaxOrderByAggregateInput
    _min?: UserQuestsMinOrderByAggregateInput
    _sum?: UserQuestsSumOrderByAggregateInput
  }

  export type UserQuestsScalarWhereWithAggregatesInput = {
    AND?: UserQuestsScalarWhereWithAggregatesInput | UserQuestsScalarWhereWithAggregatesInput[]
    OR?: UserQuestsScalarWhereWithAggregatesInput[]
    NOT?: UserQuestsScalarWhereWithAggregatesInput | UserQuestsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserQuests"> | string
    questsId?: StringWithAggregatesFilter<"UserQuests"> | string
    userId?: IntWithAggregatesFilter<"UserQuests"> | number
    gameId?: StringWithAggregatesFilter<"UserQuests"> | string
    completed?: BoolWithAggregatesFilter<"UserQuests"> | boolean
    created?: DateTimeWithAggregatesFilter<"UserQuests"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"UserQuests"> | Date | string
  }

  export type SoftwareWhereInput = {
    AND?: SoftwareWhereInput | SoftwareWhereInput[]
    OR?: SoftwareWhereInput[]
    NOT?: SoftwareWhereInput | SoftwareWhereInput[]
    id?: StringFilter<"Software"> | string
    userId?: IntFilter<"Software"> | number
    computerId?: StringFilter<"Software"> | string
    gameId?: StringFilter<"Software"> | string
    type?: StringFilter<"Software"> | string
    level?: FloatFilter<"Software"> | number
    size?: FloatFilter<"Software"> | number
    opacity?: FloatFilter<"Software"> | number
    installed?: BoolFilter<"Software"> | boolean
    executed?: DateTimeFilter<"Software"> | Date | string
    created?: DateTimeFilter<"Software"> | Date | string
    updated?: DateTimeFilter<"Software"> | Date | string
    data?: JsonFilter<"Software">
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type SoftwareOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    user?: UserOrderByWithRelationInput
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type SoftwareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SoftwareWhereInput | SoftwareWhereInput[]
    OR?: SoftwareWhereInput[]
    NOT?: SoftwareWhereInput | SoftwareWhereInput[]
    userId?: IntFilter<"Software"> | number
    computerId?: StringFilter<"Software"> | string
    gameId?: StringFilter<"Software"> | string
    type?: StringFilter<"Software"> | string
    level?: FloatFilter<"Software"> | number
    size?: FloatFilter<"Software"> | number
    opacity?: FloatFilter<"Software"> | number
    installed?: BoolFilter<"Software"> | boolean
    executed?: DateTimeFilter<"Software"> | Date | string
    created?: DateTimeFilter<"Software"> | Date | string
    updated?: DateTimeFilter<"Software"> | Date | string
    data?: JsonFilter<"Software">
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type SoftwareOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    _count?: SoftwareCountOrderByAggregateInput
    _avg?: SoftwareAvgOrderByAggregateInput
    _max?: SoftwareMaxOrderByAggregateInput
    _min?: SoftwareMinOrderByAggregateInput
    _sum?: SoftwareSumOrderByAggregateInput
  }

  export type SoftwareScalarWhereWithAggregatesInput = {
    AND?: SoftwareScalarWhereWithAggregatesInput | SoftwareScalarWhereWithAggregatesInput[]
    OR?: SoftwareScalarWhereWithAggregatesInput[]
    NOT?: SoftwareScalarWhereWithAggregatesInput | SoftwareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Software"> | string
    userId?: IntWithAggregatesFilter<"Software"> | number
    computerId?: StringWithAggregatesFilter<"Software"> | string
    gameId?: StringWithAggregatesFilter<"Software"> | string
    type?: StringWithAggregatesFilter<"Software"> | string
    level?: FloatWithAggregatesFilter<"Software"> | number
    size?: FloatWithAggregatesFilter<"Software"> | number
    opacity?: FloatWithAggregatesFilter<"Software"> | number
    installed?: BoolWithAggregatesFilter<"Software"> | boolean
    executed?: DateTimeWithAggregatesFilter<"Software"> | Date | string
    created?: DateTimeWithAggregatesFilter<"Software"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Software"> | Date | string
    data?: JsonWithAggregatesFilter<"Software">
  }

  export type ProcessWhereInput = {
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    id?: StringFilter<"Process"> | string
    userId?: IntFilter<"Process"> | number
    computerId?: StringFilter<"Process"> | string
    ip?: StringNullableFilter<"Process"> | string | null
    gameId?: StringFilter<"Process"> | string
    type?: StringFilter<"Process"> | string
    started?: DateTimeFilter<"Process"> | Date | string
    completion?: DateTimeFilter<"Process"> | Date | string
    data?: JsonFilter<"Process">
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type ProcessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrderInput | SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
    data?: SortOrder
    user?: UserOrderByWithRelationInput
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type ProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    userId?: IntFilter<"Process"> | number
    computerId?: StringFilter<"Process"> | string
    ip?: StringNullableFilter<"Process"> | string | null
    gameId?: StringFilter<"Process"> | string
    type?: StringFilter<"Process"> | string
    started?: DateTimeFilter<"Process"> | Date | string
    completion?: DateTimeFilter<"Process"> | Date | string
    data?: JsonFilter<"Process">
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type ProcessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrderInput | SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
    data?: SortOrder
    _count?: ProcessCountOrderByAggregateInput
    _avg?: ProcessAvgOrderByAggregateInput
    _max?: ProcessMaxOrderByAggregateInput
    _min?: ProcessMinOrderByAggregateInput
    _sum?: ProcessSumOrderByAggregateInput
  }

  export type ProcessScalarWhereWithAggregatesInput = {
    AND?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    OR?: ProcessScalarWhereWithAggregatesInput[]
    NOT?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Process"> | string
    userId?: IntWithAggregatesFilter<"Process"> | number
    computerId?: StringWithAggregatesFilter<"Process"> | string
    ip?: StringNullableWithAggregatesFilter<"Process"> | string | null
    gameId?: StringWithAggregatesFilter<"Process"> | string
    type?: StringWithAggregatesFilter<"Process"> | string
    started?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    completion?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    data?: JsonWithAggregatesFilter<"Process">
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: IntFilter<"Notifications"> | number
    userId?: IntFilter<"Notifications"> | number
    type?: StringFilter<"Notifications"> | string
    content?: JsonFilter<"Notifications">
    read?: BoolFilter<"Notifications"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    userId?: IntFilter<"Notifications"> | number
    type?: StringFilter<"Notifications"> | string
    content?: JsonFilter<"Notifications">
    read?: BoolFilter<"Notifications"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _avg?: NotificationsAvgOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
    _sum?: NotificationsSumOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notifications"> | number
    userId?: IntWithAggregatesFilter<"Notifications"> | number
    type?: StringWithAggregatesFilter<"Notifications"> | string
    content?: JsonWithAggregatesFilter<"Notifications">
    read?: BoolWithAggregatesFilter<"Notifications"> | boolean
  }

  export type LogsWhereInput = {
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    id?: IntFilter<"Logs"> | number
    userId?: IntFilter<"Logs"> | number
    computerId?: StringFilter<"Logs"> | string
    senderId?: StringFilter<"Logs"> | string
    senderIp?: StringFilter<"Logs"> | string
    gameId?: StringFilter<"Logs"> | string
    message?: StringFilter<"Logs"> | string
    created?: DateTimeFilter<"Logs"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type LogsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
    user?: UserOrderByWithRelationInput
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type LogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    userId?: IntFilter<"Logs"> | number
    computerId?: StringFilter<"Logs"> | string
    senderId?: StringFilter<"Logs"> | string
    senderIp?: StringFilter<"Logs"> | string
    gameId?: StringFilter<"Logs"> | string
    message?: StringFilter<"Logs"> | string
    created?: DateTimeFilter<"Logs"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type LogsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
    _count?: LogsCountOrderByAggregateInput
    _avg?: LogsAvgOrderByAggregateInput
    _max?: LogsMaxOrderByAggregateInput
    _min?: LogsMinOrderByAggregateInput
    _sum?: LogsSumOrderByAggregateInput
  }

  export type LogsScalarWhereWithAggregatesInput = {
    AND?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    OR?: LogsScalarWhereWithAggregatesInput[]
    NOT?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Logs"> | number
    userId?: IntWithAggregatesFilter<"Logs"> | number
    computerId?: StringWithAggregatesFilter<"Logs"> | string
    senderId?: StringWithAggregatesFilter<"Logs"> | string
    senderIp?: StringWithAggregatesFilter<"Logs"> | string
    gameId?: StringWithAggregatesFilter<"Logs"> | string
    message?: StringWithAggregatesFilter<"Logs"> | string
    created?: DateTimeWithAggregatesFilter<"Logs"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
  }

  export type GameCreateInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    userId: number
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id: string
    userId: number
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HardwareCreateInput = {
    type: $Enums.HardwareTypes
    strength: number
    computer: ComputerCreateNestedOneWithoutHardwareInput
    game: GameCreateNestedOneWithoutHardwareInput
  }

  export type HardwareUncheckedCreateInput = {
    id?: number
    computerId: string
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareUpdateInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
    computer?: ComputerUpdateOneRequiredWithoutHardwareNestedInput
    game?: GameUpdateOneRequiredWithoutHardwareNestedInput
  }

  export type HardwareUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareCreateManyInput = {
    id?: number
    computerId: string
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareUpdateManyMutationInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type AddressBookCreateInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAddressBookInput
    computer: ComputerCreateNestedOneWithoutAddressBookInput
    game: GameCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookUpdateInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAddressBookNestedInput
    computer?: ComputerUpdateOneRequiredWithoutAddressBookNestedInput
    game?: GameUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookCreateManyInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookUpdateManyMutationInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type DNSCreateInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    user: UserCreateNestedOneWithoutDnsInput
    computer: ComputerCreateNestedOneWithoutDnsInput
    game: GameCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateInput = {
    id?: number
    userId: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSUpdateInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDnsNestedInput
    computer?: ComputerUpdateOneRequiredWithoutDnsNestedInput
    game?: GameUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSCreateManyInput = {
    id?: number
    userId: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSUpdateManyMutationInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBookCreateInput = {
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAccountBookInput
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
    game: GameCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookCreateManyInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProfileInput
    game: GameCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    userId: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    game?: GameUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateManyInput = {
    id?: number
    userId: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryCreateInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutMemoryInput
    game: GameCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
  }

  export type MemoryUncheckedCreateInput = {
    id?: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryCreateManyInput = {
    id?: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ComputerCreateInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type ComputerCreateManyInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
  }

  export type ComputerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComputerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestsCreateInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    game: GameCreateNestedOneWithoutQuestsInput
    userQuests?: UserQuestsCreateNestedManyWithoutQuestInput
  }

  export type QuestsUncheckedCreateInput = {
    id?: string
    gameId: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    game?: GameUpdateOneRequiredWithoutQuestsNestedInput
    userQuests?: UserQuestsUpdateManyWithoutQuestNestedInput
  }

  export type QuestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    userQuests?: UserQuestsUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestsCreateManyInput = {
    id?: string
    gameId: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
  }

  export type QuestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserQuestsCreateInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    quest: QuestsCreateNestedOneWithoutUserQuestsInput
    user: UserCreateNestedOneWithoutUserQuestsInput
    game: GameCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateInput = {
    id?: string
    questsId: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    quest?: QuestsUpdateOneRequiredWithoutUserQuestsNestedInput
    user?: UserUpdateOneRequiredWithoutUserQuestsNestedInput
    game?: GameUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsCreateManyInput = {
    id?: string
    questsId: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoftwareCreateInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutSoftwareInput
    computer: ComputerCreateNestedOneWithoutSoftwareInput
    game: GameCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateInput = {
    id?: string
    userId: number
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutSoftwareNestedInput
    computer?: ComputerUpdateOneRequiredWithoutSoftwareNestedInput
    game?: GameUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateManyInput = {
    id?: string
    userId: number
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProcessInput
    computer: ComputerCreateNestedOneWithoutProcessInput
    game: GameCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProcessNestedInput
    computer?: ComputerUpdateOneRequiredWithoutProcessNestedInput
    game?: GameUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateManyInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationsCreateInput = {
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsCreateManyInput = {
    id?: number
    userId: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogsCreateInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    user: UserCreateNestedOneWithoutLogsInput
    computer: ComputerCreateNestedOneWithoutLogsInput
    game: GameCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsUpdateInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
    computer?: ComputerUpdateOneRequiredWithoutLogsNestedInput
    game?: GameUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsCreateManyInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsUpdateManyMutationInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGroupsFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsFilter<$PrismaModel> | $Enums.Groups
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ComputerListRelationFilter = {
    every?: ComputerWhereInput
    some?: ComputerWhereInput
    none?: ComputerWhereInput
  }

  export type SoftwareListRelationFilter = {
    every?: SoftwareWhereInput
    some?: SoftwareWhereInput
    none?: SoftwareWhereInput
  }

  export type MemoryListRelationFilter = {
    every?: MemoryWhereInput
    some?: MemoryWhereInput
    none?: MemoryWhereInput
  }

  export type ProcessListRelationFilter = {
    every?: ProcessWhereInput
    some?: ProcessWhereInput
    none?: ProcessWhereInput
  }

  export type UserQuestsListRelationFilter = {
    every?: UserQuestsWhereInput
    some?: UserQuestsWhereInput
    none?: UserQuestsWhereInput
  }

  export type AddressBookListRelationFilter = {
    every?: AddressBookWhereInput
    some?: AddressBookWhereInput
    none?: AddressBookWhereInput
  }

  export type AccountBookListRelationFilter = {
    every?: AccountBookWhereInput
    some?: AccountBookWhereInput
    none?: AccountBookWhereInput
  }

  export type LogsListRelationFilter = {
    every?: LogsWhereInput
    some?: LogsWhereInput
    none?: LogsWhereInput
  }

  export type DNSListRelationFilter = {
    every?: DNSWhereInput
    some?: DNSWhereInput
    none?: DNSWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComputerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SoftwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserQuestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DNSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrder
    group?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrder
    group?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrder
    group?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGroupsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsWithAggregatesFilter<$PrismaModel> | $Enums.Groups
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupsFilter<$PrismaModel>
    _max?: NestedEnumGroupsFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type HardwareListRelationFilter = {
    every?: HardwareWhereInput
    some?: HardwareWhereInput
    none?: HardwareWhereInput
  }

  export type QuestsListRelationFilter = {
    every?: QuestsWhereInput
    some?: QuestsWhereInput
    none?: QuestsWhereInput
  }

  export type HardwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumHardwareTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesFilter<$PrismaModel> | $Enums.HardwareTypes
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ComputerRelationFilter = {
    is?: ComputerWhereInput
    isNot?: ComputerWhereInput
  }

  export type GameRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type HardwareCountOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
  }

  export type HardwareAvgOrderByAggregateInput = {
    id?: SortOrder
    strength?: SortOrder
  }

  export type HardwareMaxOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
  }

  export type HardwareMinOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
  }

  export type HardwareSumOrderByAggregateInput = {
    id?: SortOrder
    strength?: SortOrder
  }

  export type EnumHardwareTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesWithAggregatesFilter<$PrismaModel> | $Enums.HardwareTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHardwareTypesFilter<$PrismaModel>
    _max?: NestedEnumHardwareTypesFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AddressBookCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
  }

  export type AddressBookAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AddressBookMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
  }

  export type AddressBookMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
  }

  export type AddressBookSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DNSCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
  }

  export type DNSAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DNSMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
  }

  export type DNSMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
  }

  export type DNSSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MemoryRelationFilter = {
    is?: MemoryWhereInput
    isNot?: MemoryWhereInput
  }

  export type AccountBookCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
  }

  export type AccountBookAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AccountBookMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    gameId?: SortOrder
  }

  export type AccountBookMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    gameId?: SortOrder
  }

  export type AccountBookSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    data?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MemoryCountOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
    data?: SortOrder
  }

  export type MemoryAvgOrderByAggregateInput = {
    userId?: SortOrder
    value?: SortOrder
  }

  export type MemoryMaxOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type MemoryMinOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type MemorySumOrderByAggregateInput = {
    userId?: SortOrder
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ComputerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ComputerAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ComputerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ComputerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ComputerSumOrderByAggregateInput = {
    userId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuestsCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    reward?: SortOrder
    open?: SortOrder
  }

  export type QuestsMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    open?: SortOrder
  }

  export type QuestsMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    open?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuestsRelationFilter = {
    is?: QuestsWhereInput
    isNot?: QuestsWhereInput
  }

  export type UserQuestsCountOrderByAggregateInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserQuestsAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserQuestsMaxOrderByAggregateInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserQuestsMinOrderByAggregateInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserQuestsSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SoftwareCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
  }

  export type SoftwareAvgOrderByAggregateInput = {
    userId?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
  }

  export type SoftwareMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SoftwareMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SoftwareSumOrderByAggregateInput = {
    userId?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
  }

  export type ProcessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
    data?: SortOrder
  }

  export type ProcessAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
  }

  export type ProcessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
  }

  export type ProcessSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
  }

  export type NotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    read?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    read?: SortOrder
  }

  export type NotificationsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type LogsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type LogsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type LogsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ComputerCreateNestedManyWithoutUserInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type SoftwareCreateNestedManyWithoutUserInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type MemoryCreateNestedManyWithoutUserInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type UserQuestsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type AddressBookCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type AccountBookCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutUserInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type DNSCreateNestedManyWithoutUserInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ComputerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type SoftwareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type MemoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type UserQuestsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type AddressBookUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type AccountBookUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type DNSUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGroupsFieldUpdateOperationsInput = {
    set?: $Enums.Groups
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ComputerUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutUserInput | ComputerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutUserInput | ComputerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutUserInput | ComputerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type SoftwareUpdateManyWithoutUserNestedInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutUserInput | SoftwareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutUserInput | SoftwareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutUserInput | SoftwareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type MemoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutUserInput | MemoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutUserInput | MemoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutUserInput | MemoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type UserQuestsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutUserInput | UserQuestsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutUserInput | UserQuestsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutUserInput | UserQuestsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type AddressBookUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutUserInput | AddressBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutUserInput | AddressBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutUserInput | AddressBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type AccountBookUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutUserInput | AccountBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutUserInput | AccountBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutUserInput | AccountBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUserInput | LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUserInput | LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUserInput | LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type DNSUpdateManyWithoutUserNestedInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutUserInput | DNSUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutUserInput | DNSUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutUserInput | DNSUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ComputerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutUserInput | ComputerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutUserInput | ComputerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutUserInput | ComputerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type SoftwareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutUserInput | SoftwareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutUserInput | SoftwareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutUserInput | SoftwareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type MemoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutUserInput | MemoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutUserInput | MemoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutUserInput | MemoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type UserQuestsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutUserInput | UserQuestsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutUserInput | UserQuestsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutUserInput | UserQuestsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type AddressBookUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutUserInput | AddressBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutUserInput | AddressBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutUserInput | AddressBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type AccountBookUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutUserInput | AccountBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutUserInput | AccountBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutUserInput | AccountBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUserInput | LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUserInput | LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUserInput | LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type DNSUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutUserInput | DNSUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutUserInput | DNSUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutUserInput | DNSUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type SoftwareCreateNestedManyWithoutGameInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type HardwareCreateNestedManyWithoutGameInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type ComputerCreateNestedManyWithoutGameInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type MemoryCreateNestedManyWithoutGameInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutGameInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type QuestsCreateNestedManyWithoutGameInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
  }

  export type UserQuestsCreateNestedManyWithoutGameInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutGameInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type AddressBookCreateNestedManyWithoutGameInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type AccountBookCreateNestedManyWithoutGameInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type DNSCreateNestedManyWithoutGameInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutGameInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type SoftwareUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type HardwareUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type ComputerUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type MemoryUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type QuestsUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
  }

  export type UserQuestsUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type AddressBookUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type AccountBookUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type DNSUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SoftwareUpdateManyWithoutGameNestedInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutGameInput | SoftwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutGameInput | SoftwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutGameInput | SoftwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type HardwareUpdateManyWithoutGameNestedInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutGameInput | HardwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutGameInput | HardwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutGameInput | HardwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type ComputerUpdateManyWithoutGameNestedInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutGameInput | ComputerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutGameInput | ComputerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutGameInput | ComputerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type MemoryUpdateManyWithoutGameNestedInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutGameInput | MemoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutGameInput | MemoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutGameInput | MemoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutGameInput | ProcessUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutGameInput | ProcessUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutGameInput | ProcessUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type QuestsUpdateManyWithoutGameNestedInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    upsert?: QuestsUpsertWithWhereUniqueWithoutGameInput | QuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    set?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    disconnect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    delete?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    update?: QuestsUpdateWithWhereUniqueWithoutGameInput | QuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: QuestsUpdateManyWithWhereWithoutGameInput | QuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
  }

  export type UserQuestsUpdateManyWithoutGameNestedInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutGameInput | UserQuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutGameInput | UserQuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutGameInput | UserQuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutGameNestedInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutGameInput | LogsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutGameInput | LogsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutGameInput | LogsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type AddressBookUpdateManyWithoutGameNestedInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutGameInput | AddressBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutGameInput | AddressBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutGameInput | AddressBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type AccountBookUpdateManyWithoutGameNestedInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutGameInput | AccountBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutGameInput | AccountBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutGameInput | AccountBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type DNSUpdateManyWithoutGameNestedInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutGameInput | DNSUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutGameInput | DNSUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutGameInput | DNSUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutGameInput | ProfileUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutGameInput | ProfileUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutGameInput | ProfileUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type SoftwareUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutGameInput | SoftwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutGameInput | SoftwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutGameInput | SoftwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type HardwareUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutGameInput | HardwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutGameInput | HardwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutGameInput | HardwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type ComputerUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutGameInput | ComputerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutGameInput | ComputerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutGameInput | ComputerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type MemoryUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutGameInput | MemoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutGameInput | MemoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutGameInput | MemoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutGameInput | ProcessUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutGameInput | ProcessUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutGameInput | ProcessUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type QuestsUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    upsert?: QuestsUpsertWithWhereUniqueWithoutGameInput | QuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    set?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    disconnect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    delete?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    update?: QuestsUpdateWithWhereUniqueWithoutGameInput | QuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: QuestsUpdateManyWithWhereWithoutGameInput | QuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
  }

  export type UserQuestsUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutGameInput | UserQuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutGameInput | UserQuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutGameInput | UserQuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutGameInput | LogsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutGameInput | LogsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutGameInput | LogsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type AddressBookUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutGameInput | AddressBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutGameInput | AddressBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutGameInput | AddressBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type AccountBookUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutGameInput | AccountBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutGameInput | AccountBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutGameInput | AccountBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type DNSUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutGameInput | DNSUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutGameInput | DNSUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutGameInput | DNSUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutGameInput | ProfileUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutGameInput | ProfileUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutGameInput | ProfileUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    upsert?: UserUpsertWithoutSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>
  }

  export type ComputerCreateNestedOneWithoutHardwareInput = {
    create?: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutHardwareInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutHardwareInput = {
    create?: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutHardwareInput
    connect?: GameWhereUniqueInput
  }

  export type EnumHardwareTypesFieldUpdateOperationsInput = {
    set?: $Enums.HardwareTypes
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComputerUpdateOneRequiredWithoutHardwareNestedInput = {
    create?: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutHardwareInput
    upsert?: ComputerUpsertWithoutHardwareInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutHardwareInput, ComputerUpdateWithoutHardwareInput>, ComputerUncheckedUpdateWithoutHardwareInput>
  }

  export type GameUpdateOneRequiredWithoutHardwareNestedInput = {
    create?: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutHardwareInput
    upsert?: GameUpsertWithoutHardwareInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutHardwareInput, GameUpdateWithoutHardwareInput>, GameUncheckedUpdateWithoutHardwareInput>
  }

  export type UserCreateNestedOneWithoutAddressBookInput = {
    create?: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressBookInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerCreateNestedOneWithoutAddressBookInput = {
    create?: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAddressBookInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutAddressBookInput = {
    create?: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAddressBookInput
    connect?: GameWhereUniqueInput
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type UserUpdateOneRequiredWithoutAddressBookNestedInput = {
    create?: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressBookInput
    upsert?: UserUpsertWithoutAddressBookInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressBookInput, UserUpdateWithoutAddressBookInput>, UserUncheckedUpdateWithoutAddressBookInput>
  }

  export type ComputerUpdateOneRequiredWithoutAddressBookNestedInput = {
    create?: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAddressBookInput
    upsert?: ComputerUpsertWithoutAddressBookInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutAddressBookInput, ComputerUpdateWithoutAddressBookInput>, ComputerUncheckedUpdateWithoutAddressBookInput>
  }

  export type GameUpdateOneRequiredWithoutAddressBookNestedInput = {
    create?: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAddressBookInput
    upsert?: GameUpsertWithoutAddressBookInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutAddressBookInput, GameUpdateWithoutAddressBookInput>, GameUncheckedUpdateWithoutAddressBookInput>
  }

  export type UserCreateNestedOneWithoutDnsInput = {
    create?: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDnsInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerCreateNestedOneWithoutDnsInput = {
    create?: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutDnsInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutDnsInput = {
    create?: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
    connectOrCreate?: GameCreateOrConnectWithoutDnsInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDnsNestedInput = {
    create?: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDnsInput
    upsert?: UserUpsertWithoutDnsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDnsInput, UserUpdateWithoutDnsInput>, UserUncheckedUpdateWithoutDnsInput>
  }

  export type ComputerUpdateOneRequiredWithoutDnsNestedInput = {
    create?: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutDnsInput
    upsert?: ComputerUpsertWithoutDnsInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutDnsInput, ComputerUpdateWithoutDnsInput>, ComputerUncheckedUpdateWithoutDnsInput>
  }

  export type GameUpdateOneRequiredWithoutDnsNestedInput = {
    create?: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
    connectOrCreate?: GameCreateOrConnectWithoutDnsInput
    upsert?: GameUpsertWithoutDnsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutDnsInput, GameUpdateWithoutDnsInput>, GameUncheckedUpdateWithoutDnsInput>
  }

  export type UserCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountBookInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAccountBookInput
    connect?: ComputerWhereUniqueInput
  }

  export type MemoryCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: MemoryCreateOrConnectWithoutAccountBookInput
    connect?: MemoryWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAccountBookInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountBookInput
    upsert?: UserUpsertWithoutAccountBookInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountBookInput, UserUpdateWithoutAccountBookInput>, UserUncheckedUpdateWithoutAccountBookInput>
  }

  export type ComputerUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAccountBookInput
    upsert?: ComputerUpsertWithoutAccountBookInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutAccountBookInput, ComputerUpdateWithoutAccountBookInput>, ComputerUncheckedUpdateWithoutAccountBookInput>
  }

  export type MemoryUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: MemoryCreateOrConnectWithoutAccountBookInput
    upsert?: MemoryUpsertWithoutAccountBookInput
    connect?: MemoryWhereUniqueInput
    update?: XOR<XOR<MemoryUpdateToOneWithWhereWithoutAccountBookInput, MemoryUpdateWithoutAccountBookInput>, MemoryUncheckedUpdateWithoutAccountBookInput>
  }

  export type GameUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAccountBookInput
    upsert?: GameUpsertWithoutAccountBookInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutAccountBookInput, GameUpdateWithoutAccountBookInput>, GameUncheckedUpdateWithoutAccountBookInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutProfileInput = {
    create?: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
    connectOrCreate?: GameCreateOrConnectWithoutProfileInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type GameUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
    connectOrCreate?: GameCreateOrConnectWithoutProfileInput
    upsert?: GameUpsertWithoutProfileInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutProfileInput, GameUpdateWithoutProfileInput>, GameUncheckedUpdateWithoutProfileInput>
  }

  export type ComputerCreateNestedOneWithoutMemoryInput = {
    create?: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutMemoryInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutMemoryInput = {
    create?: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: GameCreateOrConnectWithoutMemoryInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMemoryInput = {
    create?: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemoryInput
    connect?: UserWhereUniqueInput
  }

  export type AccountBookCreateNestedManyWithoutMemoryInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type AccountBookUncheckedCreateNestedManyWithoutMemoryInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComputerUpdateOneRequiredWithoutMemoryNestedInput = {
    create?: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutMemoryInput
    upsert?: ComputerUpsertWithoutMemoryInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutMemoryInput, ComputerUpdateWithoutMemoryInput>, ComputerUncheckedUpdateWithoutMemoryInput>
  }

  export type GameUpdateOneRequiredWithoutMemoryNestedInput = {
    create?: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: GameCreateOrConnectWithoutMemoryInput
    upsert?: GameUpsertWithoutMemoryInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutMemoryInput, GameUpdateWithoutMemoryInput>, GameUncheckedUpdateWithoutMemoryInput>
  }

  export type UserUpdateOneRequiredWithoutMemoryNestedInput = {
    create?: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemoryInput
    upsert?: UserUpsertWithoutMemoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemoryInput, UserUpdateWithoutMemoryInput>, UserUncheckedUpdateWithoutMemoryInput>
  }

  export type AccountBookUpdateManyWithoutMemoryNestedInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutMemoryInput | AccountBookUpsertWithWhereUniqueWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutMemoryInput | AccountBookUpdateWithWhereUniqueWithoutMemoryInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutMemoryInput | AccountBookUpdateManyWithWhereWithoutMemoryInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AccountBookUncheckedUpdateManyWithoutMemoryNestedInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutMemoryInput | AccountBookUpsertWithWhereUniqueWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutMemoryInput | AccountBookUpdateWithWhereUniqueWithoutMemoryInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutMemoryInput | AccountBookUpdateManyWithWhereWithoutMemoryInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutComputerInput = {
    create?: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
    connectOrCreate?: UserCreateOrConnectWithoutComputerInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutComputerInput = {
    create?: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
    connectOrCreate?: GameCreateOrConnectWithoutComputerInput
    connect?: GameWhereUniqueInput
  }

  export type DNSCreateNestedManyWithoutComputerInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type HardwareCreateNestedManyWithoutComputerInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type SoftwareCreateNestedManyWithoutComputerInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type MemoryCreateNestedManyWithoutComputerInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutComputerInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type AddressBookCreateNestedManyWithoutComputerInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type AccountBookCreateNestedManyWithoutComputerInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutComputerInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type DNSUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type HardwareUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type SoftwareUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type MemoryUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type AddressBookUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type AccountBookUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutComputerNestedInput = {
    create?: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
    connectOrCreate?: UserCreateOrConnectWithoutComputerInput
    upsert?: UserUpsertWithoutComputerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComputerInput, UserUpdateWithoutComputerInput>, UserUncheckedUpdateWithoutComputerInput>
  }

  export type GameUpdateOneRequiredWithoutComputerNestedInput = {
    create?: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
    connectOrCreate?: GameCreateOrConnectWithoutComputerInput
    upsert?: GameUpsertWithoutComputerInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutComputerInput, GameUpdateWithoutComputerInput>, GameUncheckedUpdateWithoutComputerInput>
  }

  export type DNSUpdateManyWithoutComputerNestedInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutComputerInput | DNSUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutComputerInput | DNSUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutComputerInput | DNSUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type HardwareUpdateManyWithoutComputerNestedInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutComputerInput | HardwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutComputerInput | HardwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutComputerInput | HardwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type SoftwareUpdateManyWithoutComputerNestedInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutComputerInput | SoftwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutComputerInput | SoftwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutComputerInput | SoftwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type MemoryUpdateManyWithoutComputerNestedInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutComputerInput | MemoryUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutComputerInput | MemoryUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutComputerInput | MemoryUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutComputerNestedInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutComputerInput | ProcessUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutComputerInput | ProcessUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutComputerInput | ProcessUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type AddressBookUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutComputerInput | AddressBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutComputerInput | AddressBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutComputerInput | AddressBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type AccountBookUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutComputerInput | AccountBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutComputerInput | AccountBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutComputerInput | AccountBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutComputerNestedInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutComputerInput | LogsUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutComputerInput | LogsUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutComputerInput | LogsUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type DNSUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutComputerInput | DNSUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutComputerInput | DNSUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutComputerInput | DNSUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type HardwareUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutComputerInput | HardwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutComputerInput | HardwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutComputerInput | HardwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type SoftwareUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutComputerInput | SoftwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutComputerInput | SoftwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutComputerInput | SoftwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type MemoryUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutComputerInput | MemoryUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutComputerInput | MemoryUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutComputerInput | MemoryUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutComputerInput | ProcessUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutComputerInput | ProcessUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutComputerInput | ProcessUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type AddressBookUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutComputerInput | AddressBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutComputerInput | AddressBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutComputerInput | AddressBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type AccountBookUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutComputerInput | AccountBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutComputerInput | AccountBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutComputerInput | AccountBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutComputerInput | LogsUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutComputerInput | LogsUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutComputerInput | LogsUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutQuestsInput = {
    create?: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutQuestsInput
    connect?: GameWhereUniqueInput
  }

  export type UserQuestsCreateNestedManyWithoutQuestInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type UserQuestsUncheckedCreateNestedManyWithoutQuestInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GameUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutQuestsInput
    upsert?: GameUpsertWithoutQuestsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutQuestsInput, GameUpdateWithoutQuestsInput>, GameUncheckedUpdateWithoutQuestsInput>
  }

  export type UserQuestsUpdateManyWithoutQuestNestedInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutQuestInput | UserQuestsUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutQuestInput | UserQuestsUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutQuestInput | UserQuestsUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type UserQuestsUncheckedUpdateManyWithoutQuestNestedInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutQuestInput | UserQuestsUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutQuestInput | UserQuestsUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutQuestInput | UserQuestsUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type QuestsCreateNestedOneWithoutUserQuestsInput = {
    create?: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: QuestsCreateOrConnectWithoutUserQuestsInput
    connect?: QuestsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserQuestsInput = {
    create?: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserQuestsInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutUserQuestsInput = {
    create?: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutUserQuestsInput
    connect?: GameWhereUniqueInput
  }

  export type QuestsUpdateOneRequiredWithoutUserQuestsNestedInput = {
    create?: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: QuestsCreateOrConnectWithoutUserQuestsInput
    upsert?: QuestsUpsertWithoutUserQuestsInput
    connect?: QuestsWhereUniqueInput
    update?: XOR<XOR<QuestsUpdateToOneWithWhereWithoutUserQuestsInput, QuestsUpdateWithoutUserQuestsInput>, QuestsUncheckedUpdateWithoutUserQuestsInput>
  }

  export type UserUpdateOneRequiredWithoutUserQuestsNestedInput = {
    create?: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserQuestsInput
    upsert?: UserUpsertWithoutUserQuestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserQuestsInput, UserUpdateWithoutUserQuestsInput>, UserUncheckedUpdateWithoutUserQuestsInput>
  }

  export type GameUpdateOneRequiredWithoutUserQuestsNestedInput = {
    create?: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutUserQuestsInput
    upsert?: GameUpsertWithoutUserQuestsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutUserQuestsInput, GameUpdateWithoutUserQuestsInput>, GameUncheckedUpdateWithoutUserQuestsInput>
  }

  export type UserCreateNestedOneWithoutSoftwareInput = {
    create?: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoftwareInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerCreateNestedOneWithoutSoftwareInput = {
    create?: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutSoftwareInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutSoftwareInput = {
    create?: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutSoftwareInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSoftwareNestedInput = {
    create?: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoftwareInput
    upsert?: UserUpsertWithoutSoftwareInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSoftwareInput, UserUpdateWithoutSoftwareInput>, UserUncheckedUpdateWithoutSoftwareInput>
  }

  export type ComputerUpdateOneRequiredWithoutSoftwareNestedInput = {
    create?: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutSoftwareInput
    upsert?: ComputerUpsertWithoutSoftwareInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutSoftwareInput, ComputerUpdateWithoutSoftwareInput>, ComputerUncheckedUpdateWithoutSoftwareInput>
  }

  export type GameUpdateOneRequiredWithoutSoftwareNestedInput = {
    create?: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutSoftwareInput
    upsert?: GameUpsertWithoutSoftwareInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutSoftwareInput, GameUpdateWithoutSoftwareInput>, GameUncheckedUpdateWithoutSoftwareInput>
  }

  export type UserCreateNestedOneWithoutProcessInput = {
    create?: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerCreateNestedOneWithoutProcessInput = {
    create?: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutProcessInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutProcessInput = {
    create?: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
    connectOrCreate?: GameCreateOrConnectWithoutProcessInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProcessNestedInput = {
    create?: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessInput
    upsert?: UserUpsertWithoutProcessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessInput, UserUpdateWithoutProcessInput>, UserUncheckedUpdateWithoutProcessInput>
  }

  export type ComputerUpdateOneRequiredWithoutProcessNestedInput = {
    create?: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutProcessInput
    upsert?: ComputerUpsertWithoutProcessInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutProcessInput, ComputerUpdateWithoutProcessInput>, ComputerUncheckedUpdateWithoutProcessInput>
  }

  export type GameUpdateOneRequiredWithoutProcessNestedInput = {
    create?: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
    connectOrCreate?: GameCreateOrConnectWithoutProcessInput
    upsert?: GameUpsertWithoutProcessInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutProcessInput, GameUpdateWithoutProcessInput>, GameUncheckedUpdateWithoutProcessInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerCreateNestedOneWithoutLogsInput = {
    create?: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutLogsInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutLogsInput = {
    create?: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
    connectOrCreate?: GameCreateOrConnectWithoutLogsInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type ComputerUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutLogsInput
    upsert?: ComputerUpsertWithoutLogsInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutLogsInput, ComputerUpdateWithoutLogsInput>, ComputerUncheckedUpdateWithoutLogsInput>
  }

  export type GameUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
    connectOrCreate?: GameCreateOrConnectWithoutLogsInput
    upsert?: GameUpsertWithoutLogsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutLogsInput, GameUpdateWithoutLogsInput>, GameUncheckedUpdateWithoutLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGroupsFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsFilter<$PrismaModel> | $Enums.Groups
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGroupsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsWithAggregatesFilter<$PrismaModel> | $Enums.Groups
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupsFilter<$PrismaModel>
    _max?: NestedEnumGroupsFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumHardwareTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesFilter<$PrismaModel> | $Enums.HardwareTypes
  }

  export type NestedEnumHardwareTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesWithAggregatesFilter<$PrismaModel> | $Enums.HardwareTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHardwareTypesFilter<$PrismaModel>
    _max?: NestedEnumHardwareTypesFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComputerCreateWithoutUserInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutUserInput = {
    id?: string
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutUserInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput>
  }

  export type ComputerCreateManyUserInputEnvelope = {
    data: ComputerCreateManyUserInput | ComputerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareCreateWithoutUserInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutSoftwareInput
    game: GameCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateWithoutUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateOrConnectWithoutUserInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput>
  }

  export type SoftwareCreateManyUserInputEnvelope = {
    data: SoftwareCreateManyUserInput | SoftwareCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemoryCreateWithoutUserInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutMemoryInput
    game: GameCreateNestedOneWithoutMemoryInput
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryCreateOrConnectWithoutUserInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput>
  }

  export type MemoryCreateManyUserInputEnvelope = {
    data: MemoryCreateManyUserInput | MemoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCreateWithoutUserInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutProcessInput
    game: GameCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutUserInput = {
    id?: string
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateOrConnectWithoutUserInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessCreateManyUserInputEnvelope = {
    data: ProcessCreateManyUserInput | ProcessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserQuestsCreateWithoutUserInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    quest: QuestsCreateNestedOneWithoutUserQuestsInput
    game: GameCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateWithoutUserInput = {
    id?: string
    questsId: string
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsCreateOrConnectWithoutUserInput = {
    where: UserQuestsWhereUniqueInput
    create: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput>
  }

  export type UserQuestsCreateManyUserInputEnvelope = {
    data: UserQuestsCreateManyUserInput | UserQuestsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressBookCreateWithoutUserInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAddressBookInput
    game: GameCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateWithoutUserInput = {
    id?: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookCreateOrConnectWithoutUserInput = {
    where: AddressBookWhereUniqueInput
    create: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput>
  }

  export type AddressBookCreateManyUserInputEnvelope = {
    data: AddressBookCreateManyUserInput | AddressBookCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountBookCreateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
    game: GameCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutUserInput = {
    id?: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateOrConnectWithoutUserInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput>
  }

  export type AccountBookCreateManyUserInputEnvelope = {
    data: AccountBookCreateManyUserInput | AccountBookCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogsCreateWithoutUserInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutLogsInput
    game: GameCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateWithoutUserInput = {
    id?: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsCreateOrConnectWithoutUserInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type LogsCreateManyUserInputEnvelope = {
    data: LogsCreateManyUserInput | LogsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DNSCreateWithoutUserInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutDnsInput
    game: GameCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateWithoutUserInput = {
    id?: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSCreateOrConnectWithoutUserInput = {
    where: DNSWhereUniqueInput
    create: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput>
  }

  export type DNSCreateManyUserInputEnvelope = {
    data: DNSCreateManyUserInput | DNSCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileCreateManyUserInputEnvelope = {
    data: ProfileCreateManyUserInput | ProfileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutUserInput = {
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsCreateOrConnectWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsCreateManyUserInputEnvelope = {
    data: NotificationsCreateManyUserInput | NotificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    lastAction?: DateTimeFilter<"Session"> | Date | string
    created?: DateTimeFilter<"Session"> | Date | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type ComputerUpsertWithWhereUniqueWithoutUserInput = {
    where: ComputerWhereUniqueInput
    update: XOR<ComputerUpdateWithoutUserInput, ComputerUncheckedUpdateWithoutUserInput>
    create: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput>
  }

  export type ComputerUpdateWithWhereUniqueWithoutUserInput = {
    where: ComputerWhereUniqueInput
    data: XOR<ComputerUpdateWithoutUserInput, ComputerUncheckedUpdateWithoutUserInput>
  }

  export type ComputerUpdateManyWithWhereWithoutUserInput = {
    where: ComputerScalarWhereInput
    data: XOR<ComputerUpdateManyMutationInput, ComputerUncheckedUpdateManyWithoutUserInput>
  }

  export type ComputerScalarWhereInput = {
    AND?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
    OR?: ComputerScalarWhereInput[]
    NOT?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
    id?: StringFilter<"Computer"> | string
    userId?: IntFilter<"Computer"> | number
    type?: StringFilter<"Computer"> | string
    gameId?: StringFilter<"Computer"> | string
    ip?: StringFilter<"Computer"> | string
    data?: JsonFilter<"Computer">
    created?: DateTimeFilter<"Computer"> | Date | string
    updated?: DateTimeFilter<"Computer"> | Date | string
  }

  export type SoftwareUpsertWithWhereUniqueWithoutUserInput = {
    where: SoftwareWhereUniqueInput
    update: XOR<SoftwareUpdateWithoutUserInput, SoftwareUncheckedUpdateWithoutUserInput>
    create: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput>
  }

  export type SoftwareUpdateWithWhereUniqueWithoutUserInput = {
    where: SoftwareWhereUniqueInput
    data: XOR<SoftwareUpdateWithoutUserInput, SoftwareUncheckedUpdateWithoutUserInput>
  }

  export type SoftwareUpdateManyWithWhereWithoutUserInput = {
    where: SoftwareScalarWhereInput
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyWithoutUserInput>
  }

  export type SoftwareScalarWhereInput = {
    AND?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
    OR?: SoftwareScalarWhereInput[]
    NOT?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
    id?: StringFilter<"Software"> | string
    userId?: IntFilter<"Software"> | number
    computerId?: StringFilter<"Software"> | string
    gameId?: StringFilter<"Software"> | string
    type?: StringFilter<"Software"> | string
    level?: FloatFilter<"Software"> | number
    size?: FloatFilter<"Software"> | number
    opacity?: FloatFilter<"Software"> | number
    installed?: BoolFilter<"Software"> | boolean
    executed?: DateTimeFilter<"Software"> | Date | string
    created?: DateTimeFilter<"Software"> | Date | string
    updated?: DateTimeFilter<"Software"> | Date | string
    data?: JsonFilter<"Software">
  }

  export type MemoryUpsertWithWhereUniqueWithoutUserInput = {
    where: MemoryWhereUniqueInput
    update: XOR<MemoryUpdateWithoutUserInput, MemoryUncheckedUpdateWithoutUserInput>
    create: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput>
  }

  export type MemoryUpdateWithWhereUniqueWithoutUserInput = {
    where: MemoryWhereUniqueInput
    data: XOR<MemoryUpdateWithoutUserInput, MemoryUncheckedUpdateWithoutUserInput>
  }

  export type MemoryUpdateManyWithWhereWithoutUserInput = {
    where: MemoryScalarWhereInput
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyWithoutUserInput>
  }

  export type MemoryScalarWhereInput = {
    AND?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
    OR?: MemoryScalarWhereInput[]
    NOT?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
    id?: StringFilter<"Memory"> | string
    computerId?: StringFilter<"Memory"> | string
    gameId?: StringFilter<"Memory"> | string
    userId?: IntFilter<"Memory"> | number
    type?: StringFilter<"Memory"> | string
    key?: StringFilter<"Memory"> | string
    value?: FloatNullableFilter<"Memory"> | number | null
    data?: JsonFilter<"Memory">
  }

  export type ProcessUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
  }

  export type ProcessUpdateManyWithWhereWithoutUserInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessScalarWhereInput = {
    AND?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    OR?: ProcessScalarWhereInput[]
    NOT?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    id?: StringFilter<"Process"> | string
    userId?: IntFilter<"Process"> | number
    computerId?: StringFilter<"Process"> | string
    ip?: StringNullableFilter<"Process"> | string | null
    gameId?: StringFilter<"Process"> | string
    type?: StringFilter<"Process"> | string
    started?: DateTimeFilter<"Process"> | Date | string
    completion?: DateTimeFilter<"Process"> | Date | string
    data?: JsonFilter<"Process">
  }

  export type UserQuestsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserQuestsWhereUniqueInput
    update: XOR<UserQuestsUpdateWithoutUserInput, UserQuestsUncheckedUpdateWithoutUserInput>
    create: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput>
  }

  export type UserQuestsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserQuestsWhereUniqueInput
    data: XOR<UserQuestsUpdateWithoutUserInput, UserQuestsUncheckedUpdateWithoutUserInput>
  }

  export type UserQuestsUpdateManyWithWhereWithoutUserInput = {
    where: UserQuestsScalarWhereInput
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserQuestsScalarWhereInput = {
    AND?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
    OR?: UserQuestsScalarWhereInput[]
    NOT?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
    id?: StringFilter<"UserQuests"> | string
    questsId?: StringFilter<"UserQuests"> | string
    userId?: IntFilter<"UserQuests"> | number
    gameId?: StringFilter<"UserQuests"> | string
    completed?: BoolFilter<"UserQuests"> | boolean
    created?: DateTimeFilter<"UserQuests"> | Date | string
    updated?: DateTimeFilter<"UserQuests"> | Date | string
  }

  export type AddressBookUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressBookWhereUniqueInput
    update: XOR<AddressBookUpdateWithoutUserInput, AddressBookUncheckedUpdateWithoutUserInput>
    create: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput>
  }

  export type AddressBookUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressBookWhereUniqueInput
    data: XOR<AddressBookUpdateWithoutUserInput, AddressBookUncheckedUpdateWithoutUserInput>
  }

  export type AddressBookUpdateManyWithWhereWithoutUserInput = {
    where: AddressBookScalarWhereInput
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressBookScalarWhereInput = {
    AND?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
    OR?: AddressBookScalarWhereInput[]
    NOT?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
    id?: IntFilter<"AddressBook"> | number
    userId?: IntFilter<"AddressBook"> | number
    access?: EnumAccessLevelFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringFilter<"AddressBook"> | string
    ip?: StringFilter<"AddressBook"> | string
    data?: JsonFilter<"AddressBook">
    gameId?: StringFilter<"AddressBook"> | string
  }

  export type AccountBookUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutUserInput, AccountBookUncheckedUpdateWithoutUserInput>
    create: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutUserInput, AccountBookUncheckedUpdateWithoutUserInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutUserInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountBookScalarWhereInput = {
    AND?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
    OR?: AccountBookScalarWhereInput[]
    NOT?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
    id?: IntFilter<"AccountBook"> | number
    userId?: IntFilter<"AccountBook"> | number
    computerId?: StringFilter<"AccountBook"> | string
    memoryId?: StringFilter<"AccountBook"> | string
    data?: JsonFilter<"AccountBook">
    gameId?: StringFilter<"AccountBook"> | string
  }

  export type LogsUpsertWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
  }

  export type LogsUpdateManyWithWhereWithoutUserInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutUserInput>
  }

  export type LogsScalarWhereInput = {
    AND?: LogsScalarWhereInput | LogsScalarWhereInput[]
    OR?: LogsScalarWhereInput[]
    NOT?: LogsScalarWhereInput | LogsScalarWhereInput[]
    id?: IntFilter<"Logs"> | number
    userId?: IntFilter<"Logs"> | number
    computerId?: StringFilter<"Logs"> | string
    senderId?: StringFilter<"Logs"> | string
    senderIp?: StringFilter<"Logs"> | string
    gameId?: StringFilter<"Logs"> | string
    message?: StringFilter<"Logs"> | string
    created?: DateTimeFilter<"Logs"> | Date | string
  }

  export type DNSUpsertWithWhereUniqueWithoutUserInput = {
    where: DNSWhereUniqueInput
    update: XOR<DNSUpdateWithoutUserInput, DNSUncheckedUpdateWithoutUserInput>
    create: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput>
  }

  export type DNSUpdateWithWhereUniqueWithoutUserInput = {
    where: DNSWhereUniqueInput
    data: XOR<DNSUpdateWithoutUserInput, DNSUncheckedUpdateWithoutUserInput>
  }

  export type DNSUpdateManyWithWhereWithoutUserInput = {
    where: DNSScalarWhereInput
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyWithoutUserInput>
  }

  export type DNSScalarWhereInput = {
    AND?: DNSScalarWhereInput | DNSScalarWhereInput[]
    OR?: DNSScalarWhereInput[]
    NOT?: DNSScalarWhereInput | DNSScalarWhereInput[]
    id?: IntFilter<"DNS"> | number
    userId?: IntFilter<"DNS"> | number
    computerId?: StringFilter<"DNS"> | string
    gameId?: StringFilter<"DNS"> | string
    website?: StringFilter<"DNS"> | string
    tags?: StringFilter<"DNS"> | string
    description?: StringFilter<"DNS"> | string
    updated?: DateTimeFilter<"DNS"> | Date | string
    created?: DateTimeFilter<"DNS"> | Date | string
  }

  export type ProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateManyWithWhereWithoutUserInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: IntFilter<"Profile"> | number
    userId?: IntFilter<"Profile"> | number
    gameId?: StringFilter<"Profile"> | string
    data?: JsonFilter<"Profile">
  }

  export type NotificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutUserInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: IntFilter<"Notifications"> | number
    userId?: IntFilter<"Notifications"> | number
    type?: StringFilter<"Notifications"> | string
    content?: JsonFilter<"Notifications">
    read?: BoolFilter<"Notifications"> | boolean
  }

  export type SoftwareCreateWithoutGameInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutSoftwareInput
    computer: ComputerCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateWithoutGameInput = {
    id?: string
    userId: number
    computerId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateOrConnectWithoutGameInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput>
  }

  export type SoftwareCreateManyGameInputEnvelope = {
    data: SoftwareCreateManyGameInput | SoftwareCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type HardwareCreateWithoutGameInput = {
    type: $Enums.HardwareTypes
    strength: number
    computer: ComputerCreateNestedOneWithoutHardwareInput
  }

  export type HardwareUncheckedCreateWithoutGameInput = {
    id?: number
    computerId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareCreateOrConnectWithoutGameInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput>
  }

  export type HardwareCreateManyGameInputEnvelope = {
    data: HardwareCreateManyGameInput | HardwareCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type ComputerCreateWithoutGameInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutGameInput = {
    id?: string
    userId: number
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutGameInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput>
  }

  export type ComputerCreateManyGameInputEnvelope = {
    data: ComputerCreateManyGameInput | ComputerCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type MemoryCreateWithoutGameInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutGameInput = {
    id?: string
    computerId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryCreateOrConnectWithoutGameInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput>
  }

  export type MemoryCreateManyGameInputEnvelope = {
    data: MemoryCreateManyGameInput | MemoryCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCreateWithoutGameInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProcessInput
    computer: ComputerCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutGameInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateOrConnectWithoutGameInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput>
  }

  export type ProcessCreateManyGameInputEnvelope = {
    data: ProcessCreateManyGameInput | ProcessCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type QuestsCreateWithoutGameInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    userQuests?: UserQuestsCreateNestedManyWithoutQuestInput
  }

  export type QuestsUncheckedCreateWithoutGameInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestsCreateOrConnectWithoutGameInput = {
    where: QuestsWhereUniqueInput
    create: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput>
  }

  export type QuestsCreateManyGameInputEnvelope = {
    data: QuestsCreateManyGameInput | QuestsCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type UserQuestsCreateWithoutGameInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    quest: QuestsCreateNestedOneWithoutUserQuestsInput
    user: UserCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateWithoutGameInput = {
    id?: string
    questsId: string
    userId: number
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsCreateOrConnectWithoutGameInput = {
    where: UserQuestsWhereUniqueInput
    create: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput>
  }

  export type UserQuestsCreateManyGameInputEnvelope = {
    data: UserQuestsCreateManyGameInput | UserQuestsCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LogsCreateWithoutGameInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    user: UserCreateNestedOneWithoutLogsInput
    computer: ComputerCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
  }

  export type LogsCreateOrConnectWithoutGameInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput>
  }

  export type LogsCreateManyGameInputEnvelope = {
    data: LogsCreateManyGameInput | LogsCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type AddressBookCreateWithoutGameInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAddressBookInput
    computer: ComputerCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookCreateOrConnectWithoutGameInput = {
    where: AddressBookWhereUniqueInput
    create: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput>
  }

  export type AddressBookCreateManyGameInputEnvelope = {
    data: AddressBookCreateManyGameInput | AddressBookCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type AccountBookCreateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAccountBookInput
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookCreateOrConnectWithoutGameInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput>
  }

  export type AccountBookCreateManyGameInputEnvelope = {
    data: AccountBookCreateManyGameInput | AccountBookCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type DNSCreateWithoutGameInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    user: UserCreateNestedOneWithoutDnsInput
    computer: ComputerCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    computerId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSCreateOrConnectWithoutGameInput = {
    where: DNSWhereUniqueInput
    create: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput>
  }

  export type DNSCreateManyGameInputEnvelope = {
    data: DNSCreateManyGameInput | DNSCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateOrConnectWithoutGameInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput>
  }

  export type ProfileCreateManyGameInputEnvelope = {
    data: ProfileCreateManyGameInput | ProfileCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareUpsertWithWhereUniqueWithoutGameInput = {
    where: SoftwareWhereUniqueInput
    update: XOR<SoftwareUpdateWithoutGameInput, SoftwareUncheckedUpdateWithoutGameInput>
    create: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput>
  }

  export type SoftwareUpdateWithWhereUniqueWithoutGameInput = {
    where: SoftwareWhereUniqueInput
    data: XOR<SoftwareUpdateWithoutGameInput, SoftwareUncheckedUpdateWithoutGameInput>
  }

  export type SoftwareUpdateManyWithWhereWithoutGameInput = {
    where: SoftwareScalarWhereInput
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyWithoutGameInput>
  }

  export type HardwareUpsertWithWhereUniqueWithoutGameInput = {
    where: HardwareWhereUniqueInput
    update: XOR<HardwareUpdateWithoutGameInput, HardwareUncheckedUpdateWithoutGameInput>
    create: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput>
  }

  export type HardwareUpdateWithWhereUniqueWithoutGameInput = {
    where: HardwareWhereUniqueInput
    data: XOR<HardwareUpdateWithoutGameInput, HardwareUncheckedUpdateWithoutGameInput>
  }

  export type HardwareUpdateManyWithWhereWithoutGameInput = {
    where: HardwareScalarWhereInput
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyWithoutGameInput>
  }

  export type HardwareScalarWhereInput = {
    AND?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
    OR?: HardwareScalarWhereInput[]
    NOT?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
    id?: IntFilter<"Hardware"> | number
    computerId?: StringFilter<"Hardware"> | string
    gameId?: StringFilter<"Hardware"> | string
    type?: EnumHardwareTypesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatFilter<"Hardware"> | number
  }

  export type ComputerUpsertWithWhereUniqueWithoutGameInput = {
    where: ComputerWhereUniqueInput
    update: XOR<ComputerUpdateWithoutGameInput, ComputerUncheckedUpdateWithoutGameInput>
    create: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput>
  }

  export type ComputerUpdateWithWhereUniqueWithoutGameInput = {
    where: ComputerWhereUniqueInput
    data: XOR<ComputerUpdateWithoutGameInput, ComputerUncheckedUpdateWithoutGameInput>
  }

  export type ComputerUpdateManyWithWhereWithoutGameInput = {
    where: ComputerScalarWhereInput
    data: XOR<ComputerUpdateManyMutationInput, ComputerUncheckedUpdateManyWithoutGameInput>
  }

  export type MemoryUpsertWithWhereUniqueWithoutGameInput = {
    where: MemoryWhereUniqueInput
    update: XOR<MemoryUpdateWithoutGameInput, MemoryUncheckedUpdateWithoutGameInput>
    create: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput>
  }

  export type MemoryUpdateWithWhereUniqueWithoutGameInput = {
    where: MemoryWhereUniqueInput
    data: XOR<MemoryUpdateWithoutGameInput, MemoryUncheckedUpdateWithoutGameInput>
  }

  export type MemoryUpdateManyWithWhereWithoutGameInput = {
    where: MemoryScalarWhereInput
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyWithoutGameInput>
  }

  export type ProcessUpsertWithWhereUniqueWithoutGameInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutGameInput, ProcessUncheckedUpdateWithoutGameInput>
    create: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutGameInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutGameInput, ProcessUncheckedUpdateWithoutGameInput>
  }

  export type ProcessUpdateManyWithWhereWithoutGameInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutGameInput>
  }

  export type QuestsUpsertWithWhereUniqueWithoutGameInput = {
    where: QuestsWhereUniqueInput
    update: XOR<QuestsUpdateWithoutGameInput, QuestsUncheckedUpdateWithoutGameInput>
    create: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput>
  }

  export type QuestsUpdateWithWhereUniqueWithoutGameInput = {
    where: QuestsWhereUniqueInput
    data: XOR<QuestsUpdateWithoutGameInput, QuestsUncheckedUpdateWithoutGameInput>
  }

  export type QuestsUpdateManyWithWhereWithoutGameInput = {
    where: QuestsScalarWhereInput
    data: XOR<QuestsUpdateManyMutationInput, QuestsUncheckedUpdateManyWithoutGameInput>
  }

  export type QuestsScalarWhereInput = {
    AND?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
    OR?: QuestsScalarWhereInput[]
    NOT?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
    id?: StringFilter<"Quests"> | string
    gameId?: StringFilter<"Quests"> | string
    type?: StringFilter<"Quests"> | string
    title?: StringFilter<"Quests"> | string
    reward?: JsonNullableFilter<"Quests">
    open?: BoolFilter<"Quests"> | boolean
  }

  export type UserQuestsUpsertWithWhereUniqueWithoutGameInput = {
    where: UserQuestsWhereUniqueInput
    update: XOR<UserQuestsUpdateWithoutGameInput, UserQuestsUncheckedUpdateWithoutGameInput>
    create: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput>
  }

  export type UserQuestsUpdateWithWhereUniqueWithoutGameInput = {
    where: UserQuestsWhereUniqueInput
    data: XOR<UserQuestsUpdateWithoutGameInput, UserQuestsUncheckedUpdateWithoutGameInput>
  }

  export type UserQuestsUpdateManyWithWhereWithoutGameInput = {
    where: UserQuestsScalarWhereInput
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyWithoutGameInput>
  }

  export type LogsUpsertWithWhereUniqueWithoutGameInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutGameInput, LogsUncheckedUpdateWithoutGameInput>
    create: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutGameInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutGameInput, LogsUncheckedUpdateWithoutGameInput>
  }

  export type LogsUpdateManyWithWhereWithoutGameInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutGameInput>
  }

  export type AddressBookUpsertWithWhereUniqueWithoutGameInput = {
    where: AddressBookWhereUniqueInput
    update: XOR<AddressBookUpdateWithoutGameInput, AddressBookUncheckedUpdateWithoutGameInput>
    create: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput>
  }

  export type AddressBookUpdateWithWhereUniqueWithoutGameInput = {
    where: AddressBookWhereUniqueInput
    data: XOR<AddressBookUpdateWithoutGameInput, AddressBookUncheckedUpdateWithoutGameInput>
  }

  export type AddressBookUpdateManyWithWhereWithoutGameInput = {
    where: AddressBookScalarWhereInput
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyWithoutGameInput>
  }

  export type AccountBookUpsertWithWhereUniqueWithoutGameInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutGameInput, AccountBookUncheckedUpdateWithoutGameInput>
    create: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutGameInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutGameInput, AccountBookUncheckedUpdateWithoutGameInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutGameInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutGameInput>
  }

  export type DNSUpsertWithWhereUniqueWithoutGameInput = {
    where: DNSWhereUniqueInput
    update: XOR<DNSUpdateWithoutGameInput, DNSUncheckedUpdateWithoutGameInput>
    create: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput>
  }

  export type DNSUpdateWithWhereUniqueWithoutGameInput = {
    where: DNSWhereUniqueInput
    data: XOR<DNSUpdateWithoutGameInput, DNSUncheckedUpdateWithoutGameInput>
  }

  export type DNSUpdateManyWithWhereWithoutGameInput = {
    where: DNSScalarWhereInput
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyWithoutGameInput>
  }

  export type ProfileUpsertWithWhereUniqueWithoutGameInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutGameInput, ProfileUncheckedUpdateWithoutGameInput>
    create: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutGameInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutGameInput, ProfileUncheckedUpdateWithoutGameInput>
  }

  export type ProfileUpdateManyWithWhereWithoutGameInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutGameInput>
  }

  export type UserCreateWithoutSessionInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
  }

  export type UserUpdateWithoutSessionInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComputerCreateWithoutHardwareInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutHardwareInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutHardwareInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
  }

  export type GameCreateWithoutHardwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutHardwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutHardwareInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
  }

  export type ComputerUpsertWithoutHardwareInput = {
    update: XOR<ComputerUpdateWithoutHardwareInput, ComputerUncheckedUpdateWithoutHardwareInput>
    create: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutHardwareInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutHardwareInput, ComputerUncheckedUpdateWithoutHardwareInput>
  }

  export type ComputerUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutHardwareInput = {
    update: XOR<GameUpdateWithoutHardwareInput, GameUncheckedUpdateWithoutHardwareInput>
    create: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutHardwareInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutHardwareInput, GameUncheckedUpdateWithoutHardwareInput>
  }

  export type GameUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutAddressBookInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressBookInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
  }

  export type ComputerCreateWithoutAddressBookInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutAddressBookInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutAddressBookInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
  }

  export type GameCreateWithoutAddressBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutAddressBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAddressBookInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
  }

  export type UserUpsertWithoutAddressBookInput = {
    update: XOR<UserUpdateWithoutAddressBookInput, UserUncheckedUpdateWithoutAddressBookInput>
    create: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressBookInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressBookInput, UserUncheckedUpdateWithoutAddressBookInput>
  }

  export type UserUpdateWithoutAddressBookInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComputerUpsertWithoutAddressBookInput = {
    update: XOR<ComputerUpdateWithoutAddressBookInput, ComputerUncheckedUpdateWithoutAddressBookInput>
    create: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutAddressBookInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutAddressBookInput, ComputerUncheckedUpdateWithoutAddressBookInput>
  }

  export type ComputerUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutAddressBookInput = {
    update: XOR<GameUpdateWithoutAddressBookInput, GameUncheckedUpdateWithoutAddressBookInput>
    create: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutAddressBookInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutAddressBookInput, GameUncheckedUpdateWithoutAddressBookInput>
  }

  export type GameUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutDnsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDnsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDnsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
  }

  export type ComputerCreateWithoutDnsInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutDnsInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutDnsInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
  }

  export type GameCreateWithoutDnsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutDnsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutDnsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
  }

  export type UserUpsertWithoutDnsInput = {
    update: XOR<UserUpdateWithoutDnsInput, UserUncheckedUpdateWithoutDnsInput>
    create: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDnsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDnsInput, UserUncheckedUpdateWithoutDnsInput>
  }

  export type UserUpdateWithoutDnsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComputerUpsertWithoutDnsInput = {
    update: XOR<ComputerUpdateWithoutDnsInput, ComputerUncheckedUpdateWithoutDnsInput>
    create: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutDnsInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutDnsInput, ComputerUncheckedUpdateWithoutDnsInput>
  }

  export type ComputerUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutDnsInput = {
    update: XOR<GameUpdateWithoutDnsInput, GameUncheckedUpdateWithoutDnsInput>
    create: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutDnsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutDnsInput, GameUncheckedUpdateWithoutDnsInput>
  }

  export type GameUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutAccountBookInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountBookInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
  }

  export type ComputerCreateWithoutAccountBookInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutAccountBookInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutAccountBookInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
  }

  export type MemoryCreateWithoutAccountBookInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutMemoryInput
    game: GameCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutAccountBookInput = {
    id?: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryCreateOrConnectWithoutAccountBookInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
  }

  export type GameCreateWithoutAccountBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutAccountBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAccountBookInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
  }

  export type UserUpsertWithoutAccountBookInput = {
    update: XOR<UserUpdateWithoutAccountBookInput, UserUncheckedUpdateWithoutAccountBookInput>
    create: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountBookInput, UserUncheckedUpdateWithoutAccountBookInput>
  }

  export type UserUpdateWithoutAccountBookInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComputerUpsertWithoutAccountBookInput = {
    update: XOR<ComputerUpdateWithoutAccountBookInput, ComputerUncheckedUpdateWithoutAccountBookInput>
    create: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutAccountBookInput, ComputerUncheckedUpdateWithoutAccountBookInput>
  }

  export type ComputerUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type MemoryUpsertWithoutAccountBookInput = {
    update: XOR<MemoryUpdateWithoutAccountBookInput, MemoryUncheckedUpdateWithoutAccountBookInput>
    create: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
    where?: MemoryWhereInput
  }

  export type MemoryUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: MemoryWhereInput
    data: XOR<MemoryUpdateWithoutAccountBookInput, MemoryUncheckedUpdateWithoutAccountBookInput>
  }

  export type MemoryUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type GameUpsertWithoutAccountBookInput = {
    update: XOR<GameUpdateWithoutAccountBookInput, GameUncheckedUpdateWithoutAccountBookInput>
    create: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutAccountBookInput, GameUncheckedUpdateWithoutAccountBookInput>
  }

  export type GameUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type GameCreateWithoutProfileInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutProfileInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithoutProfileInput = {
    update: XOR<GameUpdateWithoutProfileInput, GameUncheckedUpdateWithoutProfileInput>
    create: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutProfileInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutProfileInput, GameUncheckedUpdateWithoutProfileInput>
  }

  export type GameUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
  }

  export type ComputerCreateWithoutMemoryInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutMemoryInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutMemoryInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
  }

  export type GameCreateWithoutMemoryInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutMemoryInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutMemoryInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
  }

  export type UserCreateWithoutMemoryInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMemoryInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMemoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
  }

  export type AccountBookCreateWithoutMemoryInput = {
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAccountBookInput
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    game: GameCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutMemoryInput = {
    id?: number
    userId: number
    computerId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateOrConnectWithoutMemoryInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput>
  }

  export type AccountBookCreateManyMemoryInputEnvelope = {
    data: AccountBookCreateManyMemoryInput | AccountBookCreateManyMemoryInput[]
    skipDuplicates?: boolean
  }

  export type ComputerUpsertWithoutMemoryInput = {
    update: XOR<ComputerUpdateWithoutMemoryInput, ComputerUncheckedUpdateWithoutMemoryInput>
    create: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutMemoryInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutMemoryInput, ComputerUncheckedUpdateWithoutMemoryInput>
  }

  export type ComputerUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutMemoryInput = {
    update: XOR<GameUpdateWithoutMemoryInput, GameUncheckedUpdateWithoutMemoryInput>
    create: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutMemoryInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutMemoryInput, GameUncheckedUpdateWithoutMemoryInput>
  }

  export type GameUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutMemoryInput = {
    update: XOR<UserUpdateWithoutMemoryInput, UserUncheckedUpdateWithoutMemoryInput>
    create: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemoryInput, UserUncheckedUpdateWithoutMemoryInput>
  }

  export type UserUpdateWithoutMemoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMemoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountBookUpsertWithWhereUniqueWithoutMemoryInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutMemoryInput, AccountBookUncheckedUpdateWithoutMemoryInput>
    create: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutMemoryInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutMemoryInput, AccountBookUncheckedUpdateWithoutMemoryInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutMemoryInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutMemoryInput>
  }

  export type UserCreateWithoutComputerInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComputerInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComputerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
  }

  export type GameCreateWithoutComputerInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutComputerInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutComputerInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
  }

  export type DNSCreateWithoutComputerInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    user: UserCreateNestedOneWithoutDnsInput
    game: GameCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSCreateOrConnectWithoutComputerInput = {
    where: DNSWhereUniqueInput
    create: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput>
  }

  export type DNSCreateManyComputerInputEnvelope = {
    data: DNSCreateManyComputerInput | DNSCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type HardwareCreateWithoutComputerInput = {
    type: $Enums.HardwareTypes
    strength: number
    game: GameCreateNestedOneWithoutHardwareInput
  }

  export type HardwareUncheckedCreateWithoutComputerInput = {
    id?: number
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareCreateOrConnectWithoutComputerInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput>
  }

  export type HardwareCreateManyComputerInputEnvelope = {
    data: HardwareCreateManyComputerInput | HardwareCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareCreateWithoutComputerInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutSoftwareInput
    game: GameCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateWithoutComputerInput = {
    id?: string
    userId: number
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateOrConnectWithoutComputerInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput>
  }

  export type SoftwareCreateManyComputerInputEnvelope = {
    data: SoftwareCreateManyComputerInput | SoftwareCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type MemoryCreateWithoutComputerInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutComputerInput = {
    id?: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryCreateOrConnectWithoutComputerInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput>
  }

  export type MemoryCreateManyComputerInputEnvelope = {
    data: MemoryCreateManyComputerInput | MemoryCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCreateWithoutComputerInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProcessInput
    game: GameCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutComputerInput = {
    id?: string
    userId: number
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateOrConnectWithoutComputerInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput>
  }

  export type ProcessCreateManyComputerInputEnvelope = {
    data: ProcessCreateManyComputerInput | ProcessCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type AddressBookCreateWithoutComputerInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAddressBookInput
    game: GameCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookCreateOrConnectWithoutComputerInput = {
    where: AddressBookWhereUniqueInput
    create: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput>
  }

  export type AddressBookCreateManyComputerInputEnvelope = {
    data: AddressBookCreateManyComputerInput | AddressBookCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type AccountBookCreateWithoutComputerInput = {
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
    game: GameCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateOrConnectWithoutComputerInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput>
  }

  export type AccountBookCreateManyComputerInputEnvelope = {
    data: AccountBookCreateManyComputerInput | AccountBookCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type LogsCreateWithoutComputerInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    user: UserCreateNestedOneWithoutLogsInput
    game: GameCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsCreateOrConnectWithoutComputerInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput>
  }

  export type LogsCreateManyComputerInputEnvelope = {
    data: LogsCreateManyComputerInput | LogsCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutComputerInput = {
    update: XOR<UserUpdateWithoutComputerInput, UserUncheckedUpdateWithoutComputerInput>
    create: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComputerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComputerInput, UserUncheckedUpdateWithoutComputerInput>
  }

  export type UserUpdateWithoutComputerInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithoutComputerInput = {
    update: XOR<GameUpdateWithoutComputerInput, GameUncheckedUpdateWithoutComputerInput>
    create: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutComputerInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutComputerInput, GameUncheckedUpdateWithoutComputerInput>
  }

  export type GameUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type DNSUpsertWithWhereUniqueWithoutComputerInput = {
    where: DNSWhereUniqueInput
    update: XOR<DNSUpdateWithoutComputerInput, DNSUncheckedUpdateWithoutComputerInput>
    create: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput>
  }

  export type DNSUpdateWithWhereUniqueWithoutComputerInput = {
    where: DNSWhereUniqueInput
    data: XOR<DNSUpdateWithoutComputerInput, DNSUncheckedUpdateWithoutComputerInput>
  }

  export type DNSUpdateManyWithWhereWithoutComputerInput = {
    where: DNSScalarWhereInput
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyWithoutComputerInput>
  }

  export type HardwareUpsertWithWhereUniqueWithoutComputerInput = {
    where: HardwareWhereUniqueInput
    update: XOR<HardwareUpdateWithoutComputerInput, HardwareUncheckedUpdateWithoutComputerInput>
    create: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput>
  }

  export type HardwareUpdateWithWhereUniqueWithoutComputerInput = {
    where: HardwareWhereUniqueInput
    data: XOR<HardwareUpdateWithoutComputerInput, HardwareUncheckedUpdateWithoutComputerInput>
  }

  export type HardwareUpdateManyWithWhereWithoutComputerInput = {
    where: HardwareScalarWhereInput
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyWithoutComputerInput>
  }

  export type SoftwareUpsertWithWhereUniqueWithoutComputerInput = {
    where: SoftwareWhereUniqueInput
    update: XOR<SoftwareUpdateWithoutComputerInput, SoftwareUncheckedUpdateWithoutComputerInput>
    create: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput>
  }

  export type SoftwareUpdateWithWhereUniqueWithoutComputerInput = {
    where: SoftwareWhereUniqueInput
    data: XOR<SoftwareUpdateWithoutComputerInput, SoftwareUncheckedUpdateWithoutComputerInput>
  }

  export type SoftwareUpdateManyWithWhereWithoutComputerInput = {
    where: SoftwareScalarWhereInput
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyWithoutComputerInput>
  }

  export type MemoryUpsertWithWhereUniqueWithoutComputerInput = {
    where: MemoryWhereUniqueInput
    update: XOR<MemoryUpdateWithoutComputerInput, MemoryUncheckedUpdateWithoutComputerInput>
    create: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput>
  }

  export type MemoryUpdateWithWhereUniqueWithoutComputerInput = {
    where: MemoryWhereUniqueInput
    data: XOR<MemoryUpdateWithoutComputerInput, MemoryUncheckedUpdateWithoutComputerInput>
  }

  export type MemoryUpdateManyWithWhereWithoutComputerInput = {
    where: MemoryScalarWhereInput
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyWithoutComputerInput>
  }

  export type ProcessUpsertWithWhereUniqueWithoutComputerInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutComputerInput, ProcessUncheckedUpdateWithoutComputerInput>
    create: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutComputerInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutComputerInput, ProcessUncheckedUpdateWithoutComputerInput>
  }

  export type ProcessUpdateManyWithWhereWithoutComputerInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutComputerInput>
  }

  export type AddressBookUpsertWithWhereUniqueWithoutComputerInput = {
    where: AddressBookWhereUniqueInput
    update: XOR<AddressBookUpdateWithoutComputerInput, AddressBookUncheckedUpdateWithoutComputerInput>
    create: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput>
  }

  export type AddressBookUpdateWithWhereUniqueWithoutComputerInput = {
    where: AddressBookWhereUniqueInput
    data: XOR<AddressBookUpdateWithoutComputerInput, AddressBookUncheckedUpdateWithoutComputerInput>
  }

  export type AddressBookUpdateManyWithWhereWithoutComputerInput = {
    where: AddressBookScalarWhereInput
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyWithoutComputerInput>
  }

  export type AccountBookUpsertWithWhereUniqueWithoutComputerInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutComputerInput, AccountBookUncheckedUpdateWithoutComputerInput>
    create: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutComputerInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutComputerInput, AccountBookUncheckedUpdateWithoutComputerInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutComputerInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutComputerInput>
  }

  export type LogsUpsertWithWhereUniqueWithoutComputerInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutComputerInput, LogsUncheckedUpdateWithoutComputerInput>
    create: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutComputerInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutComputerInput, LogsUncheckedUpdateWithoutComputerInput>
  }

  export type LogsUpdateManyWithWhereWithoutComputerInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutComputerInput>
  }

  export type GameCreateWithoutQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutQuestsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
  }

  export type UserQuestsCreateWithoutQuestInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutUserQuestsInput
    game: GameCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateWithoutQuestInput = {
    id?: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsCreateOrConnectWithoutQuestInput = {
    where: UserQuestsWhereUniqueInput
    create: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput>
  }

  export type UserQuestsCreateManyQuestInputEnvelope = {
    data: UserQuestsCreateManyQuestInput | UserQuestsCreateManyQuestInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithoutQuestsInput = {
    update: XOR<GameUpdateWithoutQuestsInput, GameUncheckedUpdateWithoutQuestsInput>
    create: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutQuestsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutQuestsInput, GameUncheckedUpdateWithoutQuestsInput>
  }

  export type GameUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserQuestsUpsertWithWhereUniqueWithoutQuestInput = {
    where: UserQuestsWhereUniqueInput
    update: XOR<UserQuestsUpdateWithoutQuestInput, UserQuestsUncheckedUpdateWithoutQuestInput>
    create: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput>
  }

  export type UserQuestsUpdateWithWhereUniqueWithoutQuestInput = {
    where: UserQuestsWhereUniqueInput
    data: XOR<UserQuestsUpdateWithoutQuestInput, UserQuestsUncheckedUpdateWithoutQuestInput>
  }

  export type UserQuestsUpdateManyWithWhereWithoutQuestInput = {
    where: UserQuestsScalarWhereInput
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyWithoutQuestInput>
  }

  export type QuestsCreateWithoutUserQuestsInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    game: GameCreateNestedOneWithoutQuestsInput
  }

  export type QuestsUncheckedCreateWithoutUserQuestsInput = {
    id?: string
    gameId: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
  }

  export type QuestsCreateOrConnectWithoutUserQuestsInput = {
    where: QuestsWhereUniqueInput
    create: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
  }

  export type UserCreateWithoutUserQuestsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserQuestsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserQuestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
  }

  export type GameCreateWithoutUserQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutUserQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutUserQuestsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
  }

  export type QuestsUpsertWithoutUserQuestsInput = {
    update: XOR<QuestsUpdateWithoutUserQuestsInput, QuestsUncheckedUpdateWithoutUserQuestsInput>
    create: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
    where?: QuestsWhereInput
  }

  export type QuestsUpdateToOneWithWhereWithoutUserQuestsInput = {
    where?: QuestsWhereInput
    data: XOR<QuestsUpdateWithoutUserQuestsInput, QuestsUncheckedUpdateWithoutUserQuestsInput>
  }

  export type QuestsUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    game?: GameUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type QuestsUncheckedUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutUserQuestsInput = {
    update: XOR<UserUpdateWithoutUserQuestsInput, UserUncheckedUpdateWithoutUserQuestsInput>
    create: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserQuestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserQuestsInput, UserUncheckedUpdateWithoutUserQuestsInput>
  }

  export type UserUpdateWithoutUserQuestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithoutUserQuestsInput = {
    update: XOR<GameUpdateWithoutUserQuestsInput, GameUncheckedUpdateWithoutUserQuestsInput>
    create: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutUserQuestsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutUserQuestsInput, GameUncheckedUpdateWithoutUserQuestsInput>
  }

  export type GameUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutSoftwareInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSoftwareInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSoftwareInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
  }

  export type ComputerCreateWithoutSoftwareInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutSoftwareInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutSoftwareInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
  }

  export type GameCreateWithoutSoftwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSoftwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSoftwareInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
  }

  export type UserUpsertWithoutSoftwareInput = {
    update: XOR<UserUpdateWithoutSoftwareInput, UserUncheckedUpdateWithoutSoftwareInput>
    create: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSoftwareInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSoftwareInput, UserUncheckedUpdateWithoutSoftwareInput>
  }

  export type UserUpdateWithoutSoftwareInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSoftwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComputerUpsertWithoutSoftwareInput = {
    update: XOR<ComputerUpdateWithoutSoftwareInput, ComputerUncheckedUpdateWithoutSoftwareInput>
    create: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutSoftwareInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutSoftwareInput, ComputerUncheckedUpdateWithoutSoftwareInput>
  }

  export type ComputerUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutSoftwareInput = {
    update: XOR<GameUpdateWithoutSoftwareInput, GameUncheckedUpdateWithoutSoftwareInput>
    create: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutSoftwareInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutSoftwareInput, GameUncheckedUpdateWithoutSoftwareInput>
  }

  export type GameUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutProcessInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
  }

  export type ComputerCreateWithoutProcessInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutProcessInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutProcessInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
  }

  export type GameCreateWithoutProcessInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutProcessInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutProcessInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
  }

  export type UserUpsertWithoutProcessInput = {
    update: XOR<UserUpdateWithoutProcessInput, UserUncheckedUpdateWithoutProcessInput>
    create: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessInput, UserUncheckedUpdateWithoutProcessInput>
  }

  export type UserUpdateWithoutProcessInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComputerUpsertWithoutProcessInput = {
    update: XOR<ComputerUpdateWithoutProcessInput, ComputerUncheckedUpdateWithoutProcessInput>
    create: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutProcessInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutProcessInput, ComputerUncheckedUpdateWithoutProcessInput>
  }

  export type ComputerUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutProcessInput = {
    update: XOR<GameUpdateWithoutProcessInput, GameUncheckedUpdateWithoutProcessInput>
    create: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutProcessInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutProcessInput, GameUncheckedUpdateWithoutProcessInput>
  }

  export type GameUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type ComputerCreateWithoutLogsInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    user: UserCreateNestedOneWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutLogsInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutLogsInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
  }

  export type GameCreateWithoutLogsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutLogsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComputerUpsertWithoutLogsInput = {
    update: XOR<ComputerUpdateWithoutLogsInput, ComputerUncheckedUpdateWithoutLogsInput>
    create: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutLogsInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutLogsInput, ComputerUncheckedUpdateWithoutLogsInput>
  }

  export type ComputerUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutLogsInput = {
    update: XOR<GameUpdateWithoutLogsInput, GameUncheckedUpdateWithoutLogsInput>
    create: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutLogsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutLogsInput, GameUncheckedUpdateWithoutLogsInput>
  }

  export type GameUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type ComputerCreateManyUserInput = {
    id?: string
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
  }

  export type SoftwareCreateManyUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryCreateManyUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateManyUserInput = {
    id?: string
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type UserQuestsCreateManyUserInput = {
    id?: string
    questsId: string
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type AddressBookCreateManyUserInput = {
    id?: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateManyUserInput = {
    id?: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type LogsCreateManyUserInput = {
    id?: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type DNSCreateManyUserInput = {
    id?: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type ProfileCreateManyUserInput = {
    id?: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationsCreateManyUserInput = {
    id?: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComputerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoftwareUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutSoftwareNestedInput
    game?: GameUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutProcessNestedInput
    game?: GameUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UserQuestsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    quest?: QuestsUpdateOneRequiredWithoutUserQuestsNestedInput
    game?: GameUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressBookUpdateWithoutUserInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAddressBookNestedInput
    game?: GameUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUpdateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type LogsUpdateWithoutUserInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutLogsNestedInput
    game?: GameUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUpdateWithoutUserInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutDnsNestedInput
    game?: GameUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpdateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationsUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SoftwareCreateManyGameInput = {
    id?: string
    userId: number
    computerId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type HardwareCreateManyGameInput = {
    id?: number
    computerId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type ComputerCreateManyGameInput = {
    id?: string
    userId: number
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
  }

  export type MemoryCreateManyGameInput = {
    id?: string
    computerId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateManyGameInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type QuestsCreateManyGameInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
  }

  export type UserQuestsCreateManyGameInput = {
    id?: string
    questsId: string
    userId: number
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type LogsCreateManyGameInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
  }

  export type AddressBookCreateManyGameInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookCreateManyGameInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type DNSCreateManyGameInput = {
    id?: number
    userId: number
    computerId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type ProfileCreateManyGameInput = {
    id?: number
    userId: number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutSoftwareNestedInput
    computer?: ComputerUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type HardwareUpdateWithoutGameInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
    computer?: ComputerUpdateOneRequiredWithoutHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type ComputerUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProcessNestedInput
    computer?: ComputerUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type QuestsUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    userQuests?: UserQuestsUpdateManyWithoutQuestNestedInput
  }

  export type QuestsUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    userQuests?: UserQuestsUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestsUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserQuestsUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    quest?: QuestsUpdateOneRequiredWithoutUserQuestsNestedInput
    user?: UserUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUpdateWithoutGameInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
    computer?: ComputerUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressBookUpdateWithoutGameInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAddressBookNestedInput
    computer?: ComputerUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookUpdateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type DNSUpdateWithoutGameInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDnsNestedInput
    computer?: ComputerUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpdateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookCreateManyMemoryInput = {
    id?: number
    userId: number
    computerId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookUpdateWithoutMemoryInput = {
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutMemoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUncheckedUpdateManyWithoutMemoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type DNSCreateManyComputerInput = {
    id?: number
    userId: number
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type HardwareCreateManyComputerInput = {
    id?: number
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type SoftwareCreateManyComputerInput = {
    id?: string
    userId: number
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryCreateManyComputerInput = {
    id?: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateManyComputerInput = {
    id?: string
    userId: number
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookCreateManyComputerInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateManyComputerInput = {
    id?: number
    userId: number
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type LogsCreateManyComputerInput = {
    id?: number
    userId: number
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type DNSUpdateWithoutComputerInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDnsNestedInput
    game?: GameUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HardwareUpdateWithoutComputerInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type SoftwareUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutSoftwareNestedInput
    game?: GameUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateManyWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProcessNestedInput
    game?: GameUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookUpdateWithoutComputerInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAddressBookNestedInput
    game?: GameUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUpdateWithoutComputerInput = {
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type LogsUpdateWithoutComputerInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
    game?: GameUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsCreateManyQuestInput = {
    id?: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsUpdateWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserQuestsNestedInput
    game?: GameUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameCountOutputTypeDefaultArgs instead
     */
    export type GameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemoryCountOutputTypeDefaultArgs instead
     */
    export type MemoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComputerCountOutputTypeDefaultArgs instead
     */
    export type ComputerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComputerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestsCountOutputTypeDefaultArgs instead
     */
    export type QuestsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameDefaultArgs instead
     */
    export type GameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HardwareDefaultArgs instead
     */
    export type HardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HardwareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressBookDefaultArgs instead
     */
    export type AddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DNSDefaultArgs instead
     */
    export type DNSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DNSDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountBookDefaultArgs instead
     */
    export type AccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemoryDefaultArgs instead
     */
    export type MemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComputerDefaultArgs instead
     */
    export type ComputerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComputerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestsDefaultArgs instead
     */
    export type QuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserQuestsDefaultArgs instead
     */
    export type UserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserQuestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftwareDefaultArgs instead
     */
    export type SoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftwareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessDefaultArgs instead
     */
    export type ProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationsDefaultArgs instead
     */
    export type NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogsDefaultArgs instead
     */
    export type LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}