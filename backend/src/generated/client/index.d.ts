
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Hardware
 * 
 */
export type Hardware = $Result.DefaultSelection<Prisma.$HardwarePayload>
/**
 * Model AddressBook
 * 
 */
export type AddressBook = $Result.DefaultSelection<Prisma.$AddressBookPayload>
/**
 * Model DNS
 * 
 */
export type DNS = $Result.DefaultSelection<Prisma.$DNSPayload>
/**
 * Model AccountBook
 * 
 */
export type AccountBook = $Result.DefaultSelection<Prisma.$AccountBookPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Memory
 * 
 */
export type Memory = $Result.DefaultSelection<Prisma.$MemoryPayload>
/**
 * Model Computer
 * 
 */
export type Computer = $Result.DefaultSelection<Prisma.$ComputerPayload>
/**
 * Model Quests
 * 
 */
export type Quests = $Result.DefaultSelection<Prisma.$QuestsPayload>
/**
 * Model UserQuests
 * 
 */
export type UserQuests = $Result.DefaultSelection<Prisma.$UserQuestsPayload>
/**
 * Model Software
 * 
 */
export type Software = $Result.DefaultSelection<Prisma.$SoftwarePayload>
/**
 * Model Process
 * 
 */
export type Process = $Result.DefaultSelection<Prisma.$ProcessPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model Logs
 * 
 */
export type Logs = $Result.DefaultSelection<Prisma.$LogsPayload>
/**
 * Model Trade
 * 
 */
export type Trade = $Result.DefaultSelection<Prisma.$TradePayload>
/**
 * Model Fund
 * 
 */
export type Fund = $Result.DefaultSelection<Prisma.$FundPayload>
/**
 * Model Portfolio
 * 
 */
export type Portfolio = $Result.DefaultSelection<Prisma.$PortfolioPayload>
/**
 * Model PortfolioHolding
 * 
 */
export type PortfolioHolding = $Result.DefaultSelection<Prisma.$PortfolioHoldingPayload>
/**
 * Model HedgeFund
 * 
 */
export type HedgeFund = $Result.DefaultSelection<Prisma.$HedgeFundPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Groups: {
  User: 'User',
  Guest: 'Guest',
  Admin: 'Admin'
};

export type Groups = (typeof Groups)[keyof typeof Groups]


export const HardwareTypes: {
  CPU: 'CPU',
  GPU: 'GPU',
  RAM: 'RAM',
  HDD: 'HDD',
  Upload: 'Upload',
  Download: 'Download'
};

export type HardwareTypes = (typeof HardwareTypes)[keyof typeof HardwareTypes]


export const AccessLevel: {
  GOD: 'GOD',
  FTP: 'FTP'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const InstructionNamedType: {
  BUY: 'BUY',
  SELL: 'SELL',
  REBALANCE: 'REBALANCE',
  WITHDRAW: 'WITHDRAW',
  DEPOSIT: 'DEPOSIT'
};

export type InstructionNamedType = (typeof InstructionNamedType)[keyof typeof InstructionNamedType]

}

export type Groups = $Enums.Groups

export const Groups: typeof $Enums.Groups

export type HardwareTypes = $Enums.HardwareTypes

export const HardwareTypes: typeof $Enums.HardwareTypes

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

export type InstructionNamedType = $Enums.InstructionNamedType

export const InstructionNamedType: typeof $Enums.InstructionNamedType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.hardware`: Exposes CRUD operations for the **Hardware** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hardware
    * const hardware = await prisma.hardware.findMany()
    * ```
    */
  get hardware(): Prisma.HardwareDelegate<ExtArgs>;

  /**
   * `prisma.addressBook`: Exposes CRUD operations for the **AddressBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddressBooks
    * const addressBooks = await prisma.addressBook.findMany()
    * ```
    */
  get addressBook(): Prisma.AddressBookDelegate<ExtArgs>;

  /**
   * `prisma.dNS`: Exposes CRUD operations for the **DNS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DNS
    * const dNS = await prisma.dNS.findMany()
    * ```
    */
  get dNS(): Prisma.DNSDelegate<ExtArgs>;

  /**
   * `prisma.accountBook`: Exposes CRUD operations for the **AccountBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountBooks
    * const accountBooks = await prisma.accountBook.findMany()
    * ```
    */
  get accountBook(): Prisma.AccountBookDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.memory`: Exposes CRUD operations for the **Memory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memories
    * const memories = await prisma.memory.findMany()
    * ```
    */
  get memory(): Prisma.MemoryDelegate<ExtArgs>;

  /**
   * `prisma.computer`: Exposes CRUD operations for the **Computer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Computers
    * const computers = await prisma.computer.findMany()
    * ```
    */
  get computer(): Prisma.ComputerDelegate<ExtArgs>;

  /**
   * `prisma.quests`: Exposes CRUD operations for the **Quests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quests.findMany()
    * ```
    */
  get quests(): Prisma.QuestsDelegate<ExtArgs>;

  /**
   * `prisma.userQuests`: Exposes CRUD operations for the **UserQuests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuests
    * const userQuests = await prisma.userQuests.findMany()
    * ```
    */
  get userQuests(): Prisma.UserQuestsDelegate<ExtArgs>;

  /**
   * `prisma.software`: Exposes CRUD operations for the **Software** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Software
    * const software = await prisma.software.findMany()
    * ```
    */
  get software(): Prisma.SoftwareDelegate<ExtArgs>;

  /**
   * `prisma.process`: Exposes CRUD operations for the **Process** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processes
    * const processes = await prisma.process.findMany()
    * ```
    */
  get process(): Prisma.ProcessDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.LogsDelegate<ExtArgs>;

  /**
   * `prisma.trade`: Exposes CRUD operations for the **Trade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trades
    * const trades = await prisma.trade.findMany()
    * ```
    */
  get trade(): Prisma.TradeDelegate<ExtArgs>;

  /**
   * `prisma.fund`: Exposes CRUD operations for the **Fund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funds
    * const funds = await prisma.fund.findMany()
    * ```
    */
  get fund(): Prisma.FundDelegate<ExtArgs>;

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **Portfolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portfolios
    * const portfolios = await prisma.portfolio.findMany()
    * ```
    */
  get portfolio(): Prisma.PortfolioDelegate<ExtArgs>;

  /**
   * `prisma.portfolioHolding`: Exposes CRUD operations for the **PortfolioHolding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioHoldings
    * const portfolioHoldings = await prisma.portfolioHolding.findMany()
    * ```
    */
  get portfolioHolding(): Prisma.PortfolioHoldingDelegate<ExtArgs>;

  /**
   * `prisma.hedgeFund`: Exposes CRUD operations for the **HedgeFund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HedgeFunds
    * const hedgeFunds = await prisma.hedgeFund.findMany()
    * ```
    */
  get hedgeFund(): Prisma.HedgeFundDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Game: 'Game',
    Session: 'Session',
    Hardware: 'Hardware',
    AddressBook: 'AddressBook',
    DNS: 'DNS',
    AccountBook: 'AccountBook',
    Profile: 'Profile',
    Memory: 'Memory',
    Computer: 'Computer',
    Quests: 'Quests',
    UserQuests: 'UserQuests',
    Software: 'Software',
    Process: 'Process',
    Notifications: 'Notifications',
    Logs: 'Logs',
    Trade: 'Trade',
    Fund: 'Fund',
    Portfolio: 'Portfolio',
    PortfolioHolding: 'PortfolioHolding',
    HedgeFund: 'HedgeFund'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "game" | "session" | "hardware" | "addressBook" | "dNS" | "accountBook" | "profile" | "memory" | "computer" | "quests" | "userQuests" | "software" | "process" | "notifications" | "logs" | "trade" | "fund" | "portfolio" | "portfolioHolding" | "hedgeFund"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Hardware: {
        payload: Prisma.$HardwarePayload<ExtArgs>
        fields: Prisma.HardwareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HardwareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HardwareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          findFirst: {
            args: Prisma.HardwareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HardwareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          findMany: {
            args: Prisma.HardwareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>[]
          }
          create: {
            args: Prisma.HardwareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          createMany: {
            args: Prisma.HardwareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HardwareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>[]
          }
          delete: {
            args: Prisma.HardwareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          update: {
            args: Prisma.HardwareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          deleteMany: {
            args: Prisma.HardwareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HardwareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HardwareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HardwarePayload>
          }
          aggregate: {
            args: Prisma.HardwareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHardware>
          }
          groupBy: {
            args: Prisma.HardwareGroupByArgs<ExtArgs>
            result: $Utils.Optional<HardwareGroupByOutputType>[]
          }
          count: {
            args: Prisma.HardwareCountArgs<ExtArgs>
            result: $Utils.Optional<HardwareCountAggregateOutputType> | number
          }
        }
      }
      AddressBook: {
        payload: Prisma.$AddressBookPayload<ExtArgs>
        fields: Prisma.AddressBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          findFirst: {
            args: Prisma.AddressBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          findMany: {
            args: Prisma.AddressBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>[]
          }
          create: {
            args: Prisma.AddressBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          createMany: {
            args: Prisma.AddressBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressBookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>[]
          }
          delete: {
            args: Prisma.AddressBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          update: {
            args: Prisma.AddressBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          deleteMany: {
            args: Prisma.AddressBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddressBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressBookPayload>
          }
          aggregate: {
            args: Prisma.AddressBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddressBook>
          }
          groupBy: {
            args: Prisma.AddressBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressBookCountArgs<ExtArgs>
            result: $Utils.Optional<AddressBookCountAggregateOutputType> | number
          }
        }
      }
      DNS: {
        payload: Prisma.$DNSPayload<ExtArgs>
        fields: Prisma.DNSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DNSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DNSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          findFirst: {
            args: Prisma.DNSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DNSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          findMany: {
            args: Prisma.DNSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>[]
          }
          create: {
            args: Prisma.DNSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          createMany: {
            args: Prisma.DNSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DNSCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>[]
          }
          delete: {
            args: Prisma.DNSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          update: {
            args: Prisma.DNSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          deleteMany: {
            args: Prisma.DNSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DNSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DNSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DNSPayload>
          }
          aggregate: {
            args: Prisma.DNSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDNS>
          }
          groupBy: {
            args: Prisma.DNSGroupByArgs<ExtArgs>
            result: $Utils.Optional<DNSGroupByOutputType>[]
          }
          count: {
            args: Prisma.DNSCountArgs<ExtArgs>
            result: $Utils.Optional<DNSCountAggregateOutputType> | number
          }
        }
      }
      AccountBook: {
        payload: Prisma.$AccountBookPayload<ExtArgs>
        fields: Prisma.AccountBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          findFirst: {
            args: Prisma.AccountBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          findMany: {
            args: Prisma.AccountBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>[]
          }
          create: {
            args: Prisma.AccountBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          createMany: {
            args: Prisma.AccountBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountBookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>[]
          }
          delete: {
            args: Prisma.AccountBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          update: {
            args: Prisma.AccountBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          deleteMany: {
            args: Prisma.AccountBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBookPayload>
          }
          aggregate: {
            args: Prisma.AccountBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountBook>
          }
          groupBy: {
            args: Prisma.AccountBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountBookCountArgs<ExtArgs>
            result: $Utils.Optional<AccountBookCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Memory: {
        payload: Prisma.$MemoryPayload<ExtArgs>
        fields: Prisma.MemoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          findFirst: {
            args: Prisma.MemoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          findMany: {
            args: Prisma.MemoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>[]
          }
          create: {
            args: Prisma.MemoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          createMany: {
            args: Prisma.MemoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>[]
          }
          delete: {
            args: Prisma.MemoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          update: {
            args: Prisma.MemoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          deleteMany: {
            args: Prisma.MemoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MemoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemoryPayload>
          }
          aggregate: {
            args: Prisma.MemoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemory>
          }
          groupBy: {
            args: Prisma.MemoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemoryCountArgs<ExtArgs>
            result: $Utils.Optional<MemoryCountAggregateOutputType> | number
          }
        }
      }
      Computer: {
        payload: Prisma.$ComputerPayload<ExtArgs>
        fields: Prisma.ComputerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComputerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComputerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          findFirst: {
            args: Prisma.ComputerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComputerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          findMany: {
            args: Prisma.ComputerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>[]
          }
          create: {
            args: Prisma.ComputerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          createMany: {
            args: Prisma.ComputerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComputerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>[]
          }
          delete: {
            args: Prisma.ComputerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          update: {
            args: Prisma.ComputerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          deleteMany: {
            args: Prisma.ComputerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComputerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComputerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComputerPayload>
          }
          aggregate: {
            args: Prisma.ComputerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComputer>
          }
          groupBy: {
            args: Prisma.ComputerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComputerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComputerCountArgs<ExtArgs>
            result: $Utils.Optional<ComputerCountAggregateOutputType> | number
          }
        }
      }
      Quests: {
        payload: Prisma.$QuestsPayload<ExtArgs>
        fields: Prisma.QuestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          findFirst: {
            args: Prisma.QuestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          findMany: {
            args: Prisma.QuestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>[]
          }
          create: {
            args: Prisma.QuestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          createMany: {
            args: Prisma.QuestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>[]
          }
          delete: {
            args: Prisma.QuestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          update: {
            args: Prisma.QuestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          deleteMany: {
            args: Prisma.QuestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestsPayload>
          }
          aggregate: {
            args: Prisma.QuestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuests>
          }
          groupBy: {
            args: Prisma.QuestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestsCountAggregateOutputType> | number
          }
        }
      }
      UserQuests: {
        payload: Prisma.$UserQuestsPayload<ExtArgs>
        fields: Prisma.UserQuestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          findFirst: {
            args: Prisma.UserQuestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          findMany: {
            args: Prisma.UserQuestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>[]
          }
          create: {
            args: Prisma.UserQuestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          createMany: {
            args: Prisma.UserQuestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserQuestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>[]
          }
          delete: {
            args: Prisma.UserQuestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          update: {
            args: Prisma.UserQuestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          deleteMany: {
            args: Prisma.UserQuestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserQuestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestsPayload>
          }
          aggregate: {
            args: Prisma.UserQuestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQuests>
          }
          groupBy: {
            args: Prisma.UserQuestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQuestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuestsCountArgs<ExtArgs>
            result: $Utils.Optional<UserQuestsCountAggregateOutputType> | number
          }
        }
      }
      Software: {
        payload: Prisma.$SoftwarePayload<ExtArgs>
        fields: Prisma.SoftwareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoftwareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoftwareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          findFirst: {
            args: Prisma.SoftwareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoftwareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          findMany: {
            args: Prisma.SoftwareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>[]
          }
          create: {
            args: Prisma.SoftwareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          createMany: {
            args: Prisma.SoftwareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SoftwareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>[]
          }
          delete: {
            args: Prisma.SoftwareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          update: {
            args: Prisma.SoftwareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          deleteMany: {
            args: Prisma.SoftwareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SoftwareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SoftwareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoftwarePayload>
          }
          aggregate: {
            args: Prisma.SoftwareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoftware>
          }
          groupBy: {
            args: Prisma.SoftwareGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoftwareGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoftwareCountArgs<ExtArgs>
            result: $Utils.Optional<SoftwareCountAggregateOutputType> | number
          }
        }
      }
      Process: {
        payload: Prisma.$ProcessPayload<ExtArgs>
        fields: Prisma.ProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findFirst: {
            args: Prisma.ProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findMany: {
            args: Prisma.ProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          create: {
            args: Prisma.ProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          createMany: {
            args: Prisma.ProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          delete: {
            args: Prisma.ProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          update: {
            args: Prisma.ProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          deleteMany: {
            args: Prisma.ProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          aggregate: {
            args: Prisma.ProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcess>
          }
          groupBy: {
            args: Prisma.ProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      Logs: {
        payload: Prisma.$LogsPayload<ExtArgs>
        fields: Prisma.LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findFirst: {
            args: Prisma.LogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findMany: {
            args: Prisma.LogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          create: {
            args: Prisma.LogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          createMany: {
            args: Prisma.LogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          delete: {
            args: Prisma.LogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          update: {
            args: Prisma.LogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          deleteMany: {
            args: Prisma.LogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.LogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogsCountArgs<ExtArgs>
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
      Trade: {
        payload: Prisma.$TradePayload<ExtArgs>
        fields: Prisma.TradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findFirst: {
            args: Prisma.TradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findMany: {
            args: Prisma.TradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>[]
          }
          create: {
            args: Prisma.TradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          createMany: {
            args: Prisma.TradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>[]
          }
          delete: {
            args: Prisma.TradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          update: {
            args: Prisma.TradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          deleteMany: {
            args: Prisma.TradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          aggregate: {
            args: Prisma.TradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrade>
          }
          groupBy: {
            args: Prisma.TradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeCountArgs<ExtArgs>
            result: $Utils.Optional<TradeCountAggregateOutputType> | number
          }
        }
      }
      Fund: {
        payload: Prisma.$FundPayload<ExtArgs>
        fields: Prisma.FundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          findFirst: {
            args: Prisma.FundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          findMany: {
            args: Prisma.FundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>[]
          }
          create: {
            args: Prisma.FundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          createMany: {
            args: Prisma.FundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>[]
          }
          delete: {
            args: Prisma.FundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          update: {
            args: Prisma.FundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          deleteMany: {
            args: Prisma.FundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          aggregate: {
            args: Prisma.FundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFund>
          }
          groupBy: {
            args: Prisma.FundGroupByArgs<ExtArgs>
            result: $Utils.Optional<FundGroupByOutputType>[]
          }
          count: {
            args: Prisma.FundCountArgs<ExtArgs>
            result: $Utils.Optional<FundCountAggregateOutputType> | number
          }
        }
      }
      Portfolio: {
        payload: Prisma.$PortfolioPayload<ExtArgs>
        fields: Prisma.PortfolioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findFirst: {
            args: Prisma.PortfolioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findMany: {
            args: Prisma.PortfolioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          create: {
            args: Prisma.PortfolioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          createMany: {
            args: Prisma.PortfolioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          delete: {
            args: Prisma.PortfolioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          update: {
            args: Prisma.PortfolioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          aggregate: {
            args: Prisma.PortfolioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolio>
          }
          groupBy: {
            args: Prisma.PortfolioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCountAggregateOutputType> | number
          }
        }
      }
      PortfolioHolding: {
        payload: Prisma.$PortfolioHoldingPayload<ExtArgs>
        fields: Prisma.PortfolioHoldingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioHoldingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioHoldingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>
          }
          findFirst: {
            args: Prisma.PortfolioHoldingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioHoldingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>
          }
          findMany: {
            args: Prisma.PortfolioHoldingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>[]
          }
          create: {
            args: Prisma.PortfolioHoldingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>
          }
          createMany: {
            args: Prisma.PortfolioHoldingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioHoldingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>[]
          }
          delete: {
            args: Prisma.PortfolioHoldingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>
          }
          update: {
            args: Prisma.PortfolioHoldingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioHoldingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioHoldingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioHoldingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioHoldingPayload>
          }
          aggregate: {
            args: Prisma.PortfolioHoldingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioHolding>
          }
          groupBy: {
            args: Prisma.PortfolioHoldingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioHoldingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioHoldingCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioHoldingCountAggregateOutputType> | number
          }
        }
      }
      HedgeFund: {
        payload: Prisma.$HedgeFundPayload<ExtArgs>
        fields: Prisma.HedgeFundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HedgeFundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HedgeFundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>
          }
          findFirst: {
            args: Prisma.HedgeFundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HedgeFundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>
          }
          findMany: {
            args: Prisma.HedgeFundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>[]
          }
          create: {
            args: Prisma.HedgeFundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>
          }
          createMany: {
            args: Prisma.HedgeFundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HedgeFundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>[]
          }
          delete: {
            args: Prisma.HedgeFundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>
          }
          update: {
            args: Prisma.HedgeFundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>
          }
          deleteMany: {
            args: Prisma.HedgeFundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HedgeFundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HedgeFundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HedgeFundPayload>
          }
          aggregate: {
            args: Prisma.HedgeFundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHedgeFund>
          }
          groupBy: {
            args: Prisma.HedgeFundGroupByArgs<ExtArgs>
            result: $Utils.Optional<HedgeFundGroupByOutputType>[]
          }
          count: {
            args: Prisma.HedgeFundCountArgs<ExtArgs>
            result: $Utils.Optional<HedgeFundCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accountBook: number
    addressBook: number
    computer: number
    dns: number
    logs: number
    memory: number
    notifications: number
    process: number
    profile: number
    session: number
    software: number
    userQuests: number
    portfolios: number
    ongoingTrades: number
    managedFunds: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | UserCountOutputTypeCountAccountBookArgs
    addressBook?: boolean | UserCountOutputTypeCountAddressBookArgs
    computer?: boolean | UserCountOutputTypeCountComputerArgs
    dns?: boolean | UserCountOutputTypeCountDnsArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    memory?: boolean | UserCountOutputTypeCountMemoryArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    process?: boolean | UserCountOutputTypeCountProcessArgs
    profile?: boolean | UserCountOutputTypeCountProfileArgs
    session?: boolean | UserCountOutputTypeCountSessionArgs
    software?: boolean | UserCountOutputTypeCountSoftwareArgs
    userQuests?: boolean | UserCountOutputTypeCountUserQuestsArgs
    portfolios?: boolean | UserCountOutputTypeCountPortfoliosArgs
    ongoingTrades?: boolean | UserCountOutputTypeCountOngoingTradesArgs
    managedFunds?: boolean | UserCountOutputTypeCountManagedFundsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComputerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComputerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPortfoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOngoingTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedFundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FundWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    accountBook: number
    addressBook: number
    computer: number
    dns: number
    hardware: number
    logs: number
    memory: number
    process: number
    profile: number
    quests: number
    software: number
    userQuests: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | GameCountOutputTypeCountAccountBookArgs
    addressBook?: boolean | GameCountOutputTypeCountAddressBookArgs
    computer?: boolean | GameCountOutputTypeCountComputerArgs
    dns?: boolean | GameCountOutputTypeCountDnsArgs
    hardware?: boolean | GameCountOutputTypeCountHardwareArgs
    logs?: boolean | GameCountOutputTypeCountLogsArgs
    memory?: boolean | GameCountOutputTypeCountMemoryArgs
    process?: boolean | GameCountOutputTypeCountProcessArgs
    profile?: boolean | GameCountOutputTypeCountProfileArgs
    quests?: boolean | GameCountOutputTypeCountQuestsArgs
    software?: boolean | GameCountOutputTypeCountSoftwareArgs
    userQuests?: boolean | GameCountOutputTypeCountUserQuestsArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountAddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountComputerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComputerWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountDnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountHardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HardwareWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountMemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestsWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountSoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountUserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
  }


  /**
   * Count Type MemoryCountOutputType
   */

  export type MemoryCountOutputType = {
    accountBook: number
  }

  export type MemoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | MemoryCountOutputTypeCountAccountBookArgs
  }

  // Custom InputTypes
  /**
   * MemoryCountOutputType without action
   */
  export type MemoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemoryCountOutputType
     */
    select?: MemoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemoryCountOutputType without action
   */
  export type MemoryCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }


  /**
   * Count Type ComputerCountOutputType
   */

  export type ComputerCountOutputType = {
    accountBook: number
    addressBook: number
    dns: number
    hardware: number
    logs: number
    memory: number
    process: number
    software: number
  }

  export type ComputerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | ComputerCountOutputTypeCountAccountBookArgs
    addressBook?: boolean | ComputerCountOutputTypeCountAddressBookArgs
    dns?: boolean | ComputerCountOutputTypeCountDnsArgs
    hardware?: boolean | ComputerCountOutputTypeCountHardwareArgs
    logs?: boolean | ComputerCountOutputTypeCountLogsArgs
    memory?: boolean | ComputerCountOutputTypeCountMemoryArgs
    process?: boolean | ComputerCountOutputTypeCountProcessArgs
    software?: boolean | ComputerCountOutputTypeCountSoftwareArgs
  }

  // Custom InputTypes
  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComputerCountOutputType
     */
    select?: ComputerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountAccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountAddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountDnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountHardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HardwareWhereInput
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountMemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * ComputerCountOutputType without action
   */
  export type ComputerCountOutputTypeCountSoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
  }


  /**
   * Count Type QuestsCountOutputType
   */

  export type QuestsCountOutputType = {
    userQuests: number
  }

  export type QuestsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userQuests?: boolean | QuestsCountOutputTypeCountUserQuestsArgs
  }

  // Custom InputTypes
  /**
   * QuestsCountOutputType without action
   */
  export type QuestsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestsCountOutputType
     */
    select?: QuestsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestsCountOutputType without action
   */
  export type QuestsCountOutputTypeCountUserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
  }


  /**
   * Count Type FundCountOutputType
   */

  export type FundCountOutputType = {
    trades: number
    holdings: number
    hedgeFunds: number
  }

  export type FundCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trades?: boolean | FundCountOutputTypeCountTradesArgs
    holdings?: boolean | FundCountOutputTypeCountHoldingsArgs
    hedgeFunds?: boolean | FundCountOutputTypeCountHedgeFundsArgs
  }

  // Custom InputTypes
  /**
   * FundCountOutputType without action
   */
  export type FundCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundCountOutputType
     */
    select?: FundCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FundCountOutputType without action
   */
  export type FundCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }

  /**
   * FundCountOutputType without action
   */
  export type FundCountOutputTypeCountHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioHoldingWhereInput
  }

  /**
   * FundCountOutputType without action
   */
  export type FundCountOutputTypeCountHedgeFundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HedgeFundWhereInput
  }


  /**
   * Count Type PortfolioCountOutputType
   */

  export type PortfolioCountOutputType = {
    holdings: number
    trades: number
  }

  export type PortfolioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holdings?: boolean | PortfolioCountOutputTypeCountHoldingsArgs
    trades?: boolean | PortfolioCountOutputTypeCountTradesArgs
  }

  // Custom InputTypes
  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioCountOutputType
     */
    select?: PortfolioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioHoldingWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    salt: string | null
    lastAction: Date | null
    created: Date | null
    refreshToken: string | null
    group: $Enums.Groups | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    salt: string | null
    lastAction: Date | null
    created: Date | null
    refreshToken: string | null
    group: $Enums.Groups | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    salt: number
    lastAction: number
    created: number
    refreshToken: number
    group: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    salt?: true
    lastAction?: true
    created?: true
    refreshToken?: true
    group?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    salt?: true
    lastAction?: true
    created?: true
    refreshToken?: true
    group?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    salt?: true
    lastAction?: true
    created?: true
    refreshToken?: true
    group?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    password: string
    salt: string
    lastAction: Date
    created: Date
    refreshToken: string | null
    group: $Enums.Groups
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    salt?: boolean
    lastAction?: boolean
    created?: boolean
    refreshToken?: boolean
    group?: boolean
    accountBook?: boolean | User$accountBookArgs<ExtArgs>
    addressBook?: boolean | User$addressBookArgs<ExtArgs>
    computer?: boolean | User$computerArgs<ExtArgs>
    dns?: boolean | User$dnsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    memory?: boolean | User$memoryArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    process?: boolean | User$processArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    session?: boolean | User$sessionArgs<ExtArgs>
    software?: boolean | User$softwareArgs<ExtArgs>
    userQuests?: boolean | User$userQuestsArgs<ExtArgs>
    portfolios?: boolean | User$portfoliosArgs<ExtArgs>
    ongoingTrades?: boolean | User$ongoingTradesArgs<ExtArgs>
    managedFunds?: boolean | User$managedFundsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    salt?: boolean
    lastAction?: boolean
    created?: boolean
    refreshToken?: boolean
    group?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    salt?: boolean
    lastAction?: boolean
    created?: boolean
    refreshToken?: boolean
    group?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | User$accountBookArgs<ExtArgs>
    addressBook?: boolean | User$addressBookArgs<ExtArgs>
    computer?: boolean | User$computerArgs<ExtArgs>
    dns?: boolean | User$dnsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    memory?: boolean | User$memoryArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    process?: boolean | User$processArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    session?: boolean | User$sessionArgs<ExtArgs>
    software?: boolean | User$softwareArgs<ExtArgs>
    userQuests?: boolean | User$userQuestsArgs<ExtArgs>
    portfolios?: boolean | User$portfoliosArgs<ExtArgs>
    ongoingTrades?: boolean | User$ongoingTradesArgs<ExtArgs>
    managedFunds?: boolean | User$managedFundsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
      addressBook: Prisma.$AddressBookPayload<ExtArgs>[]
      computer: Prisma.$ComputerPayload<ExtArgs>[]
      dns: Prisma.$DNSPayload<ExtArgs>[]
      logs: Prisma.$LogsPayload<ExtArgs>[]
      memory: Prisma.$MemoryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationsPayload<ExtArgs>[]
      process: Prisma.$ProcessPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs>[]
      session: Prisma.$SessionPayload<ExtArgs>[]
      software: Prisma.$SoftwarePayload<ExtArgs>[]
      userQuests: Prisma.$UserQuestsPayload<ExtArgs>[]
      portfolios: Prisma.$PortfolioPayload<ExtArgs>[]
      ongoingTrades: Prisma.$TradePayload<ExtArgs>[]
      managedFunds: Prisma.$FundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      password: string
      salt: string
      lastAction: Date
      created: Date
      refreshToken: string | null
      group: $Enums.Groups
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountBook<T extends User$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, User$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findMany"> | Null>
    addressBook<T extends User$addressBookArgs<ExtArgs> = {}>(args?: Subset<T, User$addressBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findMany"> | Null>
    computer<T extends User$computerArgs<ExtArgs> = {}>(args?: Subset<T, User$computerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findMany"> | Null>
    dns<T extends User$dnsArgs<ExtArgs> = {}>(args?: Subset<T, User$dnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany"> | Null>
    memory<T extends User$memoryArgs<ExtArgs> = {}>(args?: Subset<T, User$memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany"> | Null>
    process<T extends User$processArgs<ExtArgs> = {}>(args?: Subset<T, User$processArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany"> | Null>
    session<T extends User$sessionArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    software<T extends User$softwareArgs<ExtArgs> = {}>(args?: Subset<T, User$softwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findMany"> | Null>
    userQuests<T extends User$userQuestsArgs<ExtArgs> = {}>(args?: Subset<T, User$userQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findMany"> | Null>
    portfolios<T extends User$portfoliosArgs<ExtArgs> = {}>(args?: Subset<T, User$portfoliosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany"> | Null>
    ongoingTrades<T extends User$ongoingTradesArgs<ExtArgs> = {}>(args?: Subset<T, User$ongoingTradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany"> | Null>
    managedFunds<T extends User$managedFundsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedFundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly salt: FieldRef<"User", 'String'>
    readonly lastAction: FieldRef<"User", 'DateTime'>
    readonly created: FieldRef<"User", 'DateTime'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly group: FieldRef<"User", 'Groups'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.accountBook
   */
  export type User$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }

  /**
   * User.addressBook
   */
  export type User$addressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    cursor?: AddressBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }

  /**
   * User.computer
   */
  export type User$computerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    where?: ComputerWhereInput
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    cursor?: ComputerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }

  /**
   * User.dns
   */
  export type User$dnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    cursor?: DNSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * User.memory
   */
  export type User$memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    cursor?: MemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * User.process
   */
  export type User$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * User.session
   */
  export type User$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.software
   */
  export type User$softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    cursor?: SoftwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * User.userQuests
   */
  export type User$userQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    cursor?: UserQuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }

  /**
   * User.portfolios
   */
  export type User$portfoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    cursor?: PortfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * User.ongoingTrades
   */
  export type User$ongoingTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * User.managedFunds
   */
  export type User$managedFundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    where?: FundWhereInput
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    cursor?: FundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    name: string | null
    started: Date | null
    ended: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    started: Date | null
    ended: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    name: number
    started: number
    ended: number
    _all: number
  }


  export type GameMinAggregateInputType = {
    id?: true
    name?: true
    started?: true
    ended?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    name?: true
    started?: true
    ended?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    name?: true
    started?: true
    ended?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    name: string
    started: Date
    ended: Date | null
    _count: GameCountAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    started?: boolean
    ended?: boolean
    accountBook?: boolean | Game$accountBookArgs<ExtArgs>
    addressBook?: boolean | Game$addressBookArgs<ExtArgs>
    computer?: boolean | Game$computerArgs<ExtArgs>
    dns?: boolean | Game$dnsArgs<ExtArgs>
    hardware?: boolean | Game$hardwareArgs<ExtArgs>
    logs?: boolean | Game$logsArgs<ExtArgs>
    memory?: boolean | Game$memoryArgs<ExtArgs>
    process?: boolean | Game$processArgs<ExtArgs>
    profile?: boolean | Game$profileArgs<ExtArgs>
    quests?: boolean | Game$questsArgs<ExtArgs>
    software?: boolean | Game$softwareArgs<ExtArgs>
    userQuests?: boolean | Game$userQuestsArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    started?: boolean
    ended?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    name?: boolean
    started?: boolean
    ended?: boolean
  }

  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | Game$accountBookArgs<ExtArgs>
    addressBook?: boolean | Game$addressBookArgs<ExtArgs>
    computer?: boolean | Game$computerArgs<ExtArgs>
    dns?: boolean | Game$dnsArgs<ExtArgs>
    hardware?: boolean | Game$hardwareArgs<ExtArgs>
    logs?: boolean | Game$logsArgs<ExtArgs>
    memory?: boolean | Game$memoryArgs<ExtArgs>
    process?: boolean | Game$processArgs<ExtArgs>
    profile?: boolean | Game$profileArgs<ExtArgs>
    quests?: boolean | Game$questsArgs<ExtArgs>
    software?: boolean | Game$softwareArgs<ExtArgs>
    userQuests?: boolean | Game$userQuestsArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
      addressBook: Prisma.$AddressBookPayload<ExtArgs>[]
      computer: Prisma.$ComputerPayload<ExtArgs>[]
      dns: Prisma.$DNSPayload<ExtArgs>[]
      hardware: Prisma.$HardwarePayload<ExtArgs>[]
      logs: Prisma.$LogsPayload<ExtArgs>[]
      memory: Prisma.$MemoryPayload<ExtArgs>[]
      process: Prisma.$ProcessPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs>[]
      quests: Prisma.$QuestsPayload<ExtArgs>[]
      software: Prisma.$SoftwarePayload<ExtArgs>[]
      userQuests: Prisma.$UserQuestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      started: Date
      ended: Date | null
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountBook<T extends Game$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, Game$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findMany"> | Null>
    addressBook<T extends Game$addressBookArgs<ExtArgs> = {}>(args?: Subset<T, Game$addressBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findMany"> | Null>
    computer<T extends Game$computerArgs<ExtArgs> = {}>(args?: Subset<T, Game$computerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findMany"> | Null>
    dns<T extends Game$dnsArgs<ExtArgs> = {}>(args?: Subset<T, Game$dnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findMany"> | Null>
    hardware<T extends Game$hardwareArgs<ExtArgs> = {}>(args?: Subset<T, Game$hardwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Game$logsArgs<ExtArgs> = {}>(args?: Subset<T, Game$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany"> | Null>
    memory<T extends Game$memoryArgs<ExtArgs> = {}>(args?: Subset<T, Game$memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findMany"> | Null>
    process<T extends Game$processArgs<ExtArgs> = {}>(args?: Subset<T, Game$processArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends Game$profileArgs<ExtArgs> = {}>(args?: Subset<T, Game$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany"> | Null>
    quests<T extends Game$questsArgs<ExtArgs> = {}>(args?: Subset<T, Game$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "findMany"> | Null>
    software<T extends Game$softwareArgs<ExtArgs> = {}>(args?: Subset<T, Game$softwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findMany"> | Null>
    userQuests<T extends Game$userQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Game$userQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */ 
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly name: FieldRef<"Game", 'String'>
    readonly started: FieldRef<"Game", 'DateTime'>
    readonly ended: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
  }

  /**
   * Game.accountBook
   */
  export type Game$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }

  /**
   * Game.addressBook
   */
  export type Game$addressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    cursor?: AddressBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }

  /**
   * Game.computer
   */
  export type Game$computerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    where?: ComputerWhereInput
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    cursor?: ComputerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }

  /**
   * Game.dns
   */
  export type Game$dnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    cursor?: DNSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }

  /**
   * Game.hardware
   */
  export type Game$hardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    where?: HardwareWhereInput
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    cursor?: HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }

  /**
   * Game.logs
   */
  export type Game$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Game.memory
   */
  export type Game$memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    cursor?: MemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }

  /**
   * Game.process
   */
  export type Game$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Game.profile
   */
  export type Game$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Game.quests
   */
  export type Game$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    where?: QuestsWhereInput
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    cursor?: QuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }

  /**
   * Game.software
   */
  export type Game$softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    cursor?: SoftwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * Game.userQuests
   */
  export type Game$userQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    cursor?: UserQuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    token: string | null
    lastAction: Date | null
    created: Date | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    token: string | null
    lastAction: Date | null
    created: Date | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    lastAction: number
    created: number
    expires: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    lastAction?: true
    created?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    lastAction?: true
    created?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    lastAction?: true
    created?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: number
    token: string
    lastAction: Date
    created: Date
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    lastAction?: boolean
    created?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    lastAction?: boolean
    created?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    lastAction?: boolean
    created?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      token: string
      lastAction: Date
      created: Date
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly token: FieldRef<"Session", 'String'>
    readonly lastAction: FieldRef<"Session", 'DateTime'>
    readonly created: FieldRef<"Session", 'DateTime'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Hardware
   */

  export type AggregateHardware = {
    _count: HardwareCountAggregateOutputType | null
    _avg: HardwareAvgAggregateOutputType | null
    _sum: HardwareSumAggregateOutputType | null
    _min: HardwareMinAggregateOutputType | null
    _max: HardwareMaxAggregateOutputType | null
  }

  export type HardwareAvgAggregateOutputType = {
    id: number | null
    strength: number | null
  }

  export type HardwareSumAggregateOutputType = {
    id: number | null
    strength: number | null
  }

  export type HardwareMinAggregateOutputType = {
    id: number | null
    computerId: string | null
    gameId: string | null
    type: $Enums.HardwareTypes | null
    strength: number | null
  }

  export type HardwareMaxAggregateOutputType = {
    id: number | null
    computerId: string | null
    gameId: string | null
    type: $Enums.HardwareTypes | null
    strength: number | null
  }

  export type HardwareCountAggregateOutputType = {
    id: number
    computerId: number
    gameId: number
    type: number
    strength: number
    _all: number
  }


  export type HardwareAvgAggregateInputType = {
    id?: true
    strength?: true
  }

  export type HardwareSumAggregateInputType = {
    id?: true
    strength?: true
  }

  export type HardwareMinAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    type?: true
    strength?: true
  }

  export type HardwareMaxAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    type?: true
    strength?: true
  }

  export type HardwareCountAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    type?: true
    strength?: true
    _all?: true
  }

  export type HardwareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hardware to aggregate.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hardware
    **/
    _count?: true | HardwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HardwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HardwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HardwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HardwareMaxAggregateInputType
  }

  export type GetHardwareAggregateType<T extends HardwareAggregateArgs> = {
        [P in keyof T & keyof AggregateHardware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHardware[P]>
      : GetScalarType<T[P], AggregateHardware[P]>
  }




  export type HardwareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HardwareWhereInput
    orderBy?: HardwareOrderByWithAggregationInput | HardwareOrderByWithAggregationInput[]
    by: HardwareScalarFieldEnum[] | HardwareScalarFieldEnum
    having?: HardwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HardwareCountAggregateInputType | true
    _avg?: HardwareAvgAggregateInputType
    _sum?: HardwareSumAggregateInputType
    _min?: HardwareMinAggregateInputType
    _max?: HardwareMaxAggregateInputType
  }

  export type HardwareGroupByOutputType = {
    id: number
    computerId: string
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
    _count: HardwareCountAggregateOutputType | null
    _avg: HardwareAvgAggregateOutputType | null
    _sum: HardwareSumAggregateOutputType | null
    _min: HardwareMinAggregateOutputType | null
    _max: HardwareMaxAggregateOutputType | null
  }

  type GetHardwareGroupByPayload<T extends HardwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HardwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HardwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HardwareGroupByOutputType[P]>
            : GetScalarType<T[P], HardwareGroupByOutputType[P]>
        }
      >
    >


  export type HardwareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    strength?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hardware"]>

  export type HardwareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    strength?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hardware"]>

  export type HardwareSelectScalar = {
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    strength?: boolean
  }

  export type HardwareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type HardwareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $HardwarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hardware"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      computerId: string
      gameId: string
      type: $Enums.HardwareTypes
      strength: number
    }, ExtArgs["result"]["hardware"]>
    composites: {}
  }

  type HardwareGetPayload<S extends boolean | null | undefined | HardwareDefaultArgs> = $Result.GetResult<Prisma.$HardwarePayload, S>

  type HardwareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HardwareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HardwareCountAggregateInputType | true
    }

  export interface HardwareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hardware'], meta: { name: 'Hardware' } }
    /**
     * Find zero or one Hardware that matches the filter.
     * @param {HardwareFindUniqueArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HardwareFindUniqueArgs>(args: SelectSubset<T, HardwareFindUniqueArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hardware that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HardwareFindUniqueOrThrowArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HardwareFindUniqueOrThrowArgs>(args: SelectSubset<T, HardwareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindFirstArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HardwareFindFirstArgs>(args?: SelectSubset<T, HardwareFindFirstArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hardware that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindFirstOrThrowArgs} args - Arguments to find a Hardware
     * @example
     * // Get one Hardware
     * const hardware = await prisma.hardware.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HardwareFindFirstOrThrowArgs>(args?: SelectSubset<T, HardwareFindFirstOrThrowArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hardware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hardware
     * const hardware = await prisma.hardware.findMany()
     * 
     * // Get first 10 Hardware
     * const hardware = await prisma.hardware.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hardwareWithIdOnly = await prisma.hardware.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HardwareFindManyArgs>(args?: SelectSubset<T, HardwareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hardware.
     * @param {HardwareCreateArgs} args - Arguments to create a Hardware.
     * @example
     * // Create one Hardware
     * const Hardware = await prisma.hardware.create({
     *   data: {
     *     // ... data to create a Hardware
     *   }
     * })
     * 
     */
    create<T extends HardwareCreateArgs>(args: SelectSubset<T, HardwareCreateArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hardware.
     * @param {HardwareCreateManyArgs} args - Arguments to create many Hardware.
     * @example
     * // Create many Hardware
     * const hardware = await prisma.hardware.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HardwareCreateManyArgs>(args?: SelectSubset<T, HardwareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hardware and returns the data saved in the database.
     * @param {HardwareCreateManyAndReturnArgs} args - Arguments to create many Hardware.
     * @example
     * // Create many Hardware
     * const hardware = await prisma.hardware.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hardware and only return the `id`
     * const hardwareWithIdOnly = await prisma.hardware.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HardwareCreateManyAndReturnArgs>(args?: SelectSubset<T, HardwareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hardware.
     * @param {HardwareDeleteArgs} args - Arguments to delete one Hardware.
     * @example
     * // Delete one Hardware
     * const Hardware = await prisma.hardware.delete({
     *   where: {
     *     // ... filter to delete one Hardware
     *   }
     * })
     * 
     */
    delete<T extends HardwareDeleteArgs>(args: SelectSubset<T, HardwareDeleteArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hardware.
     * @param {HardwareUpdateArgs} args - Arguments to update one Hardware.
     * @example
     * // Update one Hardware
     * const hardware = await prisma.hardware.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HardwareUpdateArgs>(args: SelectSubset<T, HardwareUpdateArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hardware.
     * @param {HardwareDeleteManyArgs} args - Arguments to filter Hardware to delete.
     * @example
     * // Delete a few Hardware
     * const { count } = await prisma.hardware.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HardwareDeleteManyArgs>(args?: SelectSubset<T, HardwareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hardware
     * const hardware = await prisma.hardware.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HardwareUpdateManyArgs>(args: SelectSubset<T, HardwareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hardware.
     * @param {HardwareUpsertArgs} args - Arguments to update or create a Hardware.
     * @example
     * // Update or create a Hardware
     * const hardware = await prisma.hardware.upsert({
     *   create: {
     *     // ... data to create a Hardware
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hardware we want to update
     *   }
     * })
     */
    upsert<T extends HardwareUpsertArgs>(args: SelectSubset<T, HardwareUpsertArgs<ExtArgs>>): Prisma__HardwareClient<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareCountArgs} args - Arguments to filter Hardware to count.
     * @example
     * // Count the number of Hardware
     * const count = await prisma.hardware.count({
     *   where: {
     *     // ... the filter for the Hardware we want to count
     *   }
     * })
    **/
    count<T extends HardwareCountArgs>(
      args?: Subset<T, HardwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HardwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HardwareAggregateArgs>(args: Subset<T, HardwareAggregateArgs>): Prisma.PrismaPromise<GetHardwareAggregateType<T>>

    /**
     * Group by Hardware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HardwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HardwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HardwareGroupByArgs['orderBy'] }
        : { orderBy?: HardwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HardwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHardwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hardware model
   */
  readonly fields: HardwareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hardware.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HardwareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hardware model
   */ 
  interface HardwareFieldRefs {
    readonly id: FieldRef<"Hardware", 'Int'>
    readonly computerId: FieldRef<"Hardware", 'String'>
    readonly gameId: FieldRef<"Hardware", 'String'>
    readonly type: FieldRef<"Hardware", 'HardwareTypes'>
    readonly strength: FieldRef<"Hardware", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Hardware findUnique
   */
  export type HardwareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where: HardwareWhereUniqueInput
  }

  /**
   * Hardware findUniqueOrThrow
   */
  export type HardwareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where: HardwareWhereUniqueInput
  }

  /**
   * Hardware findFirst
   */
  export type HardwareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware.
     */
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }

  /**
   * Hardware findFirstOrThrow
   */
  export type HardwareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hardware.
     */
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }

  /**
   * Hardware findMany
   */
  export type HardwareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter, which Hardware to fetch.
     */
    where?: HardwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hardware to fetch.
     */
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hardware.
     */
    cursor?: HardwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hardware from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hardware.
     */
    skip?: number
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }

  /**
   * Hardware create
   */
  export type HardwareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * The data needed to create a Hardware.
     */
    data: XOR<HardwareCreateInput, HardwareUncheckedCreateInput>
  }

  /**
   * Hardware createMany
   */
  export type HardwareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hardware.
     */
    data: HardwareCreateManyInput | HardwareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hardware createManyAndReturn
   */
  export type HardwareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hardware.
     */
    data: HardwareCreateManyInput | HardwareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hardware update
   */
  export type HardwareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * The data needed to update a Hardware.
     */
    data: XOR<HardwareUpdateInput, HardwareUncheckedUpdateInput>
    /**
     * Choose, which Hardware to update.
     */
    where: HardwareWhereUniqueInput
  }

  /**
   * Hardware updateMany
   */
  export type HardwareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hardware.
     */
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyInput>
    /**
     * Filter which Hardware to update
     */
    where?: HardwareWhereInput
  }

  /**
   * Hardware upsert
   */
  export type HardwareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * The filter to search for the Hardware to update in case it exists.
     */
    where: HardwareWhereUniqueInput
    /**
     * In case the Hardware found by the `where` argument doesn't exist, create a new Hardware with this data.
     */
    create: XOR<HardwareCreateInput, HardwareUncheckedCreateInput>
    /**
     * In case the Hardware was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HardwareUpdateInput, HardwareUncheckedUpdateInput>
  }

  /**
   * Hardware delete
   */
  export type HardwareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    /**
     * Filter which Hardware to delete.
     */
    where: HardwareWhereUniqueInput
  }

  /**
   * Hardware deleteMany
   */
  export type HardwareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hardware to delete
     */
    where?: HardwareWhereInput
  }

  /**
   * Hardware without action
   */
  export type HardwareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
  }


  /**
   * Model AddressBook
   */

  export type AggregateAddressBook = {
    _count: AddressBookCountAggregateOutputType | null
    _avg: AddressBookAvgAggregateOutputType | null
    _sum: AddressBookSumAggregateOutputType | null
    _min: AddressBookMinAggregateOutputType | null
    _max: AddressBookMaxAggregateOutputType | null
  }

  export type AddressBookAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressBookSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressBookMinAggregateOutputType = {
    id: number | null
    userId: number | null
    access: $Enums.AccessLevel | null
    computerId: string | null
    ip: string | null
    gameId: string | null
  }

  export type AddressBookMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    access: $Enums.AccessLevel | null
    computerId: string | null
    ip: string | null
    gameId: string | null
  }

  export type AddressBookCountAggregateOutputType = {
    id: number
    userId: number
    access: number
    computerId: number
    ip: number
    data: number
    gameId: number
    _all: number
  }


  export type AddressBookAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressBookSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressBookMinAggregateInputType = {
    id?: true
    userId?: true
    access?: true
    computerId?: true
    ip?: true
    gameId?: true
  }

  export type AddressBookMaxAggregateInputType = {
    id?: true
    userId?: true
    access?: true
    computerId?: true
    ip?: true
    gameId?: true
  }

  export type AddressBookCountAggregateInputType = {
    id?: true
    userId?: true
    access?: true
    computerId?: true
    ip?: true
    data?: true
    gameId?: true
    _all?: true
  }

  export type AddressBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressBook to aggregate.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddressBooks
    **/
    _count?: true | AddressBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressBookMaxAggregateInputType
  }

  export type GetAddressBookAggregateType<T extends AddressBookAggregateArgs> = {
        [P in keyof T & keyof AggregateAddressBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddressBook[P]>
      : GetScalarType<T[P], AggregateAddressBook[P]>
  }




  export type AddressBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithAggregationInput | AddressBookOrderByWithAggregationInput[]
    by: AddressBookScalarFieldEnum[] | AddressBookScalarFieldEnum
    having?: AddressBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressBookCountAggregateInputType | true
    _avg?: AddressBookAvgAggregateInputType
    _sum?: AddressBookSumAggregateInputType
    _min?: AddressBookMinAggregateInputType
    _max?: AddressBookMaxAggregateInputType
  }

  export type AddressBookGroupByOutputType = {
    id: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data: JsonValue
    gameId: string
    _count: AddressBookCountAggregateOutputType | null
    _avg: AddressBookAvgAggregateOutputType | null
    _sum: AddressBookSumAggregateOutputType | null
    _min: AddressBookMinAggregateOutputType | null
    _max: AddressBookMaxAggregateOutputType | null
  }

  type GetAddressBookGroupByPayload<T extends AddressBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressBookGroupByOutputType[P]>
            : GetScalarType<T[P], AddressBookGroupByOutputType[P]>
        }
      >
    >


  export type AddressBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    access?: boolean
    computerId?: boolean
    ip?: boolean
    data?: boolean
    gameId?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addressBook"]>

  export type AddressBookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    access?: boolean
    computerId?: boolean
    ip?: boolean
    data?: boolean
    gameId?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addressBook"]>

  export type AddressBookSelectScalar = {
    id?: boolean
    userId?: boolean
    access?: boolean
    computerId?: boolean
    ip?: boolean
    data?: boolean
    gameId?: boolean
  }

  export type AddressBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AddressBookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AddressBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddressBook"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      access: $Enums.AccessLevel
      computerId: string
      ip: string
      data: Prisma.JsonValue
      gameId: string
    }, ExtArgs["result"]["addressBook"]>
    composites: {}
  }

  type AddressBookGetPayload<S extends boolean | null | undefined | AddressBookDefaultArgs> = $Result.GetResult<Prisma.$AddressBookPayload, S>

  type AddressBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressBookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressBookCountAggregateInputType | true
    }

  export interface AddressBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddressBook'], meta: { name: 'AddressBook' } }
    /**
     * Find zero or one AddressBook that matches the filter.
     * @param {AddressBookFindUniqueArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressBookFindUniqueArgs>(args: SelectSubset<T, AddressBookFindUniqueArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AddressBook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AddressBookFindUniqueOrThrowArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressBookFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AddressBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookFindFirstArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressBookFindFirstArgs>(args?: SelectSubset<T, AddressBookFindFirstArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AddressBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookFindFirstOrThrowArgs} args - Arguments to find a AddressBook
     * @example
     * // Get one AddressBook
     * const addressBook = await prisma.addressBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressBookFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AddressBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddressBooks
     * const addressBooks = await prisma.addressBook.findMany()
     * 
     * // Get first 10 AddressBooks
     * const addressBooks = await prisma.addressBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressBookWithIdOnly = await prisma.addressBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressBookFindManyArgs>(args?: SelectSubset<T, AddressBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AddressBook.
     * @param {AddressBookCreateArgs} args - Arguments to create a AddressBook.
     * @example
     * // Create one AddressBook
     * const AddressBook = await prisma.addressBook.create({
     *   data: {
     *     // ... data to create a AddressBook
     *   }
     * })
     * 
     */
    create<T extends AddressBookCreateArgs>(args: SelectSubset<T, AddressBookCreateArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AddressBooks.
     * @param {AddressBookCreateManyArgs} args - Arguments to create many AddressBooks.
     * @example
     * // Create many AddressBooks
     * const addressBook = await prisma.addressBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressBookCreateManyArgs>(args?: SelectSubset<T, AddressBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddressBooks and returns the data saved in the database.
     * @param {AddressBookCreateManyAndReturnArgs} args - Arguments to create many AddressBooks.
     * @example
     * // Create many AddressBooks
     * const addressBook = await prisma.addressBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddressBooks and only return the `id`
     * const addressBookWithIdOnly = await prisma.addressBook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressBookCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressBookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AddressBook.
     * @param {AddressBookDeleteArgs} args - Arguments to delete one AddressBook.
     * @example
     * // Delete one AddressBook
     * const AddressBook = await prisma.addressBook.delete({
     *   where: {
     *     // ... filter to delete one AddressBook
     *   }
     * })
     * 
     */
    delete<T extends AddressBookDeleteArgs>(args: SelectSubset<T, AddressBookDeleteArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AddressBook.
     * @param {AddressBookUpdateArgs} args - Arguments to update one AddressBook.
     * @example
     * // Update one AddressBook
     * const addressBook = await prisma.addressBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressBookUpdateArgs>(args: SelectSubset<T, AddressBookUpdateArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AddressBooks.
     * @param {AddressBookDeleteManyArgs} args - Arguments to filter AddressBooks to delete.
     * @example
     * // Delete a few AddressBooks
     * const { count } = await prisma.addressBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressBookDeleteManyArgs>(args?: SelectSubset<T, AddressBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddressBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddressBooks
     * const addressBook = await prisma.addressBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressBookUpdateManyArgs>(args: SelectSubset<T, AddressBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddressBook.
     * @param {AddressBookUpsertArgs} args - Arguments to update or create a AddressBook.
     * @example
     * // Update or create a AddressBook
     * const addressBook = await prisma.addressBook.upsert({
     *   create: {
     *     // ... data to create a AddressBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddressBook we want to update
     *   }
     * })
     */
    upsert<T extends AddressBookUpsertArgs>(args: SelectSubset<T, AddressBookUpsertArgs<ExtArgs>>): Prisma__AddressBookClient<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AddressBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookCountArgs} args - Arguments to filter AddressBooks to count.
     * @example
     * // Count the number of AddressBooks
     * const count = await prisma.addressBook.count({
     *   where: {
     *     // ... the filter for the AddressBooks we want to count
     *   }
     * })
    **/
    count<T extends AddressBookCountArgs>(
      args?: Subset<T, AddressBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddressBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressBookAggregateArgs>(args: Subset<T, AddressBookAggregateArgs>): Prisma.PrismaPromise<GetAddressBookAggregateType<T>>

    /**
     * Group by AddressBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressBookGroupByArgs['orderBy'] }
        : { orderBy?: AddressBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddressBook model
   */
  readonly fields: AddressBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddressBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddressBook model
   */ 
  interface AddressBookFieldRefs {
    readonly id: FieldRef<"AddressBook", 'Int'>
    readonly userId: FieldRef<"AddressBook", 'Int'>
    readonly access: FieldRef<"AddressBook", 'AccessLevel'>
    readonly computerId: FieldRef<"AddressBook", 'String'>
    readonly ip: FieldRef<"AddressBook", 'String'>
    readonly data: FieldRef<"AddressBook", 'Json'>
    readonly gameId: FieldRef<"AddressBook", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddressBook findUnique
   */
  export type AddressBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where: AddressBookWhereUniqueInput
  }

  /**
   * AddressBook findUniqueOrThrow
   */
  export type AddressBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where: AddressBookWhereUniqueInput
  }

  /**
   * AddressBook findFirst
   */
  export type AddressBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressBooks.
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressBooks.
     */
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }

  /**
   * AddressBook findFirstOrThrow
   */
  export type AddressBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBook to fetch.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressBooks.
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressBooks.
     */
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }

  /**
   * AddressBook findMany
   */
  export type AddressBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter, which AddressBooks to fetch.
     */
    where?: AddressBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressBooks to fetch.
     */
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddressBooks.
     */
    cursor?: AddressBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressBooks.
     */
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }

  /**
   * AddressBook create
   */
  export type AddressBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * The data needed to create a AddressBook.
     */
    data: XOR<AddressBookCreateInput, AddressBookUncheckedCreateInput>
  }

  /**
   * AddressBook createMany
   */
  export type AddressBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddressBooks.
     */
    data: AddressBookCreateManyInput | AddressBookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddressBook createManyAndReturn
   */
  export type AddressBookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AddressBooks.
     */
    data: AddressBookCreateManyInput | AddressBookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddressBook update
   */
  export type AddressBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * The data needed to update a AddressBook.
     */
    data: XOR<AddressBookUpdateInput, AddressBookUncheckedUpdateInput>
    /**
     * Choose, which AddressBook to update.
     */
    where: AddressBookWhereUniqueInput
  }

  /**
   * AddressBook updateMany
   */
  export type AddressBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddressBooks.
     */
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyInput>
    /**
     * Filter which AddressBooks to update
     */
    where?: AddressBookWhereInput
  }

  /**
   * AddressBook upsert
   */
  export type AddressBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * The filter to search for the AddressBook to update in case it exists.
     */
    where: AddressBookWhereUniqueInput
    /**
     * In case the AddressBook found by the `where` argument doesn't exist, create a new AddressBook with this data.
     */
    create: XOR<AddressBookCreateInput, AddressBookUncheckedCreateInput>
    /**
     * In case the AddressBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressBookUpdateInput, AddressBookUncheckedUpdateInput>
  }

  /**
   * AddressBook delete
   */
  export type AddressBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    /**
     * Filter which AddressBook to delete.
     */
    where: AddressBookWhereUniqueInput
  }

  /**
   * AddressBook deleteMany
   */
  export type AddressBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressBooks to delete
     */
    where?: AddressBookWhereInput
  }

  /**
   * AddressBook without action
   */
  export type AddressBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
  }


  /**
   * Model DNS
   */

  export type AggregateDNS = {
    _count: DNSCountAggregateOutputType | null
    _avg: DNSAvgAggregateOutputType | null
    _sum: DNSSumAggregateOutputType | null
    _min: DNSMinAggregateOutputType | null
    _max: DNSMaxAggregateOutputType | null
  }

  export type DNSAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DNSSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DNSMinAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    website: string | null
    tags: string | null
    description: string | null
    updated: Date | null
    created: Date | null
  }

  export type DNSMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    website: string | null
    tags: string | null
    description: string | null
    updated: Date | null
    created: Date | null
  }

  export type DNSCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    gameId: number
    website: number
    tags: number
    description: number
    updated: number
    created: number
    _all: number
  }


  export type DNSAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DNSSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DNSMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    website?: true
    tags?: true
    description?: true
    updated?: true
    created?: true
  }

  export type DNSMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    website?: true
    tags?: true
    description?: true
    updated?: true
    created?: true
  }

  export type DNSCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    website?: true
    tags?: true
    description?: true
    updated?: true
    created?: true
    _all?: true
  }

  export type DNSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DNS to aggregate.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DNS
    **/
    _count?: true | DNSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DNSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DNSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DNSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DNSMaxAggregateInputType
  }

  export type GetDNSAggregateType<T extends DNSAggregateArgs> = {
        [P in keyof T & keyof AggregateDNS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDNS[P]>
      : GetScalarType<T[P], AggregateDNS[P]>
  }




  export type DNSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithAggregationInput | DNSOrderByWithAggregationInput[]
    by: DNSScalarFieldEnum[] | DNSScalarFieldEnum
    having?: DNSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DNSCountAggregateInputType | true
    _avg?: DNSAvgAggregateInputType
    _sum?: DNSSumAggregateInputType
    _min?: DNSMinAggregateInputType
    _max?: DNSMaxAggregateInputType
  }

  export type DNSGroupByOutputType = {
    id: number
    userId: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description: string
    updated: Date
    created: Date
    _count: DNSCountAggregateOutputType | null
    _avg: DNSAvgAggregateOutputType | null
    _sum: DNSSumAggregateOutputType | null
    _min: DNSMinAggregateOutputType | null
    _max: DNSMaxAggregateOutputType | null
  }

  type GetDNSGroupByPayload<T extends DNSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DNSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DNSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DNSGroupByOutputType[P]>
            : GetScalarType<T[P], DNSGroupByOutputType[P]>
        }
      >
    >


  export type DNSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    website?: boolean
    tags?: boolean
    description?: boolean
    updated?: boolean
    created?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dNS"]>

  export type DNSSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    website?: boolean
    tags?: boolean
    description?: boolean
    updated?: boolean
    created?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dNS"]>

  export type DNSSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    website?: boolean
    tags?: boolean
    description?: boolean
    updated?: boolean
    created?: boolean
  }

  export type DNSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DNSIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DNSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DNS"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      computerId: string
      gameId: string
      website: string
      tags: string
      description: string
      updated: Date
      created: Date
    }, ExtArgs["result"]["dNS"]>
    composites: {}
  }

  type DNSGetPayload<S extends boolean | null | undefined | DNSDefaultArgs> = $Result.GetResult<Prisma.$DNSPayload, S>

  type DNSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DNSFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DNSCountAggregateInputType | true
    }

  export interface DNSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DNS'], meta: { name: 'DNS' } }
    /**
     * Find zero or one DNS that matches the filter.
     * @param {DNSFindUniqueArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DNSFindUniqueArgs>(args: SelectSubset<T, DNSFindUniqueArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DNS that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DNSFindUniqueOrThrowArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DNSFindUniqueOrThrowArgs>(args: SelectSubset<T, DNSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSFindFirstArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DNSFindFirstArgs>(args?: SelectSubset<T, DNSFindFirstArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DNS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSFindFirstOrThrowArgs} args - Arguments to find a DNS
     * @example
     * // Get one DNS
     * const dNS = await prisma.dNS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DNSFindFirstOrThrowArgs>(args?: SelectSubset<T, DNSFindFirstOrThrowArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DNS
     * const dNS = await prisma.dNS.findMany()
     * 
     * // Get first 10 DNS
     * const dNS = await prisma.dNS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dNSWithIdOnly = await prisma.dNS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DNSFindManyArgs>(args?: SelectSubset<T, DNSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DNS.
     * @param {DNSCreateArgs} args - Arguments to create a DNS.
     * @example
     * // Create one DNS
     * const DNS = await prisma.dNS.create({
     *   data: {
     *     // ... data to create a DNS
     *   }
     * })
     * 
     */
    create<T extends DNSCreateArgs>(args: SelectSubset<T, DNSCreateArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DNS.
     * @param {DNSCreateManyArgs} args - Arguments to create many DNS.
     * @example
     * // Create many DNS
     * const dNS = await prisma.dNS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DNSCreateManyArgs>(args?: SelectSubset<T, DNSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DNS and returns the data saved in the database.
     * @param {DNSCreateManyAndReturnArgs} args - Arguments to create many DNS.
     * @example
     * // Create many DNS
     * const dNS = await prisma.dNS.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DNS and only return the `id`
     * const dNSWithIdOnly = await prisma.dNS.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DNSCreateManyAndReturnArgs>(args?: SelectSubset<T, DNSCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DNS.
     * @param {DNSDeleteArgs} args - Arguments to delete one DNS.
     * @example
     * // Delete one DNS
     * const DNS = await prisma.dNS.delete({
     *   where: {
     *     // ... filter to delete one DNS
     *   }
     * })
     * 
     */
    delete<T extends DNSDeleteArgs>(args: SelectSubset<T, DNSDeleteArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DNS.
     * @param {DNSUpdateArgs} args - Arguments to update one DNS.
     * @example
     * // Update one DNS
     * const dNS = await prisma.dNS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DNSUpdateArgs>(args: SelectSubset<T, DNSUpdateArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DNS.
     * @param {DNSDeleteManyArgs} args - Arguments to filter DNS to delete.
     * @example
     * // Delete a few DNS
     * const { count } = await prisma.dNS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DNSDeleteManyArgs>(args?: SelectSubset<T, DNSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DNS
     * const dNS = await prisma.dNS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DNSUpdateManyArgs>(args: SelectSubset<T, DNSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DNS.
     * @param {DNSUpsertArgs} args - Arguments to update or create a DNS.
     * @example
     * // Update or create a DNS
     * const dNS = await prisma.dNS.upsert({
     *   create: {
     *     // ... data to create a DNS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DNS we want to update
     *   }
     * })
     */
    upsert<T extends DNSUpsertArgs>(args: SelectSubset<T, DNSUpsertArgs<ExtArgs>>): Prisma__DNSClient<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSCountArgs} args - Arguments to filter DNS to count.
     * @example
     * // Count the number of DNS
     * const count = await prisma.dNS.count({
     *   where: {
     *     // ... the filter for the DNS we want to count
     *   }
     * })
    **/
    count<T extends DNSCountArgs>(
      args?: Subset<T, DNSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DNSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DNSAggregateArgs>(args: Subset<T, DNSAggregateArgs>): Prisma.PrismaPromise<GetDNSAggregateType<T>>

    /**
     * Group by DNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DNSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DNSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DNSGroupByArgs['orderBy'] }
        : { orderBy?: DNSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DNSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDNSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DNS model
   */
  readonly fields: DNSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DNS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DNSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DNS model
   */ 
  interface DNSFieldRefs {
    readonly id: FieldRef<"DNS", 'Int'>
    readonly userId: FieldRef<"DNS", 'Int'>
    readonly computerId: FieldRef<"DNS", 'String'>
    readonly gameId: FieldRef<"DNS", 'String'>
    readonly website: FieldRef<"DNS", 'String'>
    readonly tags: FieldRef<"DNS", 'String'>
    readonly description: FieldRef<"DNS", 'String'>
    readonly updated: FieldRef<"DNS", 'DateTime'>
    readonly created: FieldRef<"DNS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DNS findUnique
   */
  export type DNSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where: DNSWhereUniqueInput
  }

  /**
   * DNS findUniqueOrThrow
   */
  export type DNSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where: DNSWhereUniqueInput
  }

  /**
   * DNS findFirst
   */
  export type DNSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DNS.
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DNS.
     */
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }

  /**
   * DNS findFirstOrThrow
   */
  export type DNSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DNS.
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DNS.
     */
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }

  /**
   * DNS findMany
   */
  export type DNSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter, which DNS to fetch.
     */
    where?: DNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DNS to fetch.
     */
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DNS.
     */
    cursor?: DNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DNS.
     */
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }

  /**
   * DNS create
   */
  export type DNSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * The data needed to create a DNS.
     */
    data: XOR<DNSCreateInput, DNSUncheckedCreateInput>
  }

  /**
   * DNS createMany
   */
  export type DNSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DNS.
     */
    data: DNSCreateManyInput | DNSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DNS createManyAndReturn
   */
  export type DNSCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DNS.
     */
    data: DNSCreateManyInput | DNSCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DNS update
   */
  export type DNSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * The data needed to update a DNS.
     */
    data: XOR<DNSUpdateInput, DNSUncheckedUpdateInput>
    /**
     * Choose, which DNS to update.
     */
    where: DNSWhereUniqueInput
  }

  /**
   * DNS updateMany
   */
  export type DNSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DNS.
     */
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyInput>
    /**
     * Filter which DNS to update
     */
    where?: DNSWhereInput
  }

  /**
   * DNS upsert
   */
  export type DNSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * The filter to search for the DNS to update in case it exists.
     */
    where: DNSWhereUniqueInput
    /**
     * In case the DNS found by the `where` argument doesn't exist, create a new DNS with this data.
     */
    create: XOR<DNSCreateInput, DNSUncheckedCreateInput>
    /**
     * In case the DNS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DNSUpdateInput, DNSUncheckedUpdateInput>
  }

  /**
   * DNS delete
   */
  export type DNSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    /**
     * Filter which DNS to delete.
     */
    where: DNSWhereUniqueInput
  }

  /**
   * DNS deleteMany
   */
  export type DNSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DNS to delete
     */
    where?: DNSWhereInput
  }

  /**
   * DNS without action
   */
  export type DNSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
  }


  /**
   * Model AccountBook
   */

  export type AggregateAccountBook = {
    _count: AccountBookCountAggregateOutputType | null
    _avg: AccountBookAvgAggregateOutputType | null
    _sum: AccountBookSumAggregateOutputType | null
    _min: AccountBookMinAggregateOutputType | null
    _max: AccountBookMaxAggregateOutputType | null
  }

  export type AccountBookAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccountBookSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccountBookMinAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    memoryId: string | null
    gameId: string | null
  }

  export type AccountBookMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    memoryId: string | null
    gameId: string | null
  }

  export type AccountBookCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    memoryId: number
    data: number
    gameId: number
    _all: number
  }


  export type AccountBookAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountBookSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountBookMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    memoryId?: true
    gameId?: true
  }

  export type AccountBookMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    memoryId?: true
    gameId?: true
  }

  export type AccountBookCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    memoryId?: true
    data?: true
    gameId?: true
    _all?: true
  }

  export type AccountBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBook to aggregate.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountBooks
    **/
    _count?: true | AccountBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountBookMaxAggregateInputType
  }

  export type GetAccountBookAggregateType<T extends AccountBookAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountBook[P]>
      : GetScalarType<T[P], AggregateAccountBook[P]>
  }




  export type AccountBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithAggregationInput | AccountBookOrderByWithAggregationInput[]
    by: AccountBookScalarFieldEnum[] | AccountBookScalarFieldEnum
    having?: AccountBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountBookCountAggregateInputType | true
    _avg?: AccountBookAvgAggregateInputType
    _sum?: AccountBookSumAggregateInputType
    _min?: AccountBookMinAggregateInputType
    _max?: AccountBookMaxAggregateInputType
  }

  export type AccountBookGroupByOutputType = {
    id: number
    userId: number
    computerId: string
    memoryId: string
    data: JsonValue
    gameId: string
    _count: AccountBookCountAggregateOutputType | null
    _avg: AccountBookAvgAggregateOutputType | null
    _sum: AccountBookSumAggregateOutputType | null
    _min: AccountBookMinAggregateOutputType | null
    _max: AccountBookMaxAggregateOutputType | null
  }

  type GetAccountBookGroupByPayload<T extends AccountBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountBookGroupByOutputType[P]>
            : GetScalarType<T[P], AccountBookGroupByOutputType[P]>
        }
      >
    >


  export type AccountBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    memoryId?: boolean
    data?: boolean
    gameId?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    memory?: boolean | MemoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountBook"]>

  export type AccountBookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    memoryId?: boolean
    data?: boolean
    gameId?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    memory?: boolean | MemoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountBook"]>

  export type AccountBookSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    memoryId?: boolean
    data?: boolean
    gameId?: boolean
  }

  export type AccountBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    memory?: boolean | MemoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountBookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    memory?: boolean | MemoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountBook"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      memory: Prisma.$MemoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      computerId: string
      memoryId: string
      data: Prisma.JsonValue
      gameId: string
    }, ExtArgs["result"]["accountBook"]>
    composites: {}
  }

  type AccountBookGetPayload<S extends boolean | null | undefined | AccountBookDefaultArgs> = $Result.GetResult<Prisma.$AccountBookPayload, S>

  type AccountBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountBookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountBookCountAggregateInputType | true
    }

  export interface AccountBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountBook'], meta: { name: 'AccountBook' } }
    /**
     * Find zero or one AccountBook that matches the filter.
     * @param {AccountBookFindUniqueArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountBookFindUniqueArgs>(args: SelectSubset<T, AccountBookFindUniqueArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountBook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountBookFindUniqueOrThrowArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountBookFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookFindFirstArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountBookFindFirstArgs>(args?: SelectSubset<T, AccountBookFindFirstArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookFindFirstOrThrowArgs} args - Arguments to find a AccountBook
     * @example
     * // Get one AccountBook
     * const accountBook = await prisma.accountBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountBookFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountBooks
     * const accountBooks = await prisma.accountBook.findMany()
     * 
     * // Get first 10 AccountBooks
     * const accountBooks = await prisma.accountBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountBookWithIdOnly = await prisma.accountBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountBookFindManyArgs>(args?: SelectSubset<T, AccountBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountBook.
     * @param {AccountBookCreateArgs} args - Arguments to create a AccountBook.
     * @example
     * // Create one AccountBook
     * const AccountBook = await prisma.accountBook.create({
     *   data: {
     *     // ... data to create a AccountBook
     *   }
     * })
     * 
     */
    create<T extends AccountBookCreateArgs>(args: SelectSubset<T, AccountBookCreateArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountBooks.
     * @param {AccountBookCreateManyArgs} args - Arguments to create many AccountBooks.
     * @example
     * // Create many AccountBooks
     * const accountBook = await prisma.accountBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountBookCreateManyArgs>(args?: SelectSubset<T, AccountBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountBooks and returns the data saved in the database.
     * @param {AccountBookCreateManyAndReturnArgs} args - Arguments to create many AccountBooks.
     * @example
     * // Create many AccountBooks
     * const accountBook = await prisma.accountBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountBooks and only return the `id`
     * const accountBookWithIdOnly = await prisma.accountBook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountBookCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountBookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountBook.
     * @param {AccountBookDeleteArgs} args - Arguments to delete one AccountBook.
     * @example
     * // Delete one AccountBook
     * const AccountBook = await prisma.accountBook.delete({
     *   where: {
     *     // ... filter to delete one AccountBook
     *   }
     * })
     * 
     */
    delete<T extends AccountBookDeleteArgs>(args: SelectSubset<T, AccountBookDeleteArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountBook.
     * @param {AccountBookUpdateArgs} args - Arguments to update one AccountBook.
     * @example
     * // Update one AccountBook
     * const accountBook = await prisma.accountBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountBookUpdateArgs>(args: SelectSubset<T, AccountBookUpdateArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountBooks.
     * @param {AccountBookDeleteManyArgs} args - Arguments to filter AccountBooks to delete.
     * @example
     * // Delete a few AccountBooks
     * const { count } = await prisma.accountBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountBookDeleteManyArgs>(args?: SelectSubset<T, AccountBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountBooks
     * const accountBook = await prisma.accountBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountBookUpdateManyArgs>(args: SelectSubset<T, AccountBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountBook.
     * @param {AccountBookUpsertArgs} args - Arguments to update or create a AccountBook.
     * @example
     * // Update or create a AccountBook
     * const accountBook = await prisma.accountBook.upsert({
     *   create: {
     *     // ... data to create a AccountBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountBook we want to update
     *   }
     * })
     */
    upsert<T extends AccountBookUpsertArgs>(args: SelectSubset<T, AccountBookUpsertArgs<ExtArgs>>): Prisma__AccountBookClient<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookCountArgs} args - Arguments to filter AccountBooks to count.
     * @example
     * // Count the number of AccountBooks
     * const count = await prisma.accountBook.count({
     *   where: {
     *     // ... the filter for the AccountBooks we want to count
     *   }
     * })
    **/
    count<T extends AccountBookCountArgs>(
      args?: Subset<T, AccountBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountBookAggregateArgs>(args: Subset<T, AccountBookAggregateArgs>): Prisma.PrismaPromise<GetAccountBookAggregateType<T>>

    /**
     * Group by AccountBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountBookGroupByArgs['orderBy'] }
        : { orderBy?: AccountBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountBook model
   */
  readonly fields: AccountBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    memory<T extends MemoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemoryDefaultArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountBook model
   */ 
  interface AccountBookFieldRefs {
    readonly id: FieldRef<"AccountBook", 'Int'>
    readonly userId: FieldRef<"AccountBook", 'Int'>
    readonly computerId: FieldRef<"AccountBook", 'String'>
    readonly memoryId: FieldRef<"AccountBook", 'String'>
    readonly data: FieldRef<"AccountBook", 'Json'>
    readonly gameId: FieldRef<"AccountBook", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccountBook findUnique
   */
  export type AccountBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where: AccountBookWhereUniqueInput
  }

  /**
   * AccountBook findUniqueOrThrow
   */
  export type AccountBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where: AccountBookWhereUniqueInput
  }

  /**
   * AccountBook findFirst
   */
  export type AccountBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBooks.
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBooks.
     */
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }

  /**
   * AccountBook findFirstOrThrow
   */
  export type AccountBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBook to fetch.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBooks.
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBooks.
     */
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }

  /**
   * AccountBook findMany
   */
  export type AccountBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter, which AccountBooks to fetch.
     */
    where?: AccountBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBooks to fetch.
     */
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountBooks.
     */
    cursor?: AccountBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBooks.
     */
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }

  /**
   * AccountBook create
   */
  export type AccountBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountBook.
     */
    data: XOR<AccountBookCreateInput, AccountBookUncheckedCreateInput>
  }

  /**
   * AccountBook createMany
   */
  export type AccountBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountBooks.
     */
    data: AccountBookCreateManyInput | AccountBookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountBook createManyAndReturn
   */
  export type AccountBookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountBooks.
     */
    data: AccountBookCreateManyInput | AccountBookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountBook update
   */
  export type AccountBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountBook.
     */
    data: XOR<AccountBookUpdateInput, AccountBookUncheckedUpdateInput>
    /**
     * Choose, which AccountBook to update.
     */
    where: AccountBookWhereUniqueInput
  }

  /**
   * AccountBook updateMany
   */
  export type AccountBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountBooks.
     */
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyInput>
    /**
     * Filter which AccountBooks to update
     */
    where?: AccountBookWhereInput
  }

  /**
   * AccountBook upsert
   */
  export type AccountBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountBook to update in case it exists.
     */
    where: AccountBookWhereUniqueInput
    /**
     * In case the AccountBook found by the `where` argument doesn't exist, create a new AccountBook with this data.
     */
    create: XOR<AccountBookCreateInput, AccountBookUncheckedCreateInput>
    /**
     * In case the AccountBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountBookUpdateInput, AccountBookUncheckedUpdateInput>
  }

  /**
   * AccountBook delete
   */
  export type AccountBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    /**
     * Filter which AccountBook to delete.
     */
    where: AccountBookWhereUniqueInput
  }

  /**
   * AccountBook deleteMany
   */
  export type AccountBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBooks to delete
     */
    where?: AccountBookWhereInput
  }

  /**
   * AccountBook without action
   */
  export type AccountBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    gameId: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    data: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    data?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: number
    userId: number
    gameId: string
    data: JsonValue
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    data?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    data?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    data?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      gameId: string
      data: Prisma.JsonValue
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'Int'>
    readonly userId: FieldRef<"Profile", 'Int'>
    readonly gameId: FieldRef<"Profile", 'String'>
    readonly data: FieldRef<"Profile", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Memory
   */

  export type AggregateMemory = {
    _count: MemoryCountAggregateOutputType | null
    _avg: MemoryAvgAggregateOutputType | null
    _sum: MemorySumAggregateOutputType | null
    _min: MemoryMinAggregateOutputType | null
    _max: MemoryMaxAggregateOutputType | null
  }

  export type MemoryAvgAggregateOutputType = {
    userId: number | null
    value: number | null
  }

  export type MemorySumAggregateOutputType = {
    userId: number | null
    value: number | null
  }

  export type MemoryMinAggregateOutputType = {
    id: string | null
    computerId: string | null
    gameId: string | null
    userId: number | null
    type: string | null
    key: string | null
    value: number | null
  }

  export type MemoryMaxAggregateOutputType = {
    id: string | null
    computerId: string | null
    gameId: string | null
    userId: number | null
    type: string | null
    key: string | null
    value: number | null
  }

  export type MemoryCountAggregateOutputType = {
    id: number
    computerId: number
    gameId: number
    userId: number
    type: number
    key: number
    value: number
    data: number
    _all: number
  }


  export type MemoryAvgAggregateInputType = {
    userId?: true
    value?: true
  }

  export type MemorySumAggregateInputType = {
    userId?: true
    value?: true
  }

  export type MemoryMinAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    userId?: true
    type?: true
    key?: true
    value?: true
  }

  export type MemoryMaxAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    userId?: true
    type?: true
    key?: true
    value?: true
  }

  export type MemoryCountAggregateInputType = {
    id?: true
    computerId?: true
    gameId?: true
    userId?: true
    type?: true
    key?: true
    value?: true
    data?: true
    _all?: true
  }

  export type MemoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memory to aggregate.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memories
    **/
    _count?: true | MemoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemoryMaxAggregateInputType
  }

  export type GetMemoryAggregateType<T extends MemoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMemory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemory[P]>
      : GetScalarType<T[P], AggregateMemory[P]>
  }




  export type MemoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithAggregationInput | MemoryOrderByWithAggregationInput[]
    by: MemoryScalarFieldEnum[] | MemoryScalarFieldEnum
    having?: MemoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemoryCountAggregateInputType | true
    _avg?: MemoryAvgAggregateInputType
    _sum?: MemorySumAggregateInputType
    _min?: MemoryMinAggregateInputType
    _max?: MemoryMaxAggregateInputType
  }

  export type MemoryGroupByOutputType = {
    id: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value: number | null
    data: JsonValue
    _count: MemoryCountAggregateOutputType | null
    _avg: MemoryAvgAggregateOutputType | null
    _sum: MemorySumAggregateOutputType | null
    _min: MemoryMinAggregateOutputType | null
    _max: MemoryMaxAggregateOutputType | null
  }

  type GetMemoryGroupByPayload<T extends MemoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemoryGroupByOutputType[P]>
            : GetScalarType<T[P], MemoryGroupByOutputType[P]>
        }
      >
    >


  export type MemorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    data?: boolean
    accountBook?: boolean | Memory$accountBookArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MemoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memory"]>

  export type MemorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    data?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memory"]>

  export type MemorySelectScalar = {
    id?: boolean
    computerId?: boolean
    gameId?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    data?: boolean
  }

  export type MemoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | Memory$accountBookArgs<ExtArgs>
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MemoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Memory"
    objects: {
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      computerId: string
      gameId: string
      userId: number
      type: string
      key: string
      value: number | null
      data: Prisma.JsonValue
    }, ExtArgs["result"]["memory"]>
    composites: {}
  }

  type MemoryGetPayload<S extends boolean | null | undefined | MemoryDefaultArgs> = $Result.GetResult<Prisma.$MemoryPayload, S>

  type MemoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemoryCountAggregateInputType | true
    }

  export interface MemoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Memory'], meta: { name: 'Memory' } }
    /**
     * Find zero or one Memory that matches the filter.
     * @param {MemoryFindUniqueArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemoryFindUniqueArgs>(args: SelectSubset<T, MemoryFindUniqueArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Memory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MemoryFindUniqueOrThrowArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MemoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Memory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryFindFirstArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemoryFindFirstArgs>(args?: SelectSubset<T, MemoryFindFirstArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Memory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryFindFirstOrThrowArgs} args - Arguments to find a Memory
     * @example
     * // Get one Memory
     * const memory = await prisma.memory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MemoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Memories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memories
     * const memories = await prisma.memory.findMany()
     * 
     * // Get first 10 Memories
     * const memories = await prisma.memory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memoryWithIdOnly = await prisma.memory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemoryFindManyArgs>(args?: SelectSubset<T, MemoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Memory.
     * @param {MemoryCreateArgs} args - Arguments to create a Memory.
     * @example
     * // Create one Memory
     * const Memory = await prisma.memory.create({
     *   data: {
     *     // ... data to create a Memory
     *   }
     * })
     * 
     */
    create<T extends MemoryCreateArgs>(args: SelectSubset<T, MemoryCreateArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Memories.
     * @param {MemoryCreateManyArgs} args - Arguments to create many Memories.
     * @example
     * // Create many Memories
     * const memory = await prisma.memory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemoryCreateManyArgs>(args?: SelectSubset<T, MemoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memories and returns the data saved in the database.
     * @param {MemoryCreateManyAndReturnArgs} args - Arguments to create many Memories.
     * @example
     * // Create many Memories
     * const memory = await prisma.memory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memories and only return the `id`
     * const memoryWithIdOnly = await prisma.memory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MemoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Memory.
     * @param {MemoryDeleteArgs} args - Arguments to delete one Memory.
     * @example
     * // Delete one Memory
     * const Memory = await prisma.memory.delete({
     *   where: {
     *     // ... filter to delete one Memory
     *   }
     * })
     * 
     */
    delete<T extends MemoryDeleteArgs>(args: SelectSubset<T, MemoryDeleteArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Memory.
     * @param {MemoryUpdateArgs} args - Arguments to update one Memory.
     * @example
     * // Update one Memory
     * const memory = await prisma.memory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemoryUpdateArgs>(args: SelectSubset<T, MemoryUpdateArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Memories.
     * @param {MemoryDeleteManyArgs} args - Arguments to filter Memories to delete.
     * @example
     * // Delete a few Memories
     * const { count } = await prisma.memory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemoryDeleteManyArgs>(args?: SelectSubset<T, MemoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memories
     * const memory = await prisma.memory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemoryUpdateManyArgs>(args: SelectSubset<T, MemoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Memory.
     * @param {MemoryUpsertArgs} args - Arguments to update or create a Memory.
     * @example
     * // Update or create a Memory
     * const memory = await prisma.memory.upsert({
     *   create: {
     *     // ... data to create a Memory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Memory we want to update
     *   }
     * })
     */
    upsert<T extends MemoryUpsertArgs>(args: SelectSubset<T, MemoryUpsertArgs<ExtArgs>>): Prisma__MemoryClient<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryCountArgs} args - Arguments to filter Memories to count.
     * @example
     * // Count the number of Memories
     * const count = await prisma.memory.count({
     *   where: {
     *     // ... the filter for the Memories we want to count
     *   }
     * })
    **/
    count<T extends MemoryCountArgs>(
      args?: Subset<T, MemoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemoryAggregateArgs>(args: Subset<T, MemoryAggregateArgs>): Prisma.PrismaPromise<GetMemoryAggregateType<T>>

    /**
     * Group by Memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemoryGroupByArgs['orderBy'] }
        : { orderBy?: MemoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Memory model
   */
  readonly fields: MemoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Memory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountBook<T extends Memory$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, Memory$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findMany"> | Null>
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Memory model
   */ 
  interface MemoryFieldRefs {
    readonly id: FieldRef<"Memory", 'String'>
    readonly computerId: FieldRef<"Memory", 'String'>
    readonly gameId: FieldRef<"Memory", 'String'>
    readonly userId: FieldRef<"Memory", 'Int'>
    readonly type: FieldRef<"Memory", 'String'>
    readonly key: FieldRef<"Memory", 'String'>
    readonly value: FieldRef<"Memory", 'Float'>
    readonly data: FieldRef<"Memory", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Memory findUnique
   */
  export type MemoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where: MemoryWhereUniqueInput
  }

  /**
   * Memory findUniqueOrThrow
   */
  export type MemoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where: MemoryWhereUniqueInput
  }

  /**
   * Memory findFirst
   */
  export type MemoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memories.
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memories.
     */
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }

  /**
   * Memory findFirstOrThrow
   */
  export type MemoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memory to fetch.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memories.
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memories.
     */
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }

  /**
   * Memory findMany
   */
  export type MemoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter, which Memories to fetch.
     */
    where?: MemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memories to fetch.
     */
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memories.
     */
    cursor?: MemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memories.
     */
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }

  /**
   * Memory create
   */
  export type MemoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Memory.
     */
    data: XOR<MemoryCreateInput, MemoryUncheckedCreateInput>
  }

  /**
   * Memory createMany
   */
  export type MemoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memories.
     */
    data: MemoryCreateManyInput | MemoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Memory createManyAndReturn
   */
  export type MemoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Memories.
     */
    data: MemoryCreateManyInput | MemoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Memory update
   */
  export type MemoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Memory.
     */
    data: XOR<MemoryUpdateInput, MemoryUncheckedUpdateInput>
    /**
     * Choose, which Memory to update.
     */
    where: MemoryWhereUniqueInput
  }

  /**
   * Memory updateMany
   */
  export type MemoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memories.
     */
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyInput>
    /**
     * Filter which Memories to update
     */
    where?: MemoryWhereInput
  }

  /**
   * Memory upsert
   */
  export type MemoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Memory to update in case it exists.
     */
    where: MemoryWhereUniqueInput
    /**
     * In case the Memory found by the `where` argument doesn't exist, create a new Memory with this data.
     */
    create: XOR<MemoryCreateInput, MemoryUncheckedCreateInput>
    /**
     * In case the Memory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemoryUpdateInput, MemoryUncheckedUpdateInput>
  }

  /**
   * Memory delete
   */
  export type MemoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    /**
     * Filter which Memory to delete.
     */
    where: MemoryWhereUniqueInput
  }

  /**
   * Memory deleteMany
   */
  export type MemoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memories to delete
     */
    where?: MemoryWhereInput
  }

  /**
   * Memory.accountBook
   */
  export type Memory$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }

  /**
   * Memory without action
   */
  export type MemoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
  }


  /**
   * Model Computer
   */

  export type AggregateComputer = {
    _count: ComputerCountAggregateOutputType | null
    _avg: ComputerAvgAggregateOutputType | null
    _sum: ComputerSumAggregateOutputType | null
    _min: ComputerMinAggregateOutputType | null
    _max: ComputerMaxAggregateOutputType | null
  }

  export type ComputerAvgAggregateOutputType = {
    userId: number | null
  }

  export type ComputerSumAggregateOutputType = {
    userId: number | null
  }

  export type ComputerMinAggregateOutputType = {
    id: string | null
    userId: number | null
    type: string | null
    gameId: string | null
    ip: string | null
    created: Date | null
    updated: Date | null
  }

  export type ComputerMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    type: string | null
    gameId: string | null
    ip: string | null
    created: Date | null
    updated: Date | null
  }

  export type ComputerCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    gameId: number
    ip: number
    data: number
    created: number
    updated: number
    _all: number
  }


  export type ComputerAvgAggregateInputType = {
    userId?: true
  }

  export type ComputerSumAggregateInputType = {
    userId?: true
  }

  export type ComputerMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    gameId?: true
    ip?: true
    created?: true
    updated?: true
  }

  export type ComputerMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    gameId?: true
    ip?: true
    created?: true
    updated?: true
  }

  export type ComputerCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    gameId?: true
    ip?: true
    data?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type ComputerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Computer to aggregate.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Computers
    **/
    _count?: true | ComputerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComputerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComputerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComputerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComputerMaxAggregateInputType
  }

  export type GetComputerAggregateType<T extends ComputerAggregateArgs> = {
        [P in keyof T & keyof AggregateComputer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComputer[P]>
      : GetScalarType<T[P], AggregateComputer[P]>
  }




  export type ComputerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComputerWhereInput
    orderBy?: ComputerOrderByWithAggregationInput | ComputerOrderByWithAggregationInput[]
    by: ComputerScalarFieldEnum[] | ComputerScalarFieldEnum
    having?: ComputerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComputerCountAggregateInputType | true
    _avg?: ComputerAvgAggregateInputType
    _sum?: ComputerSumAggregateInputType
    _min?: ComputerMinAggregateInputType
    _max?: ComputerMaxAggregateInputType
  }

  export type ComputerGroupByOutputType = {
    id: string
    userId: number
    type: string
    gameId: string
    ip: string
    data: JsonValue
    created: Date
    updated: Date
    _count: ComputerCountAggregateOutputType | null
    _avg: ComputerAvgAggregateOutputType | null
    _sum: ComputerSumAggregateOutputType | null
    _min: ComputerMinAggregateOutputType | null
    _max: ComputerMaxAggregateOutputType | null
  }

  type GetComputerGroupByPayload<T extends ComputerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComputerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComputerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComputerGroupByOutputType[P]>
            : GetScalarType<T[P], ComputerGroupByOutputType[P]>
        }
      >
    >


  export type ComputerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    gameId?: boolean
    ip?: boolean
    data?: boolean
    created?: boolean
    updated?: boolean
    accountBook?: boolean | Computer$accountBookArgs<ExtArgs>
    addressBook?: boolean | Computer$addressBookArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dns?: boolean | Computer$dnsArgs<ExtArgs>
    hardware?: boolean | Computer$hardwareArgs<ExtArgs>
    logs?: boolean | Computer$logsArgs<ExtArgs>
    memory?: boolean | Computer$memoryArgs<ExtArgs>
    process?: boolean | Computer$processArgs<ExtArgs>
    software?: boolean | Computer$softwareArgs<ExtArgs>
    _count?: boolean | ComputerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["computer"]>

  export type ComputerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    gameId?: boolean
    ip?: boolean
    data?: boolean
    created?: boolean
    updated?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["computer"]>

  export type ComputerSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    gameId?: boolean
    ip?: boolean
    data?: boolean
    created?: boolean
    updated?: boolean
  }

  export type ComputerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBook?: boolean | Computer$accountBookArgs<ExtArgs>
    addressBook?: boolean | Computer$addressBookArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dns?: boolean | Computer$dnsArgs<ExtArgs>
    hardware?: boolean | Computer$hardwareArgs<ExtArgs>
    logs?: boolean | Computer$logsArgs<ExtArgs>
    memory?: boolean | Computer$memoryArgs<ExtArgs>
    process?: boolean | Computer$processArgs<ExtArgs>
    software?: boolean | Computer$softwareArgs<ExtArgs>
    _count?: boolean | ComputerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComputerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComputerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Computer"
    objects: {
      accountBook: Prisma.$AccountBookPayload<ExtArgs>[]
      addressBook: Prisma.$AddressBookPayload<ExtArgs>[]
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      dns: Prisma.$DNSPayload<ExtArgs>[]
      hardware: Prisma.$HardwarePayload<ExtArgs>[]
      logs: Prisma.$LogsPayload<ExtArgs>[]
      memory: Prisma.$MemoryPayload<ExtArgs>[]
      process: Prisma.$ProcessPayload<ExtArgs>[]
      software: Prisma.$SoftwarePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      type: string
      gameId: string
      ip: string
      data: Prisma.JsonValue
      created: Date
      updated: Date
    }, ExtArgs["result"]["computer"]>
    composites: {}
  }

  type ComputerGetPayload<S extends boolean | null | undefined | ComputerDefaultArgs> = $Result.GetResult<Prisma.$ComputerPayload, S>

  type ComputerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComputerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComputerCountAggregateInputType | true
    }

  export interface ComputerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Computer'], meta: { name: 'Computer' } }
    /**
     * Find zero or one Computer that matches the filter.
     * @param {ComputerFindUniqueArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComputerFindUniqueArgs>(args: SelectSubset<T, ComputerFindUniqueArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Computer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComputerFindUniqueOrThrowArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComputerFindUniqueOrThrowArgs>(args: SelectSubset<T, ComputerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Computer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerFindFirstArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComputerFindFirstArgs>(args?: SelectSubset<T, ComputerFindFirstArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Computer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerFindFirstOrThrowArgs} args - Arguments to find a Computer
     * @example
     * // Get one Computer
     * const computer = await prisma.computer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComputerFindFirstOrThrowArgs>(args?: SelectSubset<T, ComputerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Computers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Computers
     * const computers = await prisma.computer.findMany()
     * 
     * // Get first 10 Computers
     * const computers = await prisma.computer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const computerWithIdOnly = await prisma.computer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComputerFindManyArgs>(args?: SelectSubset<T, ComputerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Computer.
     * @param {ComputerCreateArgs} args - Arguments to create a Computer.
     * @example
     * // Create one Computer
     * const Computer = await prisma.computer.create({
     *   data: {
     *     // ... data to create a Computer
     *   }
     * })
     * 
     */
    create<T extends ComputerCreateArgs>(args: SelectSubset<T, ComputerCreateArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Computers.
     * @param {ComputerCreateManyArgs} args - Arguments to create many Computers.
     * @example
     * // Create many Computers
     * const computer = await prisma.computer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComputerCreateManyArgs>(args?: SelectSubset<T, ComputerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Computers and returns the data saved in the database.
     * @param {ComputerCreateManyAndReturnArgs} args - Arguments to create many Computers.
     * @example
     * // Create many Computers
     * const computer = await prisma.computer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Computers and only return the `id`
     * const computerWithIdOnly = await prisma.computer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComputerCreateManyAndReturnArgs>(args?: SelectSubset<T, ComputerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Computer.
     * @param {ComputerDeleteArgs} args - Arguments to delete one Computer.
     * @example
     * // Delete one Computer
     * const Computer = await prisma.computer.delete({
     *   where: {
     *     // ... filter to delete one Computer
     *   }
     * })
     * 
     */
    delete<T extends ComputerDeleteArgs>(args: SelectSubset<T, ComputerDeleteArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Computer.
     * @param {ComputerUpdateArgs} args - Arguments to update one Computer.
     * @example
     * // Update one Computer
     * const computer = await prisma.computer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComputerUpdateArgs>(args: SelectSubset<T, ComputerUpdateArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Computers.
     * @param {ComputerDeleteManyArgs} args - Arguments to filter Computers to delete.
     * @example
     * // Delete a few Computers
     * const { count } = await prisma.computer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComputerDeleteManyArgs>(args?: SelectSubset<T, ComputerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Computers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Computers
     * const computer = await prisma.computer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComputerUpdateManyArgs>(args: SelectSubset<T, ComputerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Computer.
     * @param {ComputerUpsertArgs} args - Arguments to update or create a Computer.
     * @example
     * // Update or create a Computer
     * const computer = await prisma.computer.upsert({
     *   create: {
     *     // ... data to create a Computer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Computer we want to update
     *   }
     * })
     */
    upsert<T extends ComputerUpsertArgs>(args: SelectSubset<T, ComputerUpsertArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Computers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerCountArgs} args - Arguments to filter Computers to count.
     * @example
     * // Count the number of Computers
     * const count = await prisma.computer.count({
     *   where: {
     *     // ... the filter for the Computers we want to count
     *   }
     * })
    **/
    count<T extends ComputerCountArgs>(
      args?: Subset<T, ComputerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComputerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Computer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComputerAggregateArgs>(args: Subset<T, ComputerAggregateArgs>): Prisma.PrismaPromise<GetComputerAggregateType<T>>

    /**
     * Group by Computer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComputerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComputerGroupByArgs['orderBy'] }
        : { orderBy?: ComputerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComputerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComputerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Computer model
   */
  readonly fields: ComputerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Computer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComputerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountBook<T extends Computer$accountBookArgs<ExtArgs> = {}>(args?: Subset<T, Computer$accountBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBookPayload<ExtArgs>, T, "findMany"> | Null>
    addressBook<T extends Computer$addressBookArgs<ExtArgs> = {}>(args?: Subset<T, Computer$addressBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressBookPayload<ExtArgs>, T, "findMany"> | Null>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dns<T extends Computer$dnsArgs<ExtArgs> = {}>(args?: Subset<T, Computer$dnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DNSPayload<ExtArgs>, T, "findMany"> | Null>
    hardware<T extends Computer$hardwareArgs<ExtArgs> = {}>(args?: Subset<T, Computer$hardwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HardwarePayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Computer$logsArgs<ExtArgs> = {}>(args?: Subset<T, Computer$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany"> | Null>
    memory<T extends Computer$memoryArgs<ExtArgs> = {}>(args?: Subset<T, Computer$memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemoryPayload<ExtArgs>, T, "findMany"> | Null>
    process<T extends Computer$processArgs<ExtArgs> = {}>(args?: Subset<T, Computer$processArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany"> | Null>
    software<T extends Computer$softwareArgs<ExtArgs> = {}>(args?: Subset<T, Computer$softwareArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Computer model
   */ 
  interface ComputerFieldRefs {
    readonly id: FieldRef<"Computer", 'String'>
    readonly userId: FieldRef<"Computer", 'Int'>
    readonly type: FieldRef<"Computer", 'String'>
    readonly gameId: FieldRef<"Computer", 'String'>
    readonly ip: FieldRef<"Computer", 'String'>
    readonly data: FieldRef<"Computer", 'Json'>
    readonly created: FieldRef<"Computer", 'DateTime'>
    readonly updated: FieldRef<"Computer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Computer findUnique
   */
  export type ComputerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where: ComputerWhereUniqueInput
  }

  /**
   * Computer findUniqueOrThrow
   */
  export type ComputerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where: ComputerWhereUniqueInput
  }

  /**
   * Computer findFirst
   */
  export type ComputerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Computers.
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Computers.
     */
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }

  /**
   * Computer findFirstOrThrow
   */
  export type ComputerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computer to fetch.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Computers.
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Computers.
     */
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }

  /**
   * Computer findMany
   */
  export type ComputerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter, which Computers to fetch.
     */
    where?: ComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Computers to fetch.
     */
    orderBy?: ComputerOrderByWithRelationInput | ComputerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Computers.
     */
    cursor?: ComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Computers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Computers.
     */
    skip?: number
    distinct?: ComputerScalarFieldEnum | ComputerScalarFieldEnum[]
  }

  /**
   * Computer create
   */
  export type ComputerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * The data needed to create a Computer.
     */
    data: XOR<ComputerCreateInput, ComputerUncheckedCreateInput>
  }

  /**
   * Computer createMany
   */
  export type ComputerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Computers.
     */
    data: ComputerCreateManyInput | ComputerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Computer createManyAndReturn
   */
  export type ComputerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Computers.
     */
    data: ComputerCreateManyInput | ComputerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Computer update
   */
  export type ComputerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * The data needed to update a Computer.
     */
    data: XOR<ComputerUpdateInput, ComputerUncheckedUpdateInput>
    /**
     * Choose, which Computer to update.
     */
    where: ComputerWhereUniqueInput
  }

  /**
   * Computer updateMany
   */
  export type ComputerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Computers.
     */
    data: XOR<ComputerUpdateManyMutationInput, ComputerUncheckedUpdateManyInput>
    /**
     * Filter which Computers to update
     */
    where?: ComputerWhereInput
  }

  /**
   * Computer upsert
   */
  export type ComputerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * The filter to search for the Computer to update in case it exists.
     */
    where: ComputerWhereUniqueInput
    /**
     * In case the Computer found by the `where` argument doesn't exist, create a new Computer with this data.
     */
    create: XOR<ComputerCreateInput, ComputerUncheckedCreateInput>
    /**
     * In case the Computer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComputerUpdateInput, ComputerUncheckedUpdateInput>
  }

  /**
   * Computer delete
   */
  export type ComputerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
    /**
     * Filter which Computer to delete.
     */
    where: ComputerWhereUniqueInput
  }

  /**
   * Computer deleteMany
   */
  export type ComputerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Computers to delete
     */
    where?: ComputerWhereInput
  }

  /**
   * Computer.accountBook
   */
  export type Computer$accountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBook
     */
    select?: AccountBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBookInclude<ExtArgs> | null
    where?: AccountBookWhereInput
    orderBy?: AccountBookOrderByWithRelationInput | AccountBookOrderByWithRelationInput[]
    cursor?: AccountBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBookScalarFieldEnum | AccountBookScalarFieldEnum[]
  }

  /**
   * Computer.addressBook
   */
  export type Computer$addressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressBook
     */
    select?: AddressBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressBookInclude<ExtArgs> | null
    where?: AddressBookWhereInput
    orderBy?: AddressBookOrderByWithRelationInput | AddressBookOrderByWithRelationInput[]
    cursor?: AddressBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressBookScalarFieldEnum | AddressBookScalarFieldEnum[]
  }

  /**
   * Computer.dns
   */
  export type Computer$dnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DNS
     */
    select?: DNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DNSInclude<ExtArgs> | null
    where?: DNSWhereInput
    orderBy?: DNSOrderByWithRelationInput | DNSOrderByWithRelationInput[]
    cursor?: DNSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DNSScalarFieldEnum | DNSScalarFieldEnum[]
  }

  /**
   * Computer.hardware
   */
  export type Computer$hardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hardware
     */
    select?: HardwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HardwareInclude<ExtArgs> | null
    where?: HardwareWhereInput
    orderBy?: HardwareOrderByWithRelationInput | HardwareOrderByWithRelationInput[]
    cursor?: HardwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HardwareScalarFieldEnum | HardwareScalarFieldEnum[]
  }

  /**
   * Computer.logs
   */
  export type Computer$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Computer.memory
   */
  export type Computer$memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memory
     */
    select?: MemorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemoryInclude<ExtArgs> | null
    where?: MemoryWhereInput
    orderBy?: MemoryOrderByWithRelationInput | MemoryOrderByWithRelationInput[]
    cursor?: MemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemoryScalarFieldEnum | MemoryScalarFieldEnum[]
  }

  /**
   * Computer.process
   */
  export type Computer$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Computer.software
   */
  export type Computer$softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    cursor?: SoftwareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * Computer without action
   */
  export type ComputerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Computer
     */
    select?: ComputerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerInclude<ExtArgs> | null
  }


  /**
   * Model Quests
   */

  export type AggregateQuests = {
    _count: QuestsCountAggregateOutputType | null
    _min: QuestsMinAggregateOutputType | null
    _max: QuestsMaxAggregateOutputType | null
  }

  export type QuestsMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    type: string | null
    title: string | null
    open: boolean | null
  }

  export type QuestsMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    type: string | null
    title: string | null
    open: boolean | null
  }

  export type QuestsCountAggregateOutputType = {
    id: number
    gameId: number
    type: number
    title: number
    reward: number
    open: number
    _all: number
  }


  export type QuestsMinAggregateInputType = {
    id?: true
    gameId?: true
    type?: true
    title?: true
    open?: true
  }

  export type QuestsMaxAggregateInputType = {
    id?: true
    gameId?: true
    type?: true
    title?: true
    open?: true
  }

  export type QuestsCountAggregateInputType = {
    id?: true
    gameId?: true
    type?: true
    title?: true
    reward?: true
    open?: true
    _all?: true
  }

  export type QuestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to aggregate.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quests
    **/
    _count?: true | QuestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestsMaxAggregateInputType
  }

  export type GetQuestsAggregateType<T extends QuestsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuests[P]>
      : GetScalarType<T[P], AggregateQuests[P]>
  }




  export type QuestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestsWhereInput
    orderBy?: QuestsOrderByWithAggregationInput | QuestsOrderByWithAggregationInput[]
    by: QuestsScalarFieldEnum[] | QuestsScalarFieldEnum
    having?: QuestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestsCountAggregateInputType | true
    _min?: QuestsMinAggregateInputType
    _max?: QuestsMaxAggregateInputType
  }

  export type QuestsGroupByOutputType = {
    id: string
    gameId: string
    type: string
    title: string
    reward: JsonValue | null
    open: boolean
    _count: QuestsCountAggregateOutputType | null
    _min: QuestsMinAggregateOutputType | null
    _max: QuestsMaxAggregateOutputType | null
  }

  type GetQuestsGroupByPayload<T extends QuestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestsGroupByOutputType[P]>
        }
      >
    >


  export type QuestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    type?: boolean
    title?: boolean
    reward?: boolean
    open?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    userQuests?: boolean | Quests$userQuestsArgs<ExtArgs>
    _count?: boolean | QuestsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quests"]>

  export type QuestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    type?: boolean
    title?: boolean
    reward?: boolean
    open?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quests"]>

  export type QuestsSelectScalar = {
    id?: boolean
    gameId?: boolean
    type?: boolean
    title?: boolean
    reward?: boolean
    open?: boolean
  }

  export type QuestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    userQuests?: boolean | Quests$userQuestsArgs<ExtArgs>
    _count?: boolean | QuestsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $QuestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quests"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      userQuests: Prisma.$UserQuestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      type: string
      title: string
      reward: Prisma.JsonValue | null
      open: boolean
    }, ExtArgs["result"]["quests"]>
    composites: {}
  }

  type QuestsGetPayload<S extends boolean | null | undefined | QuestsDefaultArgs> = $Result.GetResult<Prisma.$QuestsPayload, S>

  type QuestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestsCountAggregateInputType | true
    }

  export interface QuestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quests'], meta: { name: 'Quests' } }
    /**
     * Find zero or one Quests that matches the filter.
     * @param {QuestsFindUniqueArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestsFindUniqueArgs>(args: SelectSubset<T, QuestsFindUniqueArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quests that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestsFindUniqueOrThrowArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestsFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsFindFirstArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestsFindFirstArgs>(args?: SelectSubset<T, QuestsFindFirstArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsFindFirstOrThrowArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestsFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quests.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questsWithIdOnly = await prisma.quests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestsFindManyArgs>(args?: SelectSubset<T, QuestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quests.
     * @param {QuestsCreateArgs} args - Arguments to create a Quests.
     * @example
     * // Create one Quests
     * const Quests = await prisma.quests.create({
     *   data: {
     *     // ... data to create a Quests
     *   }
     * })
     * 
     */
    create<T extends QuestsCreateArgs>(args: SelectSubset<T, QuestsCreateArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quests.
     * @param {QuestsCreateManyArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quests = await prisma.quests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestsCreateManyArgs>(args?: SelectSubset<T, QuestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quests and returns the data saved in the database.
     * @param {QuestsCreateManyAndReturnArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quests = await prisma.quests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quests and only return the `id`
     * const questsWithIdOnly = await prisma.quests.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestsCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quests.
     * @param {QuestsDeleteArgs} args - Arguments to delete one Quests.
     * @example
     * // Delete one Quests
     * const Quests = await prisma.quests.delete({
     *   where: {
     *     // ... filter to delete one Quests
     *   }
     * })
     * 
     */
    delete<T extends QuestsDeleteArgs>(args: SelectSubset<T, QuestsDeleteArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quests.
     * @param {QuestsUpdateArgs} args - Arguments to update one Quests.
     * @example
     * // Update one Quests
     * const quests = await prisma.quests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestsUpdateArgs>(args: SelectSubset<T, QuestsUpdateArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quests.
     * @param {QuestsDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestsDeleteManyArgs>(args?: SelectSubset<T, QuestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quests = await prisma.quests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestsUpdateManyArgs>(args: SelectSubset<T, QuestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quests.
     * @param {QuestsUpsertArgs} args - Arguments to update or create a Quests.
     * @example
     * // Update or create a Quests
     * const quests = await prisma.quests.upsert({
     *   create: {
     *     // ... data to create a Quests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quests we want to update
     *   }
     * })
     */
    upsert<T extends QuestsUpsertArgs>(args: SelectSubset<T, QuestsUpsertArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quests.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends QuestsCountArgs>(
      args?: Subset<T, QuestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestsAggregateArgs>(args: Subset<T, QuestsAggregateArgs>): Prisma.PrismaPromise<GetQuestsAggregateType<T>>

    /**
     * Group by Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestsGroupByArgs['orderBy'] }
        : { orderBy?: QuestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quests model
   */
  readonly fields: QuestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userQuests<T extends Quests$userQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Quests$userQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quests model
   */ 
  interface QuestsFieldRefs {
    readonly id: FieldRef<"Quests", 'String'>
    readonly gameId: FieldRef<"Quests", 'String'>
    readonly type: FieldRef<"Quests", 'String'>
    readonly title: FieldRef<"Quests", 'String'>
    readonly reward: FieldRef<"Quests", 'Json'>
    readonly open: FieldRef<"Quests", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Quests findUnique
   */
  export type QuestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where: QuestsWhereUniqueInput
  }

  /**
   * Quests findUniqueOrThrow
   */
  export type QuestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where: QuestsWhereUniqueInput
  }

  /**
   * Quests findFirst
   */
  export type QuestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }

  /**
   * Quests findFirstOrThrow
   */
  export type QuestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }

  /**
   * Quests findMany
   */
  export type QuestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestsOrderByWithRelationInput | QuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quests.
     */
    cursor?: QuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }

  /**
   * Quests create
   */
  export type QuestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * The data needed to create a Quests.
     */
    data: XOR<QuestsCreateInput, QuestsUncheckedCreateInput>
  }

  /**
   * Quests createMany
   */
  export type QuestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quests.
     */
    data: QuestsCreateManyInput | QuestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quests createManyAndReturn
   */
  export type QuestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quests.
     */
    data: QuestsCreateManyInput | QuestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quests update
   */
  export type QuestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * The data needed to update a Quests.
     */
    data: XOR<QuestsUpdateInput, QuestsUncheckedUpdateInput>
    /**
     * Choose, which Quests to update.
     */
    where: QuestsWhereUniqueInput
  }

  /**
   * Quests updateMany
   */
  export type QuestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestsUpdateManyMutationInput, QuestsUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestsWhereInput
  }

  /**
   * Quests upsert
   */
  export type QuestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * The filter to search for the Quests to update in case it exists.
     */
    where: QuestsWhereUniqueInput
    /**
     * In case the Quests found by the `where` argument doesn't exist, create a new Quests with this data.
     */
    create: XOR<QuestsCreateInput, QuestsUncheckedCreateInput>
    /**
     * In case the Quests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestsUpdateInput, QuestsUncheckedUpdateInput>
  }

  /**
   * Quests delete
   */
  export type QuestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
    /**
     * Filter which Quests to delete.
     */
    where: QuestsWhereUniqueInput
  }

  /**
   * Quests deleteMany
   */
  export type QuestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to delete
     */
    where?: QuestsWhereInput
  }

  /**
   * Quests.userQuests
   */
  export type Quests$userQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    cursor?: UserQuestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }

  /**
   * Quests without action
   */
  export type QuestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quests
     */
    select?: QuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestsInclude<ExtArgs> | null
  }


  /**
   * Model UserQuests
   */

  export type AggregateUserQuests = {
    _count: UserQuestsCountAggregateOutputType | null
    _avg: UserQuestsAvgAggregateOutputType | null
    _sum: UserQuestsSumAggregateOutputType | null
    _min: UserQuestsMinAggregateOutputType | null
    _max: UserQuestsMaxAggregateOutputType | null
  }

  export type UserQuestsAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserQuestsSumAggregateOutputType = {
    userId: number | null
  }

  export type UserQuestsMinAggregateOutputType = {
    id: string | null
    questsId: string | null
    userId: number | null
    gameId: string | null
    completed: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type UserQuestsMaxAggregateOutputType = {
    id: string | null
    questsId: string | null
    userId: number | null
    gameId: string | null
    completed: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type UserQuestsCountAggregateOutputType = {
    id: number
    questsId: number
    userId: number
    gameId: number
    completed: number
    created: number
    updated: number
    _all: number
  }


  export type UserQuestsAvgAggregateInputType = {
    userId?: true
  }

  export type UserQuestsSumAggregateInputType = {
    userId?: true
  }

  export type UserQuestsMinAggregateInputType = {
    id?: true
    questsId?: true
    userId?: true
    gameId?: true
    completed?: true
    created?: true
    updated?: true
  }

  export type UserQuestsMaxAggregateInputType = {
    id?: true
    questsId?: true
    userId?: true
    gameId?: true
    completed?: true
    created?: true
    updated?: true
  }

  export type UserQuestsCountAggregateInputType = {
    id?: true
    questsId?: true
    userId?: true
    gameId?: true
    completed?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type UserQuestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuests to aggregate.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuests
    **/
    _count?: true | UserQuestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuestsMaxAggregateInputType
  }

  export type GetUserQuestsAggregateType<T extends UserQuestsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuests[P]>
      : GetScalarType<T[P], AggregateUserQuests[P]>
  }




  export type UserQuestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestsWhereInput
    orderBy?: UserQuestsOrderByWithAggregationInput | UserQuestsOrderByWithAggregationInput[]
    by: UserQuestsScalarFieldEnum[] | UserQuestsScalarFieldEnum
    having?: UserQuestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuestsCountAggregateInputType | true
    _avg?: UserQuestsAvgAggregateInputType
    _sum?: UserQuestsSumAggregateInputType
    _min?: UserQuestsMinAggregateInputType
    _max?: UserQuestsMaxAggregateInputType
  }

  export type UserQuestsGroupByOutputType = {
    id: string
    questsId: string
    userId: number
    gameId: string
    completed: boolean
    created: Date
    updated: Date
    _count: UserQuestsCountAggregateOutputType | null
    _avg: UserQuestsAvgAggregateOutputType | null
    _sum: UserQuestsSumAggregateOutputType | null
    _min: UserQuestsMinAggregateOutputType | null
    _max: UserQuestsMaxAggregateOutputType | null
  }

  type GetUserQuestsGroupByPayload<T extends UserQuestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuestsGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuestsGroupByOutputType[P]>
        }
      >
    >


  export type UserQuestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questsId?: boolean
    userId?: boolean
    gameId?: boolean
    completed?: boolean
    created?: boolean
    updated?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    quest?: boolean | QuestsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuests"]>

  export type UserQuestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questsId?: boolean
    userId?: boolean
    gameId?: boolean
    completed?: boolean
    created?: boolean
    updated?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    quest?: boolean | QuestsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuests"]>

  export type UserQuestsSelectScalar = {
    id?: boolean
    questsId?: boolean
    userId?: boolean
    gameId?: boolean
    completed?: boolean
    created?: boolean
    updated?: boolean
  }

  export type UserQuestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    quest?: boolean | QuestsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserQuestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    quest?: boolean | QuestsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserQuestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuests"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      quest: Prisma.$QuestsPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questsId: string
      userId: number
      gameId: string
      completed: boolean
      created: Date
      updated: Date
    }, ExtArgs["result"]["userQuests"]>
    composites: {}
  }

  type UserQuestsGetPayload<S extends boolean | null | undefined | UserQuestsDefaultArgs> = $Result.GetResult<Prisma.$UserQuestsPayload, S>

  type UserQuestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserQuestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserQuestsCountAggregateInputType | true
    }

  export interface UserQuestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuests'], meta: { name: 'UserQuests' } }
    /**
     * Find zero or one UserQuests that matches the filter.
     * @param {UserQuestsFindUniqueArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQuestsFindUniqueArgs>(args: SelectSubset<T, UserQuestsFindUniqueArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserQuests that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserQuestsFindUniqueOrThrowArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQuestsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQuestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsFindFirstArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQuestsFindFirstArgs>(args?: SelectSubset<T, UserQuestsFindFirstArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserQuests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsFindFirstOrThrowArgs} args - Arguments to find a UserQuests
     * @example
     * // Get one UserQuests
     * const userQuests = await prisma.userQuests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQuestsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQuestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuests
     * const userQuests = await prisma.userQuests.findMany()
     * 
     * // Get first 10 UserQuests
     * const userQuests = await prisma.userQuests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userQuestsWithIdOnly = await prisma.userQuests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserQuestsFindManyArgs>(args?: SelectSubset<T, UserQuestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserQuests.
     * @param {UserQuestsCreateArgs} args - Arguments to create a UserQuests.
     * @example
     * // Create one UserQuests
     * const UserQuests = await prisma.userQuests.create({
     *   data: {
     *     // ... data to create a UserQuests
     *   }
     * })
     * 
     */
    create<T extends UserQuestsCreateArgs>(args: SelectSubset<T, UserQuestsCreateArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserQuests.
     * @param {UserQuestsCreateManyArgs} args - Arguments to create many UserQuests.
     * @example
     * // Create many UserQuests
     * const userQuests = await prisma.userQuests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQuestsCreateManyArgs>(args?: SelectSubset<T, UserQuestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserQuests and returns the data saved in the database.
     * @param {UserQuestsCreateManyAndReturnArgs} args - Arguments to create many UserQuests.
     * @example
     * // Create many UserQuests
     * const userQuests = await prisma.userQuests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserQuests and only return the `id`
     * const userQuestsWithIdOnly = await prisma.userQuests.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserQuestsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserQuestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserQuests.
     * @param {UserQuestsDeleteArgs} args - Arguments to delete one UserQuests.
     * @example
     * // Delete one UserQuests
     * const UserQuests = await prisma.userQuests.delete({
     *   where: {
     *     // ... filter to delete one UserQuests
     *   }
     * })
     * 
     */
    delete<T extends UserQuestsDeleteArgs>(args: SelectSubset<T, UserQuestsDeleteArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserQuests.
     * @param {UserQuestsUpdateArgs} args - Arguments to update one UserQuests.
     * @example
     * // Update one UserQuests
     * const userQuests = await prisma.userQuests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQuestsUpdateArgs>(args: SelectSubset<T, UserQuestsUpdateArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserQuests.
     * @param {UserQuestsDeleteManyArgs} args - Arguments to filter UserQuests to delete.
     * @example
     * // Delete a few UserQuests
     * const { count } = await prisma.userQuests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQuestsDeleteManyArgs>(args?: SelectSubset<T, UserQuestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuests
     * const userQuests = await prisma.userQuests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQuestsUpdateManyArgs>(args: SelectSubset<T, UserQuestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserQuests.
     * @param {UserQuestsUpsertArgs} args - Arguments to update or create a UserQuests.
     * @example
     * // Update or create a UserQuests
     * const userQuests = await prisma.userQuests.upsert({
     *   create: {
     *     // ... data to create a UserQuests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuests we want to update
     *   }
     * })
     */
    upsert<T extends UserQuestsUpsertArgs>(args: SelectSubset<T, UserQuestsUpsertArgs<ExtArgs>>): Prisma__UserQuestsClient<$Result.GetResult<Prisma.$UserQuestsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsCountArgs} args - Arguments to filter UserQuests to count.
     * @example
     * // Count the number of UserQuests
     * const count = await prisma.userQuests.count({
     *   where: {
     *     // ... the filter for the UserQuests we want to count
     *   }
     * })
    **/
    count<T extends UserQuestsCountArgs>(
      args?: Subset<T, UserQuestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuestsAggregateArgs>(args: Subset<T, UserQuestsAggregateArgs>): Prisma.PrismaPromise<GetUserQuestsAggregateType<T>>

    /**
     * Group by UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuestsGroupByArgs['orderBy'] }
        : { orderBy?: UserQuestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuests model
   */
  readonly fields: UserQuestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quest<T extends QuestsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestsDefaultArgs<ExtArgs>>): Prisma__QuestsClient<$Result.GetResult<Prisma.$QuestsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQuests model
   */ 
  interface UserQuestsFieldRefs {
    readonly id: FieldRef<"UserQuests", 'String'>
    readonly questsId: FieldRef<"UserQuests", 'String'>
    readonly userId: FieldRef<"UserQuests", 'Int'>
    readonly gameId: FieldRef<"UserQuests", 'String'>
    readonly completed: FieldRef<"UserQuests", 'Boolean'>
    readonly created: FieldRef<"UserQuests", 'DateTime'>
    readonly updated: FieldRef<"UserQuests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserQuests findUnique
   */
  export type UserQuestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where: UserQuestsWhereUniqueInput
  }

  /**
   * UserQuests findUniqueOrThrow
   */
  export type UserQuestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where: UserQuestsWhereUniqueInput
  }

  /**
   * UserQuests findFirst
   */
  export type UserQuestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuests.
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuests.
     */
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }

  /**
   * UserQuests findFirstOrThrow
   */
  export type UserQuestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuests.
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuests.
     */
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }

  /**
   * UserQuests findMany
   */
  export type UserQuestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where?: UserQuestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestsOrderByWithRelationInput | UserQuestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuests.
     */
    cursor?: UserQuestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    distinct?: UserQuestsScalarFieldEnum | UserQuestsScalarFieldEnum[]
  }

  /**
   * UserQuests create
   */
  export type UserQuestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserQuests.
     */
    data: XOR<UserQuestsCreateInput, UserQuestsUncheckedCreateInput>
  }

  /**
   * UserQuests createMany
   */
  export type UserQuestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuests.
     */
    data: UserQuestsCreateManyInput | UserQuestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQuests createManyAndReturn
   */
  export type UserQuestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserQuests.
     */
    data: UserQuestsCreateManyInput | UserQuestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserQuests update
   */
  export type UserQuestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserQuests.
     */
    data: XOR<UserQuestsUpdateInput, UserQuestsUncheckedUpdateInput>
    /**
     * Choose, which UserQuests to update.
     */
    where: UserQuestsWhereUniqueInput
  }

  /**
   * UserQuests updateMany
   */
  export type UserQuestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuests.
     */
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyInput>
    /**
     * Filter which UserQuests to update
     */
    where?: UserQuestsWhereInput
  }

  /**
   * UserQuests upsert
   */
  export type UserQuestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserQuests to update in case it exists.
     */
    where: UserQuestsWhereUniqueInput
    /**
     * In case the UserQuests found by the `where` argument doesn't exist, create a new UserQuests with this data.
     */
    create: XOR<UserQuestsCreateInput, UserQuestsUncheckedCreateInput>
    /**
     * In case the UserQuests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuestsUpdateInput, UserQuestsUncheckedUpdateInput>
  }

  /**
   * UserQuests delete
   */
  export type UserQuestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
    /**
     * Filter which UserQuests to delete.
     */
    where: UserQuestsWhereUniqueInput
  }

  /**
   * UserQuests deleteMany
   */
  export type UserQuestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuests to delete
     */
    where?: UserQuestsWhereInput
  }

  /**
   * UserQuests without action
   */
  export type UserQuestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuests
     */
    select?: UserQuestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestsInclude<ExtArgs> | null
  }


  /**
   * Model Software
   */

  export type AggregateSoftware = {
    _count: SoftwareCountAggregateOutputType | null
    _avg: SoftwareAvgAggregateOutputType | null
    _sum: SoftwareSumAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  export type SoftwareAvgAggregateOutputType = {
    userId: number | null
    level: number | null
    size: number | null
    opacity: number | null
  }

  export type SoftwareSumAggregateOutputType = {
    userId: number | null
    level: number | null
    size: number | null
    opacity: number | null
  }

  export type SoftwareMinAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    type: string | null
    level: number | null
    size: number | null
    opacity: number | null
    installed: boolean | null
    executed: Date | null
    created: Date | null
    updated: Date | null
  }

  export type SoftwareMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    gameId: string | null
    type: string | null
    level: number | null
    size: number | null
    opacity: number | null
    installed: boolean | null
    executed: Date | null
    created: Date | null
    updated: Date | null
  }

  export type SoftwareCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    gameId: number
    type: number
    level: number
    size: number
    opacity: number
    installed: number
    executed: number
    created: number
    updated: number
    data: number
    _all: number
  }


  export type SoftwareAvgAggregateInputType = {
    userId?: true
    level?: true
    size?: true
    opacity?: true
  }

  export type SoftwareSumAggregateInputType = {
    userId?: true
    level?: true
    size?: true
    opacity?: true
  }

  export type SoftwareMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    type?: true
    level?: true
    size?: true
    opacity?: true
    installed?: true
    executed?: true
    created?: true
    updated?: true
  }

  export type SoftwareMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    type?: true
    level?: true
    size?: true
    opacity?: true
    installed?: true
    executed?: true
    created?: true
    updated?: true
  }

  export type SoftwareCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    gameId?: true
    type?: true
    level?: true
    size?: true
    opacity?: true
    installed?: true
    executed?: true
    created?: true
    updated?: true
    data?: true
    _all?: true
  }

  export type SoftwareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Software to aggregate.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Software
    **/
    _count?: true | SoftwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoftwareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoftwareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoftwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoftwareMaxAggregateInputType
  }

  export type GetSoftwareAggregateType<T extends SoftwareAggregateArgs> = {
        [P in keyof T & keyof AggregateSoftware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoftware[P]>
      : GetScalarType<T[P], AggregateSoftware[P]>
  }




  export type SoftwareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftwareWhereInput
    orderBy?: SoftwareOrderByWithAggregationInput | SoftwareOrderByWithAggregationInput[]
    by: SoftwareScalarFieldEnum[] | SoftwareScalarFieldEnum
    having?: SoftwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoftwareCountAggregateInputType | true
    _avg?: SoftwareAvgAggregateInputType
    _sum?: SoftwareSumAggregateInputType
    _min?: SoftwareMinAggregateInputType
    _max?: SoftwareMaxAggregateInputType
  }

  export type SoftwareGroupByOutputType = {
    id: string
    userId: number
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed: Date
    created: Date
    updated: Date
    data: JsonValue
    _count: SoftwareCountAggregateOutputType | null
    _avg: SoftwareAvgAggregateOutputType | null
    _sum: SoftwareSumAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  type GetSoftwareGroupByPayload<T extends SoftwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoftwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoftwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
            : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
        }
      >
    >


  export type SoftwareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    level?: boolean
    size?: boolean
    opacity?: boolean
    installed?: boolean
    executed?: boolean
    created?: boolean
    updated?: boolean
    data?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["software"]>

  export type SoftwareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    level?: boolean
    size?: boolean
    opacity?: boolean
    installed?: boolean
    executed?: boolean
    created?: boolean
    updated?: boolean
    data?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["software"]>

  export type SoftwareSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    gameId?: boolean
    type?: boolean
    level?: boolean
    size?: boolean
    opacity?: boolean
    installed?: boolean
    executed?: boolean
    created?: boolean
    updated?: boolean
    data?: boolean
  }

  export type SoftwareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SoftwareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SoftwarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Software"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      computerId: string
      gameId: string
      type: string
      level: number
      size: number
      opacity: number
      installed: boolean
      executed: Date
      created: Date
      updated: Date
      data: Prisma.JsonValue
    }, ExtArgs["result"]["software"]>
    composites: {}
  }

  type SoftwareGetPayload<S extends boolean | null | undefined | SoftwareDefaultArgs> = $Result.GetResult<Prisma.$SoftwarePayload, S>

  type SoftwareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SoftwareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoftwareCountAggregateInputType | true
    }

  export interface SoftwareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Software'], meta: { name: 'Software' } }
    /**
     * Find zero or one Software that matches the filter.
     * @param {SoftwareFindUniqueArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SoftwareFindUniqueArgs>(args: SelectSubset<T, SoftwareFindUniqueArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Software that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SoftwareFindUniqueOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SoftwareFindUniqueOrThrowArgs>(args: SelectSubset<T, SoftwareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindFirstArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SoftwareFindFirstArgs>(args?: SelectSubset<T, SoftwareFindFirstArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Software that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindFirstOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SoftwareFindFirstOrThrowArgs>(args?: SelectSubset<T, SoftwareFindFirstOrThrowArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Software
     * const software = await prisma.software.findMany()
     * 
     * // Get first 10 Software
     * const software = await prisma.software.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const softwareWithIdOnly = await prisma.software.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SoftwareFindManyArgs>(args?: SelectSubset<T, SoftwareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Software.
     * @param {SoftwareCreateArgs} args - Arguments to create a Software.
     * @example
     * // Create one Software
     * const Software = await prisma.software.create({
     *   data: {
     *     // ... data to create a Software
     *   }
     * })
     * 
     */
    create<T extends SoftwareCreateArgs>(args: SelectSubset<T, SoftwareCreateArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Software.
     * @param {SoftwareCreateManyArgs} args - Arguments to create many Software.
     * @example
     * // Create many Software
     * const software = await prisma.software.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SoftwareCreateManyArgs>(args?: SelectSubset<T, SoftwareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Software and returns the data saved in the database.
     * @param {SoftwareCreateManyAndReturnArgs} args - Arguments to create many Software.
     * @example
     * // Create many Software
     * const software = await prisma.software.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Software and only return the `id`
     * const softwareWithIdOnly = await prisma.software.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SoftwareCreateManyAndReturnArgs>(args?: SelectSubset<T, SoftwareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Software.
     * @param {SoftwareDeleteArgs} args - Arguments to delete one Software.
     * @example
     * // Delete one Software
     * const Software = await prisma.software.delete({
     *   where: {
     *     // ... filter to delete one Software
     *   }
     * })
     * 
     */
    delete<T extends SoftwareDeleteArgs>(args: SelectSubset<T, SoftwareDeleteArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Software.
     * @param {SoftwareUpdateArgs} args - Arguments to update one Software.
     * @example
     * // Update one Software
     * const software = await prisma.software.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SoftwareUpdateArgs>(args: SelectSubset<T, SoftwareUpdateArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Software.
     * @param {SoftwareDeleteManyArgs} args - Arguments to filter Software to delete.
     * @example
     * // Delete a few Software
     * const { count } = await prisma.software.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SoftwareDeleteManyArgs>(args?: SelectSubset<T, SoftwareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Software
     * const software = await prisma.software.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SoftwareUpdateManyArgs>(args: SelectSubset<T, SoftwareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Software.
     * @param {SoftwareUpsertArgs} args - Arguments to update or create a Software.
     * @example
     * // Update or create a Software
     * const software = await prisma.software.upsert({
     *   create: {
     *     // ... data to create a Software
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Software we want to update
     *   }
     * })
     */
    upsert<T extends SoftwareUpsertArgs>(args: SelectSubset<T, SoftwareUpsertArgs<ExtArgs>>): Prisma__SoftwareClient<$Result.GetResult<Prisma.$SoftwarePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareCountArgs} args - Arguments to filter Software to count.
     * @example
     * // Count the number of Software
     * const count = await prisma.software.count({
     *   where: {
     *     // ... the filter for the Software we want to count
     *   }
     * })
    **/
    count<T extends SoftwareCountArgs>(
      args?: Subset<T, SoftwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoftwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoftwareAggregateArgs>(args: Subset<T, SoftwareAggregateArgs>): Prisma.PrismaPromise<GetSoftwareAggregateType<T>>

    /**
     * Group by Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoftwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoftwareGroupByArgs['orderBy'] }
        : { orderBy?: SoftwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoftwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoftwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Software model
   */
  readonly fields: SoftwareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Software.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoftwareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Software model
   */ 
  interface SoftwareFieldRefs {
    readonly id: FieldRef<"Software", 'String'>
    readonly userId: FieldRef<"Software", 'Int'>
    readonly computerId: FieldRef<"Software", 'String'>
    readonly gameId: FieldRef<"Software", 'String'>
    readonly type: FieldRef<"Software", 'String'>
    readonly level: FieldRef<"Software", 'Float'>
    readonly size: FieldRef<"Software", 'Float'>
    readonly opacity: FieldRef<"Software", 'Float'>
    readonly installed: FieldRef<"Software", 'Boolean'>
    readonly executed: FieldRef<"Software", 'DateTime'>
    readonly created: FieldRef<"Software", 'DateTime'>
    readonly updated: FieldRef<"Software", 'DateTime'>
    readonly data: FieldRef<"Software", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Software findUnique
   */
  export type SoftwareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where: SoftwareWhereUniqueInput
  }

  /**
   * Software findUniqueOrThrow
   */
  export type SoftwareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where: SoftwareWhereUniqueInput
  }

  /**
   * Software findFirst
   */
  export type SoftwareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * Software findFirstOrThrow
   */
  export type SoftwareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * Software findMany
   */
  export type SoftwareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter, which Software to fetch.
     */
    where?: SoftwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Software to fetch.
     */
    orderBy?: SoftwareOrderByWithRelationInput | SoftwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Software.
     */
    cursor?: SoftwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Software.
     */
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * Software create
   */
  export type SoftwareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The data needed to create a Software.
     */
    data: XOR<SoftwareCreateInput, SoftwareUncheckedCreateInput>
  }

  /**
   * Software createMany
   */
  export type SoftwareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Software.
     */
    data: SoftwareCreateManyInput | SoftwareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Software createManyAndReturn
   */
  export type SoftwareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Software.
     */
    data: SoftwareCreateManyInput | SoftwareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Software update
   */
  export type SoftwareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The data needed to update a Software.
     */
    data: XOR<SoftwareUpdateInput, SoftwareUncheckedUpdateInput>
    /**
     * Choose, which Software to update.
     */
    where: SoftwareWhereUniqueInput
  }

  /**
   * Software updateMany
   */
  export type SoftwareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Software.
     */
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyInput>
    /**
     * Filter which Software to update
     */
    where?: SoftwareWhereInput
  }

  /**
   * Software upsert
   */
  export type SoftwareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * The filter to search for the Software to update in case it exists.
     */
    where: SoftwareWhereUniqueInput
    /**
     * In case the Software found by the `where` argument doesn't exist, create a new Software with this data.
     */
    create: XOR<SoftwareCreateInput, SoftwareUncheckedCreateInput>
    /**
     * In case the Software was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoftwareUpdateInput, SoftwareUncheckedUpdateInput>
  }

  /**
   * Software delete
   */
  export type SoftwareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
    /**
     * Filter which Software to delete.
     */
    where: SoftwareWhereUniqueInput
  }

  /**
   * Software deleteMany
   */
  export type SoftwareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Software to delete
     */
    where?: SoftwareWhereInput
  }

  /**
   * Software without action
   */
  export type SoftwareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Software
     */
    select?: SoftwareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoftwareInclude<ExtArgs> | null
  }


  /**
   * Model Process
   */

  export type AggregateProcess = {
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  export type ProcessAvgAggregateOutputType = {
    userId: number | null
  }

  export type ProcessSumAggregateOutputType = {
    userId: number | null
  }

  export type ProcessMinAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    ip: string | null
    gameId: string | null
    type: string | null
    started: Date | null
    completion: Date | null
  }

  export type ProcessMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    computerId: string | null
    ip: string | null
    gameId: string | null
    type: string | null
    started: Date | null
    completion: Date | null
  }

  export type ProcessCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    ip: number
    gameId: number
    type: number
    started: number
    completion: number
    data: number
    _all: number
  }


  export type ProcessAvgAggregateInputType = {
    userId?: true
  }

  export type ProcessSumAggregateInputType = {
    userId?: true
  }

  export type ProcessMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    ip?: true
    gameId?: true
    type?: true
    started?: true
    completion?: true
  }

  export type ProcessMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    ip?: true
    gameId?: true
    type?: true
    started?: true
    completion?: true
  }

  export type ProcessCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    ip?: true
    gameId?: true
    type?: true
    started?: true
    completion?: true
    data?: true
    _all?: true
  }

  export type ProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Process to aggregate.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processes
    **/
    _count?: true | ProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessMaxAggregateInputType
  }

  export type GetProcessAggregateType<T extends ProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcess[P]>
      : GetScalarType<T[P], AggregateProcess[P]>
  }




  export type ProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithAggregationInput | ProcessOrderByWithAggregationInput[]
    by: ProcessScalarFieldEnum[] | ProcessScalarFieldEnum
    having?: ProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCountAggregateInputType | true
    _avg?: ProcessAvgAggregateInputType
    _sum?: ProcessSumAggregateInputType
    _min?: ProcessMinAggregateInputType
    _max?: ProcessMaxAggregateInputType
  }

  export type ProcessGroupByOutputType = {
    id: string
    userId: number
    computerId: string
    ip: string | null
    gameId: string
    type: string
    started: Date
    completion: Date
    data: JsonValue
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  type GetProcessGroupByPayload<T extends ProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessGroupByOutputType[P]>
        }
      >
    >


  export type ProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    ip?: boolean
    gameId?: boolean
    type?: boolean
    started?: boolean
    completion?: boolean
    data?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    ip?: boolean
    gameId?: boolean
    type?: boolean
    started?: boolean
    completion?: boolean
    data?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    ip?: boolean
    gameId?: boolean
    type?: boolean
    started?: boolean
    completion?: boolean
    data?: boolean
  }

  export type ProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProcessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Process"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      computerId: string
      ip: string | null
      gameId: string
      type: string
      started: Date
      completion: Date
      data: Prisma.JsonValue
    }, ExtArgs["result"]["process"]>
    composites: {}
  }

  type ProcessGetPayload<S extends boolean | null | undefined | ProcessDefaultArgs> = $Result.GetResult<Prisma.$ProcessPayload, S>

  type ProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessCountAggregateInputType | true
    }

  export interface ProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Process'], meta: { name: 'Process' } }
    /**
     * Find zero or one Process that matches the filter.
     * @param {ProcessFindUniqueArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessFindUniqueArgs>(args: SelectSubset<T, ProcessFindUniqueArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Process that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessFindUniqueOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Process that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessFindFirstArgs>(args?: SelectSubset<T, ProcessFindFirstArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Process that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Processes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processes
     * const processes = await prisma.process.findMany()
     * 
     * // Get first 10 Processes
     * const processes = await prisma.process.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processWithIdOnly = await prisma.process.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessFindManyArgs>(args?: SelectSubset<T, ProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Process.
     * @param {ProcessCreateArgs} args - Arguments to create a Process.
     * @example
     * // Create one Process
     * const Process = await prisma.process.create({
     *   data: {
     *     // ... data to create a Process
     *   }
     * })
     * 
     */
    create<T extends ProcessCreateArgs>(args: SelectSubset<T, ProcessCreateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Processes.
     * @param {ProcessCreateManyArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessCreateManyArgs>(args?: SelectSubset<T, ProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Processes and returns the data saved in the database.
     * @param {ProcessCreateManyAndReturnArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Processes and only return the `id`
     * const processWithIdOnly = await prisma.process.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Process.
     * @param {ProcessDeleteArgs} args - Arguments to delete one Process.
     * @example
     * // Delete one Process
     * const Process = await prisma.process.delete({
     *   where: {
     *     // ... filter to delete one Process
     *   }
     * })
     * 
     */
    delete<T extends ProcessDeleteArgs>(args: SelectSubset<T, ProcessDeleteArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Process.
     * @param {ProcessUpdateArgs} args - Arguments to update one Process.
     * @example
     * // Update one Process
     * const process = await prisma.process.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessUpdateArgs>(args: SelectSubset<T, ProcessUpdateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Processes.
     * @param {ProcessDeleteManyArgs} args - Arguments to filter Processes to delete.
     * @example
     * // Delete a few Processes
     * const { count } = await prisma.process.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessDeleteManyArgs>(args?: SelectSubset<T, ProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessUpdateManyArgs>(args: SelectSubset<T, ProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Process.
     * @param {ProcessUpsertArgs} args - Arguments to update or create a Process.
     * @example
     * // Update or create a Process
     * const process = await prisma.process.upsert({
     *   create: {
     *     // ... data to create a Process
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Process we want to update
     *   }
     * })
     */
    upsert<T extends ProcessUpsertArgs>(args: SelectSubset<T, ProcessUpsertArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCountArgs} args - Arguments to filter Processes to count.
     * @example
     * // Count the number of Processes
     * const count = await prisma.process.count({
     *   where: {
     *     // ... the filter for the Processes we want to count
     *   }
     * })
    **/
    count<T extends ProcessCountArgs>(
      args?: Subset<T, ProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessAggregateArgs>(args: Subset<T, ProcessAggregateArgs>): Prisma.PrismaPromise<GetProcessAggregateType<T>>

    /**
     * Group by Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessGroupByArgs['orderBy'] }
        : { orderBy?: ProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Process model
   */
  readonly fields: ProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Process.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Process model
   */ 
  interface ProcessFieldRefs {
    readonly id: FieldRef<"Process", 'String'>
    readonly userId: FieldRef<"Process", 'Int'>
    readonly computerId: FieldRef<"Process", 'String'>
    readonly ip: FieldRef<"Process", 'String'>
    readonly gameId: FieldRef<"Process", 'String'>
    readonly type: FieldRef<"Process", 'String'>
    readonly started: FieldRef<"Process", 'DateTime'>
    readonly completion: FieldRef<"Process", 'DateTime'>
    readonly data: FieldRef<"Process", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Process findUnique
   */
  export type ProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findUniqueOrThrow
   */
  export type ProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findFirst
   */
  export type ProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findFirstOrThrow
   */
  export type ProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findMany
   */
  export type ProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Processes to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process create
   */
  export type ProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a Process.
     */
    data: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
  }

  /**
   * Process createMany
   */
  export type ProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Process createManyAndReturn
   */
  export type ProcessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Process update
   */
  export type ProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a Process.
     */
    data: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
    /**
     * Choose, which Process to update.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process updateMany
   */
  export type ProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
  }

  /**
   * Process upsert
   */
  export type ProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the Process to update in case it exists.
     */
    where: ProcessWhereUniqueInput
    /**
     * In case the Process found by the `where` argument doesn't exist, create a new Process with this data.
     */
    create: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
    /**
     * In case the Process was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
  }

  /**
   * Process delete
   */
  export type ProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter which Process to delete.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process deleteMany
   */
  export type ProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processes to delete
     */
    where?: ProcessWhereInput
  }

  /**
   * Process without action
   */
  export type ProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    read: boolean | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    read: boolean | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    content: number
    read: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    read?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    read?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    content?: true
    read?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    userId: number
    type: string
    content: JsonValue
    read: boolean
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
  }

  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      content: Prisma.JsonValue
      read: boolean
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsFindManyArgs>(args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends NotificationsCreateArgs>(args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsCreateManyArgs>(args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends NotificationsDeleteArgs>(args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsUpdateArgs>(args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsUpdateManyArgs>(args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notifications model
   */ 
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'Int'>
    readonly userId: FieldRef<"Notifications", 'Int'>
    readonly type: FieldRef<"Notifications", 'String'>
    readonly content: FieldRef<"Notifications", 'Json'>
    readonly read: FieldRef<"Notifications", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications createManyAndReturn
   */
  export type NotificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
  }


  /**
   * Model Logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    senderId: string | null
    senderIp: string | null
    gameId: string | null
    message: string | null
    created: Date | null
  }

  export type LogsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    computerId: string | null
    senderId: string | null
    senderIp: string | null
    gameId: string | null
    message: string | null
    created: Date | null
  }

  export type LogsCountAggregateOutputType = {
    id: number
    userId: number
    computerId: number
    senderId: number
    senderIp: number
    gameId: number
    message: number
    created: number
    _all: number
  }


  export type LogsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogsMinAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    senderId?: true
    senderIp?: true
    gameId?: true
    message?: true
    created?: true
  }

  export type LogsMaxAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    senderId?: true
    senderIp?: true
    gameId?: true
    message?: true
    created?: true
  }

  export type LogsCountAggregateInputType = {
    id?: true
    userId?: true
    computerId?: true
    senderId?: true
    senderIp?: true
    gameId?: true
    message?: true
    created?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to aggregate.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithAggregationInput | LogsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _avg?: LogsAvgAggregateInputType
    _sum?: LogsSumAggregateInputType
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    id: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created: Date
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    senderId?: boolean
    senderIp?: boolean
    gameId?: boolean
    message?: boolean
    created?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    computerId?: boolean
    senderId?: boolean
    senderIp?: boolean
    gameId?: boolean
    message?: boolean
    created?: boolean
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectScalar = {
    id?: boolean
    userId?: boolean
    computerId?: boolean
    senderId?: boolean
    senderIp?: boolean
    gameId?: boolean
    message?: boolean
    created?: boolean
  }

  export type LogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    computer?: boolean | ComputerDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logs"
    objects: {
      computer: Prisma.$ComputerPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      computerId: string
      senderId: string
      senderIp: string
      gameId: string
      message: string
      created: Date
    }, ExtArgs["result"]["logs"]>
    composites: {}
  }

  type LogsGetPayload<S extends boolean | null | undefined | LogsDefaultArgs> = $Result.GetResult<Prisma.$LogsPayload, S>

  type LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logs'], meta: { name: 'Logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {LogsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogsFindUniqueArgs>(args: SelectSubset<T, LogsFindUniqueArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogsFindUniqueOrThrowArgs>(args: SelectSubset<T, LogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogsFindFirstArgs>(args?: SelectSubset<T, LogsFindFirstArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogsFindFirstOrThrowArgs>(args?: SelectSubset<T, LogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsWithIdOnly = await prisma.logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogsFindManyArgs>(args?: SelectSubset<T, LogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Logs.
     * @param {LogsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
     */
    create<T extends LogsCreateArgs>(args: SelectSubset<T, LogsCreateArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logs.
     * @param {LogsCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogsCreateManyArgs>(args?: SelectSubset<T, LogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogsCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logsWithIdOnly = await prisma.logs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogsCreateManyAndReturnArgs>(args?: SelectSubset<T, LogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Logs.
     * @param {LogsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
     */
    delete<T extends LogsDeleteArgs>(args: SelectSubset<T, LogsDeleteArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Logs.
     * @param {LogsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogsUpdateArgs>(args: SelectSubset<T, LogsUpdateArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogsDeleteManyArgs>(args?: SelectSubset<T, LogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogsUpdateManyArgs>(args: SelectSubset<T, LogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs.
     * @param {LogsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
     */
    upsert<T extends LogsUpsertArgs>(args: SelectSubset<T, LogsUpsertArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogsCountArgs>(
      args?: Subset<T, LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsGroupByArgs['orderBy'] }
        : { orderBy?: LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logs model
   */
  readonly fields: LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    computer<T extends ComputerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComputerDefaultArgs<ExtArgs>>): Prisma__ComputerClient<$Result.GetResult<Prisma.$ComputerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Logs model
   */ 
  interface LogsFieldRefs {
    readonly id: FieldRef<"Logs", 'Int'>
    readonly userId: FieldRef<"Logs", 'Int'>
    readonly computerId: FieldRef<"Logs", 'String'>
    readonly senderId: FieldRef<"Logs", 'String'>
    readonly senderIp: FieldRef<"Logs", 'String'>
    readonly gameId: FieldRef<"Logs", 'String'>
    readonly message: FieldRef<"Logs", 'String'>
    readonly created: FieldRef<"Logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Logs findUnique
   */
  export type LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs findUniqueOrThrow
   */
  export type LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs findFirst
   */
  export type LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs findFirstOrThrow
   */
  export type LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs findMany
   */
  export type LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs create
   */
  export type LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to create a Logs.
     */
    data: XOR<LogsCreateInput, LogsUncheckedCreateInput>
  }

  /**
   * Logs createMany
   */
  export type LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Logs createManyAndReturn
   */
  export type LogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Logs update
   */
  export type LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to update a Logs.
     */
    data: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
    /**
     * Choose, which Logs to update.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs updateMany
   */
  export type LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogsWhereInput
  }

  /**
   * Logs upsert
   */
  export type LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The filter to search for the Logs to update in case it exists.
     */
    where: LogsWhereUniqueInput
    /**
     * In case the Logs found by the `where` argument doesn't exist, create a new Logs with this data.
     */
    create: XOR<LogsCreateInput, LogsUncheckedCreateInput>
    /**
     * In case the Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
  }

  /**
   * Logs delete
   */
  export type LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter which Logs to delete.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs deleteMany
   */
  export type LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogsWhereInput
  }

  /**
   * Logs without action
   */
  export type LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
  }


  /**
   * Model Trade
   */

  export type AggregateTrade = {
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  export type TradeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    marketId: number | null
    portfolioId: number | null
    quantity: number | null
    price: number | null
    totalValue: number | null
    buyIntoTargetFundid: number | null
  }

  export type TradeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    marketId: number | null
    portfolioId: number | null
    quantity: number | null
    price: bigint | null
    totalValue: number | null
    buyIntoTargetFundid: number | null
  }

  export type TradeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    marketId: number | null
    portfolioId: number | null
    type: string | null
    quantity: number | null
    price: bigint | null
    totalValue: number | null
    status: string | null
    executedAt: Date | null
    createdAt: Date | null
    buyIntoTargetFundid: number | null
    instructionType: $Enums.InstructionNamedType | null
  }

  export type TradeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    marketId: number | null
    portfolioId: number | null
    type: string | null
    quantity: number | null
    price: bigint | null
    totalValue: number | null
    status: string | null
    executedAt: Date | null
    createdAt: Date | null
    buyIntoTargetFundid: number | null
    instructionType: $Enums.InstructionNamedType | null
  }

  export type TradeCountAggregateOutputType = {
    id: number
    userId: number
    marketId: number
    portfolioId: number
    type: number
    quantity: number
    price: number
    totalValue: number
    status: number
    executedAt: number
    createdAt: number
    buyIntoTargetFundid: number
    instructionType: number
    _all: number
  }


  export type TradeAvgAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    portfolioId?: true
    quantity?: true
    price?: true
    totalValue?: true
    buyIntoTargetFundid?: true
  }

  export type TradeSumAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    portfolioId?: true
    quantity?: true
    price?: true
    totalValue?: true
    buyIntoTargetFundid?: true
  }

  export type TradeMinAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    portfolioId?: true
    type?: true
    quantity?: true
    price?: true
    totalValue?: true
    status?: true
    executedAt?: true
    createdAt?: true
    buyIntoTargetFundid?: true
    instructionType?: true
  }

  export type TradeMaxAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    portfolioId?: true
    type?: true
    quantity?: true
    price?: true
    totalValue?: true
    status?: true
    executedAt?: true
    createdAt?: true
    buyIntoTargetFundid?: true
    instructionType?: true
  }

  export type TradeCountAggregateInputType = {
    id?: true
    userId?: true
    marketId?: true
    portfolioId?: true
    type?: true
    quantity?: true
    price?: true
    totalValue?: true
    status?: true
    executedAt?: true
    createdAt?: true
    buyIntoTargetFundid?: true
    instructionType?: true
    _all?: true
  }

  export type TradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trade to aggregate.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trades
    **/
    _count?: true | TradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeMaxAggregateInputType
  }

  export type GetTradeAggregateType<T extends TradeAggregateArgs> = {
        [P in keyof T & keyof AggregateTrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrade[P]>
      : GetScalarType<T[P], AggregateTrade[P]>
  }




  export type TradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithAggregationInput | TradeOrderByWithAggregationInput[]
    by: TradeScalarFieldEnum[] | TradeScalarFieldEnum
    having?: TradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeCountAggregateInputType | true
    _avg?: TradeAvgAggregateInputType
    _sum?: TradeSumAggregateInputType
    _min?: TradeMinAggregateInputType
    _max?: TradeMaxAggregateInputType
  }

  export type TradeGroupByOutputType = {
    id: number
    userId: number
    marketId: number
    portfolioId: number
    type: string
    quantity: number
    price: bigint
    totalValue: number
    status: string
    executedAt: Date
    createdAt: Date
    buyIntoTargetFundid: number
    instructionType: $Enums.InstructionNamedType
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  type GetTradeGroupByPayload<T extends TradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeGroupByOutputType[P]>
            : GetScalarType<T[P], TradeGroupByOutputType[P]>
        }
      >
    >


  export type TradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    marketId?: boolean
    portfolioId?: boolean
    type?: boolean
    quantity?: boolean
    price?: boolean
    totalValue?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    buyIntoTargetFundid?: boolean
    instructionType?: boolean
    buyIntoTargetFund?: boolean | FundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trade"]>

  export type TradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    marketId?: boolean
    portfolioId?: boolean
    type?: boolean
    quantity?: boolean
    price?: boolean
    totalValue?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    buyIntoTargetFundid?: boolean
    instructionType?: boolean
    buyIntoTargetFund?: boolean | FundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trade"]>

  export type TradeSelectScalar = {
    id?: boolean
    userId?: boolean
    marketId?: boolean
    portfolioId?: boolean
    type?: boolean
    quantity?: boolean
    price?: boolean
    totalValue?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    buyIntoTargetFundid?: boolean
    instructionType?: boolean
  }

  export type TradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyIntoTargetFund?: boolean | FundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }
  export type TradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyIntoTargetFund?: boolean | FundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }

  export type $TradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trade"
    objects: {
      buyIntoTargetFund: Prisma.$FundPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      marketId: number
      portfolioId: number
      type: string
      quantity: number
      price: bigint
      totalValue: number
      status: string
      executedAt: Date
      createdAt: Date
      buyIntoTargetFundid: number
      instructionType: $Enums.InstructionNamedType
    }, ExtArgs["result"]["trade"]>
    composites: {}
  }

  type TradeGetPayload<S extends boolean | null | undefined | TradeDefaultArgs> = $Result.GetResult<Prisma.$TradePayload, S>

  type TradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TradeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TradeCountAggregateInputType | true
    }

  export interface TradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trade'], meta: { name: 'Trade' } }
    /**
     * Find zero or one Trade that matches the filter.
     * @param {TradeFindUniqueArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeFindUniqueArgs>(args: SelectSubset<T, TradeFindUniqueArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TradeFindUniqueOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeFindFirstArgs>(args?: SelectSubset<T, TradeFindFirstArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trades
     * const trades = await prisma.trade.findMany()
     * 
     * // Get first 10 Trades
     * const trades = await prisma.trade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeWithIdOnly = await prisma.trade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeFindManyArgs>(args?: SelectSubset<T, TradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trade.
     * @param {TradeCreateArgs} args - Arguments to create a Trade.
     * @example
     * // Create one Trade
     * const Trade = await prisma.trade.create({
     *   data: {
     *     // ... data to create a Trade
     *   }
     * })
     * 
     */
    create<T extends TradeCreateArgs>(args: SelectSubset<T, TradeCreateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trades.
     * @param {TradeCreateManyArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trade = await prisma.trade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeCreateManyArgs>(args?: SelectSubset<T, TradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trades and returns the data saved in the database.
     * @param {TradeCreateManyAndReturnArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trade = await prisma.trade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trades and only return the `id`
     * const tradeWithIdOnly = await prisma.trade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trade.
     * @param {TradeDeleteArgs} args - Arguments to delete one Trade.
     * @example
     * // Delete one Trade
     * const Trade = await prisma.trade.delete({
     *   where: {
     *     // ... filter to delete one Trade
     *   }
     * })
     * 
     */
    delete<T extends TradeDeleteArgs>(args: SelectSubset<T, TradeDeleteArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trade.
     * @param {TradeUpdateArgs} args - Arguments to update one Trade.
     * @example
     * // Update one Trade
     * const trade = await prisma.trade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeUpdateArgs>(args: SelectSubset<T, TradeUpdateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trades.
     * @param {TradeDeleteManyArgs} args - Arguments to filter Trades to delete.
     * @example
     * // Delete a few Trades
     * const { count } = await prisma.trade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeDeleteManyArgs>(args?: SelectSubset<T, TradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trades
     * const trade = await prisma.trade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeUpdateManyArgs>(args: SelectSubset<T, TradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trade.
     * @param {TradeUpsertArgs} args - Arguments to update or create a Trade.
     * @example
     * // Update or create a Trade
     * const trade = await prisma.trade.upsert({
     *   create: {
     *     // ... data to create a Trade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trade we want to update
     *   }
     * })
     */
    upsert<T extends TradeUpsertArgs>(args: SelectSubset<T, TradeUpsertArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeCountArgs} args - Arguments to filter Trades to count.
     * @example
     * // Count the number of Trades
     * const count = await prisma.trade.count({
     *   where: {
     *     // ... the filter for the Trades we want to count
     *   }
     * })
    **/
    count<T extends TradeCountArgs>(
      args?: Subset<T, TradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeAggregateArgs>(args: Subset<T, TradeAggregateArgs>): Prisma.PrismaPromise<GetTradeAggregateType<T>>

    /**
     * Group by Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeGroupByArgs['orderBy'] }
        : { orderBy?: TradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trade model
   */
  readonly fields: TradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyIntoTargetFund<T extends FundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FundDefaultArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trade model
   */ 
  interface TradeFieldRefs {
    readonly id: FieldRef<"Trade", 'Int'>
    readonly userId: FieldRef<"Trade", 'Int'>
    readonly marketId: FieldRef<"Trade", 'Int'>
    readonly portfolioId: FieldRef<"Trade", 'Int'>
    readonly type: FieldRef<"Trade", 'String'>
    readonly quantity: FieldRef<"Trade", 'Int'>
    readonly price: FieldRef<"Trade", 'BigInt'>
    readonly totalValue: FieldRef<"Trade", 'Int'>
    readonly status: FieldRef<"Trade", 'String'>
    readonly executedAt: FieldRef<"Trade", 'DateTime'>
    readonly createdAt: FieldRef<"Trade", 'DateTime'>
    readonly buyIntoTargetFundid: FieldRef<"Trade", 'Int'>
    readonly instructionType: FieldRef<"Trade", 'InstructionNamedType'>
  }
    

  // Custom InputTypes
  /**
   * Trade findUnique
   */
  export type TradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findUniqueOrThrow
   */
  export type TradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findFirst
   */
  export type TradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findFirstOrThrow
   */
  export type TradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findMany
   */
  export type TradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trades to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade create
   */
  export type TradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Trade.
     */
    data: XOR<TradeCreateInput, TradeUncheckedCreateInput>
  }

  /**
   * Trade createMany
   */
  export type TradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trades.
     */
    data: TradeCreateManyInput | TradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trade createManyAndReturn
   */
  export type TradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trades.
     */
    data: TradeCreateManyInput | TradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trade update
   */
  export type TradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Trade.
     */
    data: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
    /**
     * Choose, which Trade to update.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade updateMany
   */
  export type TradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trades.
     */
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyInput>
    /**
     * Filter which Trades to update
     */
    where?: TradeWhereInput
  }

  /**
   * Trade upsert
   */
  export type TradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Trade to update in case it exists.
     */
    where: TradeWhereUniqueInput
    /**
     * In case the Trade found by the `where` argument doesn't exist, create a new Trade with this data.
     */
    create: XOR<TradeCreateInput, TradeUncheckedCreateInput>
    /**
     * In case the Trade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
  }

  /**
   * Trade delete
   */
  export type TradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter which Trade to delete.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade deleteMany
   */
  export type TradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trades to delete
     */
    where?: TradeWhereInput
  }

  /**
   * Trade without action
   */
  export type TradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
  }


  /**
   * Model Fund
   */

  export type AggregateFund = {
    _count: FundCountAggregateOutputType | null
    _avg: FundAvgAggregateOutputType | null
    _sum: FundSumAggregateOutputType | null
    _min: FundMinAggregateOutputType | null
    _max: FundMaxAggregateOutputType | null
  }

  export type FundAvgAggregateOutputType = {
    id: number | null
    fundManagerId: number | null
    minimumInvestmentAmount: number | null
    totalFundCharge: Decimal | null
    totalFundCost: Decimal | null
    totalAssets: number | null
    maxInvestors: number | null
  }

  export type FundSumAggregateOutputType = {
    id: number | null
    fundManagerId: number | null
    minimumInvestmentAmount: bigint | null
    totalFundCharge: Decimal | null
    totalFundCost: Decimal | null
    totalAssets: bigint | null
    maxInvestors: number | null
  }

  export type FundMinAggregateOutputType = {
    id: number | null
    fundManagerId: number | null
    name: string | null
    minimumInvestmentAmount: bigint | null
    totalFundCharge: Decimal | null
    totalFundCost: Decimal | null
    totalAssets: bigint | null
    isActive: boolean | null
    maxInvestors: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FundMaxAggregateOutputType = {
    id: number | null
    fundManagerId: number | null
    name: string | null
    minimumInvestmentAmount: bigint | null
    totalFundCharge: Decimal | null
    totalFundCost: Decimal | null
    totalAssets: bigint | null
    isActive: boolean | null
    maxInvestors: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FundCountAggregateOutputType = {
    id: number
    fundManagerId: number
    name: number
    minimumInvestmentAmount: number
    totalFundCharge: number
    totalFundCost: number
    totalAssets: number
    isActive: number
    maxInvestors: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FundAvgAggregateInputType = {
    id?: true
    fundManagerId?: true
    minimumInvestmentAmount?: true
    totalFundCharge?: true
    totalFundCost?: true
    totalAssets?: true
    maxInvestors?: true
  }

  export type FundSumAggregateInputType = {
    id?: true
    fundManagerId?: true
    minimumInvestmentAmount?: true
    totalFundCharge?: true
    totalFundCost?: true
    totalAssets?: true
    maxInvestors?: true
  }

  export type FundMinAggregateInputType = {
    id?: true
    fundManagerId?: true
    name?: true
    minimumInvestmentAmount?: true
    totalFundCharge?: true
    totalFundCost?: true
    totalAssets?: true
    isActive?: true
    maxInvestors?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FundMaxAggregateInputType = {
    id?: true
    fundManagerId?: true
    name?: true
    minimumInvestmentAmount?: true
    totalFundCharge?: true
    totalFundCost?: true
    totalAssets?: true
    isActive?: true
    maxInvestors?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FundCountAggregateInputType = {
    id?: true
    fundManagerId?: true
    name?: true
    minimumInvestmentAmount?: true
    totalFundCharge?: true
    totalFundCost?: true
    totalAssets?: true
    isActive?: true
    maxInvestors?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fund to aggregate.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Funds
    **/
    _count?: true | FundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FundMaxAggregateInputType
  }

  export type GetFundAggregateType<T extends FundAggregateArgs> = {
        [P in keyof T & keyof AggregateFund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFund[P]>
      : GetScalarType<T[P], AggregateFund[P]>
  }




  export type FundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FundWhereInput
    orderBy?: FundOrderByWithAggregationInput | FundOrderByWithAggregationInput[]
    by: FundScalarFieldEnum[] | FundScalarFieldEnum
    having?: FundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FundCountAggregateInputType | true
    _avg?: FundAvgAggregateInputType
    _sum?: FundSumAggregateInputType
    _min?: FundMinAggregateInputType
    _max?: FundMaxAggregateInputType
  }

  export type FundGroupByOutputType = {
    id: number
    fundManagerId: number
    name: string
    minimumInvestmentAmount: bigint
    totalFundCharge: Decimal
    totalFundCost: Decimal
    totalAssets: bigint
    isActive: boolean
    maxInvestors: number
    createdAt: Date
    updatedAt: Date
    _count: FundCountAggregateOutputType | null
    _avg: FundAvgAggregateOutputType | null
    _sum: FundSumAggregateOutputType | null
    _min: FundMinAggregateOutputType | null
    _max: FundMaxAggregateOutputType | null
  }

  type GetFundGroupByPayload<T extends FundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FundGroupByOutputType[P]>
            : GetScalarType<T[P], FundGroupByOutputType[P]>
        }
      >
    >


  export type FundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fundManagerId?: boolean
    name?: boolean
    minimumInvestmentAmount?: boolean
    totalFundCharge?: boolean
    totalFundCost?: boolean
    totalAssets?: boolean
    isActive?: boolean
    maxInvestors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fundManager?: boolean | UserDefaultArgs<ExtArgs>
    trades?: boolean | Fund$tradesArgs<ExtArgs>
    holdings?: boolean | Fund$holdingsArgs<ExtArgs>
    hedgeFunds?: boolean | Fund$hedgeFundsArgs<ExtArgs>
    _count?: boolean | FundCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fund"]>

  export type FundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fundManagerId?: boolean
    name?: boolean
    minimumInvestmentAmount?: boolean
    totalFundCharge?: boolean
    totalFundCost?: boolean
    totalAssets?: boolean
    isActive?: boolean
    maxInvestors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fundManager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fund"]>

  export type FundSelectScalar = {
    id?: boolean
    fundManagerId?: boolean
    name?: boolean
    minimumInvestmentAmount?: boolean
    totalFundCharge?: boolean
    totalFundCost?: boolean
    totalAssets?: boolean
    isActive?: boolean
    maxInvestors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fundManager?: boolean | UserDefaultArgs<ExtArgs>
    trades?: boolean | Fund$tradesArgs<ExtArgs>
    holdings?: boolean | Fund$holdingsArgs<ExtArgs>
    hedgeFunds?: boolean | Fund$hedgeFundsArgs<ExtArgs>
    _count?: boolean | FundCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fundManager?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fund"
    objects: {
      fundManager: Prisma.$UserPayload<ExtArgs>
      trades: Prisma.$TradePayload<ExtArgs>[]
      holdings: Prisma.$PortfolioHoldingPayload<ExtArgs>[]
      hedgeFunds: Prisma.$HedgeFundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fundManagerId: number
      name: string
      minimumInvestmentAmount: bigint
      totalFundCharge: Prisma.Decimal
      totalFundCost: Prisma.Decimal
      totalAssets: bigint
      isActive: boolean
      maxInvestors: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fund"]>
    composites: {}
  }

  type FundGetPayload<S extends boolean | null | undefined | FundDefaultArgs> = $Result.GetResult<Prisma.$FundPayload, S>

  type FundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FundCountAggregateInputType | true
    }

  export interface FundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fund'], meta: { name: 'Fund' } }
    /**
     * Find zero or one Fund that matches the filter.
     * @param {FundFindUniqueArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FundFindUniqueArgs>(args: SelectSubset<T, FundFindUniqueArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Fund that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FundFindUniqueOrThrowArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FundFindUniqueOrThrowArgs>(args: SelectSubset<T, FundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Fund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundFindFirstArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FundFindFirstArgs>(args?: SelectSubset<T, FundFindFirstArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Fund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundFindFirstOrThrowArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FundFindFirstOrThrowArgs>(args?: SelectSubset<T, FundFindFirstOrThrowArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Funds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funds
     * const funds = await prisma.fund.findMany()
     * 
     * // Get first 10 Funds
     * const funds = await prisma.fund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fundWithIdOnly = await prisma.fund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FundFindManyArgs>(args?: SelectSubset<T, FundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Fund.
     * @param {FundCreateArgs} args - Arguments to create a Fund.
     * @example
     * // Create one Fund
     * const Fund = await prisma.fund.create({
     *   data: {
     *     // ... data to create a Fund
     *   }
     * })
     * 
     */
    create<T extends FundCreateArgs>(args: SelectSubset<T, FundCreateArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Funds.
     * @param {FundCreateManyArgs} args - Arguments to create many Funds.
     * @example
     * // Create many Funds
     * const fund = await prisma.fund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FundCreateManyArgs>(args?: SelectSubset<T, FundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Funds and returns the data saved in the database.
     * @param {FundCreateManyAndReturnArgs} args - Arguments to create many Funds.
     * @example
     * // Create many Funds
     * const fund = await prisma.fund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Funds and only return the `id`
     * const fundWithIdOnly = await prisma.fund.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FundCreateManyAndReturnArgs>(args?: SelectSubset<T, FundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Fund.
     * @param {FundDeleteArgs} args - Arguments to delete one Fund.
     * @example
     * // Delete one Fund
     * const Fund = await prisma.fund.delete({
     *   where: {
     *     // ... filter to delete one Fund
     *   }
     * })
     * 
     */
    delete<T extends FundDeleteArgs>(args: SelectSubset<T, FundDeleteArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Fund.
     * @param {FundUpdateArgs} args - Arguments to update one Fund.
     * @example
     * // Update one Fund
     * const fund = await prisma.fund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FundUpdateArgs>(args: SelectSubset<T, FundUpdateArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Funds.
     * @param {FundDeleteManyArgs} args - Arguments to filter Funds to delete.
     * @example
     * // Delete a few Funds
     * const { count } = await prisma.fund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FundDeleteManyArgs>(args?: SelectSubset<T, FundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funds
     * const fund = await prisma.fund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FundUpdateManyArgs>(args: SelectSubset<T, FundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fund.
     * @param {FundUpsertArgs} args - Arguments to update or create a Fund.
     * @example
     * // Update or create a Fund
     * const fund = await prisma.fund.upsert({
     *   create: {
     *     // ... data to create a Fund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fund we want to update
     *   }
     * })
     */
    upsert<T extends FundUpsertArgs>(args: SelectSubset<T, FundUpsertArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Funds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundCountArgs} args - Arguments to filter Funds to count.
     * @example
     * // Count the number of Funds
     * const count = await prisma.fund.count({
     *   where: {
     *     // ... the filter for the Funds we want to count
     *   }
     * })
    **/
    count<T extends FundCountArgs>(
      args?: Subset<T, FundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FundAggregateArgs>(args: Subset<T, FundAggregateArgs>): Prisma.PrismaPromise<GetFundAggregateType<T>>

    /**
     * Group by Fund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FundGroupByArgs['orderBy'] }
        : { orderBy?: FundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fund model
   */
  readonly fields: FundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fundManager<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trades<T extends Fund$tradesArgs<ExtArgs> = {}>(args?: Subset<T, Fund$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany"> | Null>
    holdings<T extends Fund$holdingsArgs<ExtArgs> = {}>(args?: Subset<T, Fund$holdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "findMany"> | Null>
    hedgeFunds<T extends Fund$hedgeFundsArgs<ExtArgs> = {}>(args?: Subset<T, Fund$hedgeFundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fund model
   */ 
  interface FundFieldRefs {
    readonly id: FieldRef<"Fund", 'Int'>
    readonly fundManagerId: FieldRef<"Fund", 'Int'>
    readonly name: FieldRef<"Fund", 'String'>
    readonly minimumInvestmentAmount: FieldRef<"Fund", 'BigInt'>
    readonly totalFundCharge: FieldRef<"Fund", 'Decimal'>
    readonly totalFundCost: FieldRef<"Fund", 'Decimal'>
    readonly totalAssets: FieldRef<"Fund", 'BigInt'>
    readonly isActive: FieldRef<"Fund", 'Boolean'>
    readonly maxInvestors: FieldRef<"Fund", 'Int'>
    readonly createdAt: FieldRef<"Fund", 'DateTime'>
    readonly updatedAt: FieldRef<"Fund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fund findUnique
   */
  export type FundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund findUniqueOrThrow
   */
  export type FundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund findFirst
   */
  export type FundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funds.
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funds.
     */
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * Fund findFirstOrThrow
   */
  export type FundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funds.
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funds.
     */
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * Fund findMany
   */
  export type FundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Funds to fetch.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Funds.
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * Fund create
   */
  export type FundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * The data needed to create a Fund.
     */
    data: XOR<FundCreateInput, FundUncheckedCreateInput>
  }

  /**
   * Fund createMany
   */
  export type FundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Funds.
     */
    data: FundCreateManyInput | FundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fund createManyAndReturn
   */
  export type FundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Funds.
     */
    data: FundCreateManyInput | FundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fund update
   */
  export type FundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * The data needed to update a Fund.
     */
    data: XOR<FundUpdateInput, FundUncheckedUpdateInput>
    /**
     * Choose, which Fund to update.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund updateMany
   */
  export type FundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Funds.
     */
    data: XOR<FundUpdateManyMutationInput, FundUncheckedUpdateManyInput>
    /**
     * Filter which Funds to update
     */
    where?: FundWhereInput
  }

  /**
   * Fund upsert
   */
  export type FundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * The filter to search for the Fund to update in case it exists.
     */
    where: FundWhereUniqueInput
    /**
     * In case the Fund found by the `where` argument doesn't exist, create a new Fund with this data.
     */
    create: XOR<FundCreateInput, FundUncheckedCreateInput>
    /**
     * In case the Fund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FundUpdateInput, FundUncheckedUpdateInput>
  }

  /**
   * Fund delete
   */
  export type FundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter which Fund to delete.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund deleteMany
   */
  export type FundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funds to delete
     */
    where?: FundWhereInput
  }

  /**
   * Fund.trades
   */
  export type Fund$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Fund.holdings
   */
  export type Fund$holdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    where?: PortfolioHoldingWhereInput
    orderBy?: PortfolioHoldingOrderByWithRelationInput | PortfolioHoldingOrderByWithRelationInput[]
    cursor?: PortfolioHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioHoldingScalarFieldEnum | PortfolioHoldingScalarFieldEnum[]
  }

  /**
   * Fund.hedgeFunds
   */
  export type Fund$hedgeFundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    where?: HedgeFundWhereInput
    orderBy?: HedgeFundOrderByWithRelationInput | HedgeFundOrderByWithRelationInput[]
    cursor?: HedgeFundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HedgeFundScalarFieldEnum | HedgeFundScalarFieldEnum[]
  }

  /**
   * Fund without action
   */
  export type FundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
  }


  /**
   * Model Portfolio
   */

  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  export type PortfolioAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    totalValue: number | null
  }

  export type PortfolioSumAggregateOutputType = {
    id: number | null
    userId: number | null
    totalValue: bigint | null
  }

  export type PortfolioMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    totalValue: bigint | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    totalValue: bigint | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    totalValue: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioAvgAggregateInputType = {
    id?: true
    userId?: true
    totalValue?: true
  }

  export type PortfolioSumAggregateInputType = {
    id?: true
    userId?: true
    totalValue?: true
  }

  export type PortfolioMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    totalValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    totalValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    totalValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolio to aggregate.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Portfolios
    **/
    _count?: true | PortfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioMaxAggregateInputType
  }

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>
  }




  export type PortfolioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithAggregationInput | PortfolioOrderByWithAggregationInput[]
    by: PortfolioScalarFieldEnum[] | PortfolioScalarFieldEnum
    having?: PortfolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCountAggregateInputType | true
    _avg?: PortfolioAvgAggregateInputType
    _sum?: PortfolioSumAggregateInputType
    _min?: PortfolioMinAggregateInputType
    _max?: PortfolioMaxAggregateInputType
  }

  export type PortfolioGroupByOutputType = {
    id: number
    userId: number
    name: string
    totalValue: bigint
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  type GetPortfolioGroupByPayload<T extends PortfolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    totalValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    holdings?: boolean | Portfolio$holdingsArgs<ExtArgs>
    trades?: boolean | Portfolio$tradesArgs<ExtArgs>
    _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    totalValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    totalValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    holdings?: boolean | Portfolio$holdingsArgs<ExtArgs>
    trades?: boolean | Portfolio$tradesArgs<ExtArgs>
    _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PortfolioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Portfolio"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      holdings: Prisma.$PortfolioHoldingPayload<ExtArgs>[]
      trades: Prisma.$TradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      totalValue: bigint
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolio"]>
    composites: {}
  }

  type PortfolioGetPayload<S extends boolean | null | undefined | PortfolioDefaultArgs> = $Result.GetResult<Prisma.$PortfolioPayload, S>

  type PortfolioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortfolioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortfolioCountAggregateInputType | true
    }

  export interface PortfolioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Portfolio'], meta: { name: 'Portfolio' } }
    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {PortfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioFindUniqueArgs>(args: SelectSubset<T, PortfolioFindUniqueArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Portfolio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PortfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioFindFirstArgs>(args?: SelectSubset<T, PortfolioFindFirstArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Portfolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     * 
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioFindManyArgs>(args?: SelectSubset<T, PortfolioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Portfolio.
     * @param {PortfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     * 
     */
    create<T extends PortfolioCreateArgs>(args: SelectSubset<T, PortfolioCreateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Portfolios.
     * @param {PortfolioCreateManyArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioCreateManyArgs>(args?: SelectSubset<T, PortfolioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Portfolios and returns the data saved in the database.
     * @param {PortfolioCreateManyAndReturnArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Portfolio.
     * @param {PortfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     * 
     */
    delete<T extends PortfolioDeleteArgs>(args: SelectSubset<T, PortfolioDeleteArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Portfolio.
     * @param {PortfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioUpdateArgs>(args: SelectSubset<T, PortfolioUpdateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Portfolios.
     * @param {PortfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioDeleteManyArgs>(args?: SelectSubset<T, PortfolioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioUpdateManyArgs>(args: SelectSubset<T, PortfolioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Portfolio.
     * @param {PortfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioUpsertArgs>(args: SelectSubset<T, PortfolioUpsertArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
    **/
    count<T extends PortfolioCountArgs>(
      args?: Subset<T, PortfolioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioAggregateArgs>(args: Subset<T, PortfolioAggregateArgs>): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Portfolio model
   */
  readonly fields: PortfolioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    holdings<T extends Portfolio$holdingsArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$holdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "findMany"> | Null>
    trades<T extends Portfolio$tradesArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Portfolio model
   */ 
  interface PortfolioFieldRefs {
    readonly id: FieldRef<"Portfolio", 'Int'>
    readonly userId: FieldRef<"Portfolio", 'Int'>
    readonly name: FieldRef<"Portfolio", 'String'>
    readonly totalValue: FieldRef<"Portfolio", 'BigInt'>
    readonly isActive: FieldRef<"Portfolio", 'Boolean'>
    readonly createdAt: FieldRef<"Portfolio", 'DateTime'>
    readonly updatedAt: FieldRef<"Portfolio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Portfolio findUnique
   */
  export type PortfolioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findUniqueOrThrow
   */
  export type PortfolioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findFirst
   */
  export type PortfolioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findFirstOrThrow
   */
  export type PortfolioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findMany
   */
  export type PortfolioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolios to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio create
   */
  export type PortfolioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to create a Portfolio.
     */
    data: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
  }

  /**
   * Portfolio createMany
   */
  export type PortfolioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portfolio createManyAndReturn
   */
  export type PortfolioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio update
   */
  export type PortfolioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to update a Portfolio.
     */
    data: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
    /**
     * Choose, which Portfolio to update.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio updateMany
   */
  export type PortfolioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
  }

  /**
   * Portfolio upsert
   */
  export type PortfolioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The filter to search for the Portfolio to update in case it exists.
     */
    where: PortfolioWhereUniqueInput
    /**
     * In case the Portfolio found by the `where` argument doesn't exist, create a new Portfolio with this data.
     */
    create: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
    /**
     * In case the Portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
  }

  /**
   * Portfolio delete
   */
  export type PortfolioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter which Portfolio to delete.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio deleteMany
   */
  export type PortfolioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolios to delete
     */
    where?: PortfolioWhereInput
  }

  /**
   * Portfolio.holdings
   */
  export type Portfolio$holdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    where?: PortfolioHoldingWhereInput
    orderBy?: PortfolioHoldingOrderByWithRelationInput | PortfolioHoldingOrderByWithRelationInput[]
    cursor?: PortfolioHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioHoldingScalarFieldEnum | PortfolioHoldingScalarFieldEnum[]
  }

  /**
   * Portfolio.trades
   */
  export type Portfolio$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Portfolio without action
   */
  export type PortfolioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioHolding
   */

  export type AggregatePortfolioHolding = {
    _count: PortfolioHoldingCountAggregateOutputType | null
    _avg: PortfolioHoldingAvgAggregateOutputType | null
    _sum: PortfolioHoldingSumAggregateOutputType | null
    _min: PortfolioHoldingMinAggregateOutputType | null
    _max: PortfolioHoldingMaxAggregateOutputType | null
  }

  export type PortfolioHoldingAvgAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    fundId: number | null
    quantity: number | null
    averagePrice: number | null
  }

  export type PortfolioHoldingSumAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    fundId: number | null
    quantity: bigint | null
    averagePrice: bigint | null
  }

  export type PortfolioHoldingMinAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    fundId: number | null
    quantity: bigint | null
    averagePrice: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioHoldingMaxAggregateOutputType = {
    id: number | null
    portfolioId: number | null
    fundId: number | null
    quantity: bigint | null
    averagePrice: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioHoldingCountAggregateOutputType = {
    id: number
    portfolioId: number
    fundId: number
    quantity: number
    averagePrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioHoldingAvgAggregateInputType = {
    id?: true
    portfolioId?: true
    fundId?: true
    quantity?: true
    averagePrice?: true
  }

  export type PortfolioHoldingSumAggregateInputType = {
    id?: true
    portfolioId?: true
    fundId?: true
    quantity?: true
    averagePrice?: true
  }

  export type PortfolioHoldingMinAggregateInputType = {
    id?: true
    portfolioId?: true
    fundId?: true
    quantity?: true
    averagePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioHoldingMaxAggregateInputType = {
    id?: true
    portfolioId?: true
    fundId?: true
    quantity?: true
    averagePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioHoldingCountAggregateInputType = {
    id?: true
    portfolioId?: true
    fundId?: true
    quantity?: true
    averagePrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioHoldingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioHolding to aggregate.
     */
    where?: PortfolioHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioHoldings to fetch.
     */
    orderBy?: PortfolioHoldingOrderByWithRelationInput | PortfolioHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioHoldings
    **/
    _count?: true | PortfolioHoldingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioHoldingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioHoldingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioHoldingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioHoldingMaxAggregateInputType
  }

  export type GetPortfolioHoldingAggregateType<T extends PortfolioHoldingAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioHolding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioHolding[P]>
      : GetScalarType<T[P], AggregatePortfolioHolding[P]>
  }




  export type PortfolioHoldingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioHoldingWhereInput
    orderBy?: PortfolioHoldingOrderByWithAggregationInput | PortfolioHoldingOrderByWithAggregationInput[]
    by: PortfolioHoldingScalarFieldEnum[] | PortfolioHoldingScalarFieldEnum
    having?: PortfolioHoldingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioHoldingCountAggregateInputType | true
    _avg?: PortfolioHoldingAvgAggregateInputType
    _sum?: PortfolioHoldingSumAggregateInputType
    _min?: PortfolioHoldingMinAggregateInputType
    _max?: PortfolioHoldingMaxAggregateInputType
  }

  export type PortfolioHoldingGroupByOutputType = {
    id: number
    portfolioId: number
    fundId: number
    quantity: bigint
    averagePrice: bigint
    createdAt: Date
    updatedAt: Date
    _count: PortfolioHoldingCountAggregateOutputType | null
    _avg: PortfolioHoldingAvgAggregateOutputType | null
    _sum: PortfolioHoldingSumAggregateOutputType | null
    _min: PortfolioHoldingMinAggregateOutputType | null
    _max: PortfolioHoldingMaxAggregateOutputType | null
  }

  type GetPortfolioHoldingGroupByPayload<T extends PortfolioHoldingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioHoldingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioHoldingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioHoldingGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioHoldingGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioHoldingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    fundId?: boolean
    quantity?: boolean
    averagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioHolding"]>

  export type PortfolioHoldingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    fundId?: boolean
    quantity?: boolean
    averagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioHolding"]>

  export type PortfolioHoldingSelectScalar = {
    id?: boolean
    portfolioId?: boolean
    fundId?: boolean
    quantity?: boolean
    averagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioHoldingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }
  export type PortfolioHoldingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }

  export type $PortfolioHoldingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioHolding"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
      fund: Prisma.$FundPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      portfolioId: number
      fundId: number
      quantity: bigint
      averagePrice: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioHolding"]>
    composites: {}
  }

  type PortfolioHoldingGetPayload<S extends boolean | null | undefined | PortfolioHoldingDefaultArgs> = $Result.GetResult<Prisma.$PortfolioHoldingPayload, S>

  type PortfolioHoldingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortfolioHoldingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortfolioHoldingCountAggregateInputType | true
    }

  export interface PortfolioHoldingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioHolding'], meta: { name: 'PortfolioHolding' } }
    /**
     * Find zero or one PortfolioHolding that matches the filter.
     * @param {PortfolioHoldingFindUniqueArgs} args - Arguments to find a PortfolioHolding
     * @example
     * // Get one PortfolioHolding
     * const portfolioHolding = await prisma.portfolioHolding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioHoldingFindUniqueArgs>(args: SelectSubset<T, PortfolioHoldingFindUniqueArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PortfolioHolding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PortfolioHoldingFindUniqueOrThrowArgs} args - Arguments to find a PortfolioHolding
     * @example
     * // Get one PortfolioHolding
     * const portfolioHolding = await prisma.portfolioHolding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioHoldingFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioHoldingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PortfolioHolding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioHoldingFindFirstArgs} args - Arguments to find a PortfolioHolding
     * @example
     * // Get one PortfolioHolding
     * const portfolioHolding = await prisma.portfolioHolding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioHoldingFindFirstArgs>(args?: SelectSubset<T, PortfolioHoldingFindFirstArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PortfolioHolding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioHoldingFindFirstOrThrowArgs} args - Arguments to find a PortfolioHolding
     * @example
     * // Get one PortfolioHolding
     * const portfolioHolding = await prisma.portfolioHolding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioHoldingFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioHoldingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PortfolioHoldings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioHoldingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioHoldings
     * const portfolioHoldings = await prisma.portfolioHolding.findMany()
     * 
     * // Get first 10 PortfolioHoldings
     * const portfolioHoldings = await prisma.portfolioHolding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioHoldingWithIdOnly = await prisma.portfolioHolding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioHoldingFindManyArgs>(args?: SelectSubset<T, PortfolioHoldingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PortfolioHolding.
     * @param {PortfolioHoldingCreateArgs} args - Arguments to create a PortfolioHolding.
     * @example
     * // Create one PortfolioHolding
     * const PortfolioHolding = await prisma.portfolioHolding.create({
     *   data: {
     *     // ... data to create a PortfolioHolding
     *   }
     * })
     * 
     */
    create<T extends PortfolioHoldingCreateArgs>(args: SelectSubset<T, PortfolioHoldingCreateArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PortfolioHoldings.
     * @param {PortfolioHoldingCreateManyArgs} args - Arguments to create many PortfolioHoldings.
     * @example
     * // Create many PortfolioHoldings
     * const portfolioHolding = await prisma.portfolioHolding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioHoldingCreateManyArgs>(args?: SelectSubset<T, PortfolioHoldingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioHoldings and returns the data saved in the database.
     * @param {PortfolioHoldingCreateManyAndReturnArgs} args - Arguments to create many PortfolioHoldings.
     * @example
     * // Create many PortfolioHoldings
     * const portfolioHolding = await prisma.portfolioHolding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioHoldings and only return the `id`
     * const portfolioHoldingWithIdOnly = await prisma.portfolioHolding.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioHoldingCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioHoldingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PortfolioHolding.
     * @param {PortfolioHoldingDeleteArgs} args - Arguments to delete one PortfolioHolding.
     * @example
     * // Delete one PortfolioHolding
     * const PortfolioHolding = await prisma.portfolioHolding.delete({
     *   where: {
     *     // ... filter to delete one PortfolioHolding
     *   }
     * })
     * 
     */
    delete<T extends PortfolioHoldingDeleteArgs>(args: SelectSubset<T, PortfolioHoldingDeleteArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PortfolioHolding.
     * @param {PortfolioHoldingUpdateArgs} args - Arguments to update one PortfolioHolding.
     * @example
     * // Update one PortfolioHolding
     * const portfolioHolding = await prisma.portfolioHolding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioHoldingUpdateArgs>(args: SelectSubset<T, PortfolioHoldingUpdateArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PortfolioHoldings.
     * @param {PortfolioHoldingDeleteManyArgs} args - Arguments to filter PortfolioHoldings to delete.
     * @example
     * // Delete a few PortfolioHoldings
     * const { count } = await prisma.portfolioHolding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioHoldingDeleteManyArgs>(args?: SelectSubset<T, PortfolioHoldingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioHoldingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioHoldings
     * const portfolioHolding = await prisma.portfolioHolding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioHoldingUpdateManyArgs>(args: SelectSubset<T, PortfolioHoldingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PortfolioHolding.
     * @param {PortfolioHoldingUpsertArgs} args - Arguments to update or create a PortfolioHolding.
     * @example
     * // Update or create a PortfolioHolding
     * const portfolioHolding = await prisma.portfolioHolding.upsert({
     *   create: {
     *     // ... data to create a PortfolioHolding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioHolding we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioHoldingUpsertArgs>(args: SelectSubset<T, PortfolioHoldingUpsertArgs<ExtArgs>>): Prisma__PortfolioHoldingClient<$Result.GetResult<Prisma.$PortfolioHoldingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PortfolioHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioHoldingCountArgs} args - Arguments to filter PortfolioHoldings to count.
     * @example
     * // Count the number of PortfolioHoldings
     * const count = await prisma.portfolioHolding.count({
     *   where: {
     *     // ... the filter for the PortfolioHoldings we want to count
     *   }
     * })
    **/
    count<T extends PortfolioHoldingCountArgs>(
      args?: Subset<T, PortfolioHoldingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioHoldingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioHoldingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioHoldingAggregateArgs>(args: Subset<T, PortfolioHoldingAggregateArgs>): Prisma.PrismaPromise<GetPortfolioHoldingAggregateType<T>>

    /**
     * Group by PortfolioHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioHoldingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioHoldingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioHoldingGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioHoldingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioHoldingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioHoldingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioHolding model
   */
  readonly fields: PortfolioHoldingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioHolding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioHoldingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fund<T extends FundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FundDefaultArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioHolding model
   */ 
  interface PortfolioHoldingFieldRefs {
    readonly id: FieldRef<"PortfolioHolding", 'Int'>
    readonly portfolioId: FieldRef<"PortfolioHolding", 'Int'>
    readonly fundId: FieldRef<"PortfolioHolding", 'Int'>
    readonly quantity: FieldRef<"PortfolioHolding", 'BigInt'>
    readonly averagePrice: FieldRef<"PortfolioHolding", 'BigInt'>
    readonly createdAt: FieldRef<"PortfolioHolding", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioHolding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioHolding findUnique
   */
  export type PortfolioHoldingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioHolding to fetch.
     */
    where: PortfolioHoldingWhereUniqueInput
  }

  /**
   * PortfolioHolding findUniqueOrThrow
   */
  export type PortfolioHoldingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioHolding to fetch.
     */
    where: PortfolioHoldingWhereUniqueInput
  }

  /**
   * PortfolioHolding findFirst
   */
  export type PortfolioHoldingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioHolding to fetch.
     */
    where?: PortfolioHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioHoldings to fetch.
     */
    orderBy?: PortfolioHoldingOrderByWithRelationInput | PortfolioHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioHoldings.
     */
    cursor?: PortfolioHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioHoldings.
     */
    distinct?: PortfolioHoldingScalarFieldEnum | PortfolioHoldingScalarFieldEnum[]
  }

  /**
   * PortfolioHolding findFirstOrThrow
   */
  export type PortfolioHoldingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioHolding to fetch.
     */
    where?: PortfolioHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioHoldings to fetch.
     */
    orderBy?: PortfolioHoldingOrderByWithRelationInput | PortfolioHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioHoldings.
     */
    cursor?: PortfolioHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioHoldings.
     */
    distinct?: PortfolioHoldingScalarFieldEnum | PortfolioHoldingScalarFieldEnum[]
  }

  /**
   * PortfolioHolding findMany
   */
  export type PortfolioHoldingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioHoldings to fetch.
     */
    where?: PortfolioHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioHoldings to fetch.
     */
    orderBy?: PortfolioHoldingOrderByWithRelationInput | PortfolioHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioHoldings.
     */
    cursor?: PortfolioHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioHoldings.
     */
    skip?: number
    distinct?: PortfolioHoldingScalarFieldEnum | PortfolioHoldingScalarFieldEnum[]
  }

  /**
   * PortfolioHolding create
   */
  export type PortfolioHoldingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioHolding.
     */
    data: XOR<PortfolioHoldingCreateInput, PortfolioHoldingUncheckedCreateInput>
  }

  /**
   * PortfolioHolding createMany
   */
  export type PortfolioHoldingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioHoldings.
     */
    data: PortfolioHoldingCreateManyInput | PortfolioHoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioHolding createManyAndReturn
   */
  export type PortfolioHoldingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PortfolioHoldings.
     */
    data: PortfolioHoldingCreateManyInput | PortfolioHoldingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioHolding update
   */
  export type PortfolioHoldingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioHolding.
     */
    data: XOR<PortfolioHoldingUpdateInput, PortfolioHoldingUncheckedUpdateInput>
    /**
     * Choose, which PortfolioHolding to update.
     */
    where: PortfolioHoldingWhereUniqueInput
  }

  /**
   * PortfolioHolding updateMany
   */
  export type PortfolioHoldingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioHoldings.
     */
    data: XOR<PortfolioHoldingUpdateManyMutationInput, PortfolioHoldingUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioHoldings to update
     */
    where?: PortfolioHoldingWhereInput
  }

  /**
   * PortfolioHolding upsert
   */
  export type PortfolioHoldingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioHolding to update in case it exists.
     */
    where: PortfolioHoldingWhereUniqueInput
    /**
     * In case the PortfolioHolding found by the `where` argument doesn't exist, create a new PortfolioHolding with this data.
     */
    create: XOR<PortfolioHoldingCreateInput, PortfolioHoldingUncheckedCreateInput>
    /**
     * In case the PortfolioHolding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioHoldingUpdateInput, PortfolioHoldingUncheckedUpdateInput>
  }

  /**
   * PortfolioHolding delete
   */
  export type PortfolioHoldingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
    /**
     * Filter which PortfolioHolding to delete.
     */
    where: PortfolioHoldingWhereUniqueInput
  }

  /**
   * PortfolioHolding deleteMany
   */
  export type PortfolioHoldingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioHoldings to delete
     */
    where?: PortfolioHoldingWhereInput
  }

  /**
   * PortfolioHolding without action
   */
  export type PortfolioHoldingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioHolding
     */
    select?: PortfolioHoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioHoldingInclude<ExtArgs> | null
  }


  /**
   * Model HedgeFund
   */

  export type AggregateHedgeFund = {
    _count: HedgeFundCountAggregateOutputType | null
    _avg: HedgeFundAvgAggregateOutputType | null
    _sum: HedgeFundSumAggregateOutputType | null
    _min: HedgeFundMinAggregateOutputType | null
    _max: HedgeFundMaxAggregateOutputType | null
  }

  export type HedgeFundAvgAggregateOutputType = {
    id: number | null
    fundId: number | null
    minimumLockPeriod: number | null
    managementFee: Decimal | null
    performanceFee: Decimal | null
    highWaterMark: number | null
  }

  export type HedgeFundSumAggregateOutputType = {
    id: number | null
    fundId: number | null
    minimumLockPeriod: number | null
    managementFee: Decimal | null
    performanceFee: Decimal | null
    highWaterMark: bigint | null
  }

  export type HedgeFundMinAggregateOutputType = {
    id: number | null
    fundId: number | null
    strategy: string | null
    riskLevel: string | null
    minimumLockPeriod: number | null
    managementFee: Decimal | null
    performanceFee: Decimal | null
    highWaterMark: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HedgeFundMaxAggregateOutputType = {
    id: number | null
    fundId: number | null
    strategy: string | null
    riskLevel: string | null
    minimumLockPeriod: number | null
    managementFee: Decimal | null
    performanceFee: Decimal | null
    highWaterMark: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HedgeFundCountAggregateOutputType = {
    id: number
    fundId: number
    strategy: number
    riskLevel: number
    minimumLockPeriod: number
    managementFee: number
    performanceFee: number
    highWaterMark: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HedgeFundAvgAggregateInputType = {
    id?: true
    fundId?: true
    minimumLockPeriod?: true
    managementFee?: true
    performanceFee?: true
    highWaterMark?: true
  }

  export type HedgeFundSumAggregateInputType = {
    id?: true
    fundId?: true
    minimumLockPeriod?: true
    managementFee?: true
    performanceFee?: true
    highWaterMark?: true
  }

  export type HedgeFundMinAggregateInputType = {
    id?: true
    fundId?: true
    strategy?: true
    riskLevel?: true
    minimumLockPeriod?: true
    managementFee?: true
    performanceFee?: true
    highWaterMark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HedgeFundMaxAggregateInputType = {
    id?: true
    fundId?: true
    strategy?: true
    riskLevel?: true
    minimumLockPeriod?: true
    managementFee?: true
    performanceFee?: true
    highWaterMark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HedgeFundCountAggregateInputType = {
    id?: true
    fundId?: true
    strategy?: true
    riskLevel?: true
    minimumLockPeriod?: true
    managementFee?: true
    performanceFee?: true
    highWaterMark?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HedgeFundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HedgeFund to aggregate.
     */
    where?: HedgeFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HedgeFunds to fetch.
     */
    orderBy?: HedgeFundOrderByWithRelationInput | HedgeFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HedgeFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HedgeFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HedgeFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HedgeFunds
    **/
    _count?: true | HedgeFundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HedgeFundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HedgeFundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HedgeFundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HedgeFundMaxAggregateInputType
  }

  export type GetHedgeFundAggregateType<T extends HedgeFundAggregateArgs> = {
        [P in keyof T & keyof AggregateHedgeFund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHedgeFund[P]>
      : GetScalarType<T[P], AggregateHedgeFund[P]>
  }




  export type HedgeFundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HedgeFundWhereInput
    orderBy?: HedgeFundOrderByWithAggregationInput | HedgeFundOrderByWithAggregationInput[]
    by: HedgeFundScalarFieldEnum[] | HedgeFundScalarFieldEnum
    having?: HedgeFundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HedgeFundCountAggregateInputType | true
    _avg?: HedgeFundAvgAggregateInputType
    _sum?: HedgeFundSumAggregateInputType
    _min?: HedgeFundMinAggregateInputType
    _max?: HedgeFundMaxAggregateInputType
  }

  export type HedgeFundGroupByOutputType = {
    id: number
    fundId: number
    strategy: string
    riskLevel: string
    minimumLockPeriod: number
    managementFee: Decimal
    performanceFee: Decimal
    highWaterMark: bigint
    createdAt: Date
    updatedAt: Date
    _count: HedgeFundCountAggregateOutputType | null
    _avg: HedgeFundAvgAggregateOutputType | null
    _sum: HedgeFundSumAggregateOutputType | null
    _min: HedgeFundMinAggregateOutputType | null
    _max: HedgeFundMaxAggregateOutputType | null
  }

  type GetHedgeFundGroupByPayload<T extends HedgeFundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HedgeFundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HedgeFundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HedgeFundGroupByOutputType[P]>
            : GetScalarType<T[P], HedgeFundGroupByOutputType[P]>
        }
      >
    >


  export type HedgeFundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fundId?: boolean
    strategy?: boolean
    riskLevel?: boolean
    minimumLockPeriod?: boolean
    managementFee?: boolean
    performanceFee?: boolean
    highWaterMark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hedgeFund"]>

  export type HedgeFundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fundId?: boolean
    strategy?: boolean
    riskLevel?: boolean
    minimumLockPeriod?: boolean
    managementFee?: boolean
    performanceFee?: boolean
    highWaterMark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hedgeFund"]>

  export type HedgeFundSelectScalar = {
    id?: boolean
    fundId?: boolean
    strategy?: boolean
    riskLevel?: boolean
    minimumLockPeriod?: boolean
    managementFee?: boolean
    performanceFee?: boolean
    highWaterMark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HedgeFundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }
  export type HedgeFundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fund?: boolean | FundDefaultArgs<ExtArgs>
  }

  export type $HedgeFundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HedgeFund"
    objects: {
      fund: Prisma.$FundPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fundId: number
      strategy: string
      riskLevel: string
      minimumLockPeriod: number
      managementFee: Prisma.Decimal
      performanceFee: Prisma.Decimal
      highWaterMark: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hedgeFund"]>
    composites: {}
  }

  type HedgeFundGetPayload<S extends boolean | null | undefined | HedgeFundDefaultArgs> = $Result.GetResult<Prisma.$HedgeFundPayload, S>

  type HedgeFundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HedgeFundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HedgeFundCountAggregateInputType | true
    }

  export interface HedgeFundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HedgeFund'], meta: { name: 'HedgeFund' } }
    /**
     * Find zero or one HedgeFund that matches the filter.
     * @param {HedgeFundFindUniqueArgs} args - Arguments to find a HedgeFund
     * @example
     * // Get one HedgeFund
     * const hedgeFund = await prisma.hedgeFund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HedgeFundFindUniqueArgs>(args: SelectSubset<T, HedgeFundFindUniqueArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HedgeFund that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HedgeFundFindUniqueOrThrowArgs} args - Arguments to find a HedgeFund
     * @example
     * // Get one HedgeFund
     * const hedgeFund = await prisma.hedgeFund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HedgeFundFindUniqueOrThrowArgs>(args: SelectSubset<T, HedgeFundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HedgeFund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HedgeFundFindFirstArgs} args - Arguments to find a HedgeFund
     * @example
     * // Get one HedgeFund
     * const hedgeFund = await prisma.hedgeFund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HedgeFundFindFirstArgs>(args?: SelectSubset<T, HedgeFundFindFirstArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HedgeFund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HedgeFundFindFirstOrThrowArgs} args - Arguments to find a HedgeFund
     * @example
     * // Get one HedgeFund
     * const hedgeFund = await prisma.hedgeFund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HedgeFundFindFirstOrThrowArgs>(args?: SelectSubset<T, HedgeFundFindFirstOrThrowArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HedgeFunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HedgeFundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HedgeFunds
     * const hedgeFunds = await prisma.hedgeFund.findMany()
     * 
     * // Get first 10 HedgeFunds
     * const hedgeFunds = await prisma.hedgeFund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hedgeFundWithIdOnly = await prisma.hedgeFund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HedgeFundFindManyArgs>(args?: SelectSubset<T, HedgeFundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HedgeFund.
     * @param {HedgeFundCreateArgs} args - Arguments to create a HedgeFund.
     * @example
     * // Create one HedgeFund
     * const HedgeFund = await prisma.hedgeFund.create({
     *   data: {
     *     // ... data to create a HedgeFund
     *   }
     * })
     * 
     */
    create<T extends HedgeFundCreateArgs>(args: SelectSubset<T, HedgeFundCreateArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HedgeFunds.
     * @param {HedgeFundCreateManyArgs} args - Arguments to create many HedgeFunds.
     * @example
     * // Create many HedgeFunds
     * const hedgeFund = await prisma.hedgeFund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HedgeFundCreateManyArgs>(args?: SelectSubset<T, HedgeFundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HedgeFunds and returns the data saved in the database.
     * @param {HedgeFundCreateManyAndReturnArgs} args - Arguments to create many HedgeFunds.
     * @example
     * // Create many HedgeFunds
     * const hedgeFund = await prisma.hedgeFund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HedgeFunds and only return the `id`
     * const hedgeFundWithIdOnly = await prisma.hedgeFund.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HedgeFundCreateManyAndReturnArgs>(args?: SelectSubset<T, HedgeFundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HedgeFund.
     * @param {HedgeFundDeleteArgs} args - Arguments to delete one HedgeFund.
     * @example
     * // Delete one HedgeFund
     * const HedgeFund = await prisma.hedgeFund.delete({
     *   where: {
     *     // ... filter to delete one HedgeFund
     *   }
     * })
     * 
     */
    delete<T extends HedgeFundDeleteArgs>(args: SelectSubset<T, HedgeFundDeleteArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HedgeFund.
     * @param {HedgeFundUpdateArgs} args - Arguments to update one HedgeFund.
     * @example
     * // Update one HedgeFund
     * const hedgeFund = await prisma.hedgeFund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HedgeFundUpdateArgs>(args: SelectSubset<T, HedgeFundUpdateArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HedgeFunds.
     * @param {HedgeFundDeleteManyArgs} args - Arguments to filter HedgeFunds to delete.
     * @example
     * // Delete a few HedgeFunds
     * const { count } = await prisma.hedgeFund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HedgeFundDeleteManyArgs>(args?: SelectSubset<T, HedgeFundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HedgeFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HedgeFundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HedgeFunds
     * const hedgeFund = await prisma.hedgeFund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HedgeFundUpdateManyArgs>(args: SelectSubset<T, HedgeFundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HedgeFund.
     * @param {HedgeFundUpsertArgs} args - Arguments to update or create a HedgeFund.
     * @example
     * // Update or create a HedgeFund
     * const hedgeFund = await prisma.hedgeFund.upsert({
     *   create: {
     *     // ... data to create a HedgeFund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HedgeFund we want to update
     *   }
     * })
     */
    upsert<T extends HedgeFundUpsertArgs>(args: SelectSubset<T, HedgeFundUpsertArgs<ExtArgs>>): Prisma__HedgeFundClient<$Result.GetResult<Prisma.$HedgeFundPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HedgeFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HedgeFundCountArgs} args - Arguments to filter HedgeFunds to count.
     * @example
     * // Count the number of HedgeFunds
     * const count = await prisma.hedgeFund.count({
     *   where: {
     *     // ... the filter for the HedgeFunds we want to count
     *   }
     * })
    **/
    count<T extends HedgeFundCountArgs>(
      args?: Subset<T, HedgeFundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HedgeFundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HedgeFund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HedgeFundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HedgeFundAggregateArgs>(args: Subset<T, HedgeFundAggregateArgs>): Prisma.PrismaPromise<GetHedgeFundAggregateType<T>>

    /**
     * Group by HedgeFund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HedgeFundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HedgeFundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HedgeFundGroupByArgs['orderBy'] }
        : { orderBy?: HedgeFundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HedgeFundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHedgeFundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HedgeFund model
   */
  readonly fields: HedgeFundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HedgeFund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HedgeFundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fund<T extends FundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FundDefaultArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HedgeFund model
   */ 
  interface HedgeFundFieldRefs {
    readonly id: FieldRef<"HedgeFund", 'Int'>
    readonly fundId: FieldRef<"HedgeFund", 'Int'>
    readonly strategy: FieldRef<"HedgeFund", 'String'>
    readonly riskLevel: FieldRef<"HedgeFund", 'String'>
    readonly minimumLockPeriod: FieldRef<"HedgeFund", 'Int'>
    readonly managementFee: FieldRef<"HedgeFund", 'Decimal'>
    readonly performanceFee: FieldRef<"HedgeFund", 'Decimal'>
    readonly highWaterMark: FieldRef<"HedgeFund", 'BigInt'>
    readonly createdAt: FieldRef<"HedgeFund", 'DateTime'>
    readonly updatedAt: FieldRef<"HedgeFund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HedgeFund findUnique
   */
  export type HedgeFundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * Filter, which HedgeFund to fetch.
     */
    where: HedgeFundWhereUniqueInput
  }

  /**
   * HedgeFund findUniqueOrThrow
   */
  export type HedgeFundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * Filter, which HedgeFund to fetch.
     */
    where: HedgeFundWhereUniqueInput
  }

  /**
   * HedgeFund findFirst
   */
  export type HedgeFundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * Filter, which HedgeFund to fetch.
     */
    where?: HedgeFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HedgeFunds to fetch.
     */
    orderBy?: HedgeFundOrderByWithRelationInput | HedgeFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HedgeFunds.
     */
    cursor?: HedgeFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HedgeFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HedgeFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HedgeFunds.
     */
    distinct?: HedgeFundScalarFieldEnum | HedgeFundScalarFieldEnum[]
  }

  /**
   * HedgeFund findFirstOrThrow
   */
  export type HedgeFundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * Filter, which HedgeFund to fetch.
     */
    where?: HedgeFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HedgeFunds to fetch.
     */
    orderBy?: HedgeFundOrderByWithRelationInput | HedgeFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HedgeFunds.
     */
    cursor?: HedgeFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HedgeFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HedgeFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HedgeFunds.
     */
    distinct?: HedgeFundScalarFieldEnum | HedgeFundScalarFieldEnum[]
  }

  /**
   * HedgeFund findMany
   */
  export type HedgeFundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * Filter, which HedgeFunds to fetch.
     */
    where?: HedgeFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HedgeFunds to fetch.
     */
    orderBy?: HedgeFundOrderByWithRelationInput | HedgeFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HedgeFunds.
     */
    cursor?: HedgeFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HedgeFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HedgeFunds.
     */
    skip?: number
    distinct?: HedgeFundScalarFieldEnum | HedgeFundScalarFieldEnum[]
  }

  /**
   * HedgeFund create
   */
  export type HedgeFundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * The data needed to create a HedgeFund.
     */
    data: XOR<HedgeFundCreateInput, HedgeFundUncheckedCreateInput>
  }

  /**
   * HedgeFund createMany
   */
  export type HedgeFundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HedgeFunds.
     */
    data: HedgeFundCreateManyInput | HedgeFundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HedgeFund createManyAndReturn
   */
  export type HedgeFundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HedgeFunds.
     */
    data: HedgeFundCreateManyInput | HedgeFundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HedgeFund update
   */
  export type HedgeFundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * The data needed to update a HedgeFund.
     */
    data: XOR<HedgeFundUpdateInput, HedgeFundUncheckedUpdateInput>
    /**
     * Choose, which HedgeFund to update.
     */
    where: HedgeFundWhereUniqueInput
  }

  /**
   * HedgeFund updateMany
   */
  export type HedgeFundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HedgeFunds.
     */
    data: XOR<HedgeFundUpdateManyMutationInput, HedgeFundUncheckedUpdateManyInput>
    /**
     * Filter which HedgeFunds to update
     */
    where?: HedgeFundWhereInput
  }

  /**
   * HedgeFund upsert
   */
  export type HedgeFundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * The filter to search for the HedgeFund to update in case it exists.
     */
    where: HedgeFundWhereUniqueInput
    /**
     * In case the HedgeFund found by the `where` argument doesn't exist, create a new HedgeFund with this data.
     */
    create: XOR<HedgeFundCreateInput, HedgeFundUncheckedCreateInput>
    /**
     * In case the HedgeFund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HedgeFundUpdateInput, HedgeFundUncheckedUpdateInput>
  }

  /**
   * HedgeFund delete
   */
  export type HedgeFundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
    /**
     * Filter which HedgeFund to delete.
     */
    where: HedgeFundWhereUniqueInput
  }

  /**
   * HedgeFund deleteMany
   */
  export type HedgeFundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HedgeFunds to delete
     */
    where?: HedgeFundWhereInput
  }

  /**
   * HedgeFund without action
   */
  export type HedgeFundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HedgeFund
     */
    select?: HedgeFundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HedgeFundInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    salt: 'salt',
    lastAction: 'lastAction',
    created: 'created',
    refreshToken: 'refreshToken',
    group: 'group'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    started: 'started',
    ended: 'ended'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    lastAction: 'lastAction',
    created: 'created',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const HardwareScalarFieldEnum: {
    id: 'id',
    computerId: 'computerId',
    gameId: 'gameId',
    type: 'type',
    strength: 'strength'
  };

  export type HardwareScalarFieldEnum = (typeof HardwareScalarFieldEnum)[keyof typeof HardwareScalarFieldEnum]


  export const AddressBookScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    access: 'access',
    computerId: 'computerId',
    ip: 'ip',
    data: 'data',
    gameId: 'gameId'
  };

  export type AddressBookScalarFieldEnum = (typeof AddressBookScalarFieldEnum)[keyof typeof AddressBookScalarFieldEnum]


  export const DNSScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    gameId: 'gameId',
    website: 'website',
    tags: 'tags',
    description: 'description',
    updated: 'updated',
    created: 'created'
  };

  export type DNSScalarFieldEnum = (typeof DNSScalarFieldEnum)[keyof typeof DNSScalarFieldEnum]


  export const AccountBookScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    memoryId: 'memoryId',
    data: 'data',
    gameId: 'gameId'
  };

  export type AccountBookScalarFieldEnum = (typeof AccountBookScalarFieldEnum)[keyof typeof AccountBookScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    data: 'data'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const MemoryScalarFieldEnum: {
    id: 'id',
    computerId: 'computerId',
    gameId: 'gameId',
    userId: 'userId',
    type: 'type',
    key: 'key',
    value: 'value',
    data: 'data'
  };

  export type MemoryScalarFieldEnum = (typeof MemoryScalarFieldEnum)[keyof typeof MemoryScalarFieldEnum]


  export const ComputerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    gameId: 'gameId',
    ip: 'ip',
    data: 'data',
    created: 'created',
    updated: 'updated'
  };

  export type ComputerScalarFieldEnum = (typeof ComputerScalarFieldEnum)[keyof typeof ComputerScalarFieldEnum]


  export const QuestsScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    type: 'type',
    title: 'title',
    reward: 'reward',
    open: 'open'
  };

  export type QuestsScalarFieldEnum = (typeof QuestsScalarFieldEnum)[keyof typeof QuestsScalarFieldEnum]


  export const UserQuestsScalarFieldEnum: {
    id: 'id',
    questsId: 'questsId',
    userId: 'userId',
    gameId: 'gameId',
    completed: 'completed',
    created: 'created',
    updated: 'updated'
  };

  export type UserQuestsScalarFieldEnum = (typeof UserQuestsScalarFieldEnum)[keyof typeof UserQuestsScalarFieldEnum]


  export const SoftwareScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    gameId: 'gameId',
    type: 'type',
    level: 'level',
    size: 'size',
    opacity: 'opacity',
    installed: 'installed',
    executed: 'executed',
    created: 'created',
    updated: 'updated',
    data: 'data'
  };

  export type SoftwareScalarFieldEnum = (typeof SoftwareScalarFieldEnum)[keyof typeof SoftwareScalarFieldEnum]


  export const ProcessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    ip: 'ip',
    gameId: 'gameId',
    type: 'type',
    started: 'started',
    completion: 'completion',
    data: 'data'
  };

  export type ProcessScalarFieldEnum = (typeof ProcessScalarFieldEnum)[keyof typeof ProcessScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    content: 'content',
    read: 'read'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const LogsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    computerId: 'computerId',
    senderId: 'senderId',
    senderIp: 'senderIp',
    gameId: 'gameId',
    message: 'message',
    created: 'created'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const TradeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    marketId: 'marketId',
    portfolioId: 'portfolioId',
    type: 'type',
    quantity: 'quantity',
    price: 'price',
    totalValue: 'totalValue',
    status: 'status',
    executedAt: 'executedAt',
    createdAt: 'createdAt',
    buyIntoTargetFundid: 'buyIntoTargetFundid',
    instructionType: 'instructionType'
  };

  export type TradeScalarFieldEnum = (typeof TradeScalarFieldEnum)[keyof typeof TradeScalarFieldEnum]


  export const FundScalarFieldEnum: {
    id: 'id',
    fundManagerId: 'fundManagerId',
    name: 'name',
    minimumInvestmentAmount: 'minimumInvestmentAmount',
    totalFundCharge: 'totalFundCharge',
    totalFundCost: 'totalFundCost',
    totalAssets: 'totalAssets',
    isActive: 'isActive',
    maxInvestors: 'maxInvestors',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FundScalarFieldEnum = (typeof FundScalarFieldEnum)[keyof typeof FundScalarFieldEnum]


  export const PortfolioScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    totalValue: 'totalValue',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioScalarFieldEnum = (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum]


  export const PortfolioHoldingScalarFieldEnum: {
    id: 'id',
    portfolioId: 'portfolioId',
    fundId: 'fundId',
    quantity: 'quantity',
    averagePrice: 'averagePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioHoldingScalarFieldEnum = (typeof PortfolioHoldingScalarFieldEnum)[keyof typeof PortfolioHoldingScalarFieldEnum]


  export const HedgeFundScalarFieldEnum: {
    id: 'id',
    fundId: 'fundId',
    strategy: 'strategy',
    riskLevel: 'riskLevel',
    minimumLockPeriod: 'minimumLockPeriod',
    managementFee: 'managementFee',
    performanceFee: 'performanceFee',
    highWaterMark: 'highWaterMark',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HedgeFundScalarFieldEnum = (typeof HedgeFundScalarFieldEnum)[keyof typeof HedgeFundScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Groups'
   */
  export type EnumGroupsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Groups'>
    


  /**
   * Reference to a field of type 'Groups[]'
   */
  export type ListEnumGroupsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Groups[]'>
    


  /**
   * Reference to a field of type 'HardwareTypes'
   */
  export type EnumHardwareTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HardwareTypes'>
    


  /**
   * Reference to a field of type 'HardwareTypes[]'
   */
  export type ListEnumHardwareTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HardwareTypes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'InstructionNamedType'
   */
  export type EnumInstructionNamedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstructionNamedType'>
    


  /**
   * Reference to a field of type 'InstructionNamedType[]'
   */
  export type ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstructionNamedType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    salt?: StringFilter<"User"> | string
    lastAction?: DateTimeFilter<"User"> | Date | string
    created?: DateTimeFilter<"User"> | Date | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    group?: EnumGroupsFilter<"User"> | $Enums.Groups
    accountBook?: AccountBookListRelationFilter
    addressBook?: AddressBookListRelationFilter
    computer?: ComputerListRelationFilter
    dns?: DNSListRelationFilter
    logs?: LogsListRelationFilter
    memory?: MemoryListRelationFilter
    notifications?: NotificationsListRelationFilter
    process?: ProcessListRelationFilter
    profile?: ProfileListRelationFilter
    session?: SessionListRelationFilter
    software?: SoftwareListRelationFilter
    userQuests?: UserQuestsListRelationFilter
    portfolios?: PortfolioListRelationFilter
    ongoingTrades?: TradeListRelationFilter
    managedFunds?: FundListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    group?: SortOrder
    accountBook?: AccountBookOrderByRelationAggregateInput
    addressBook?: AddressBookOrderByRelationAggregateInput
    computer?: ComputerOrderByRelationAggregateInput
    dns?: DNSOrderByRelationAggregateInput
    logs?: LogsOrderByRelationAggregateInput
    memory?: MemoryOrderByRelationAggregateInput
    notifications?: NotificationsOrderByRelationAggregateInput
    process?: ProcessOrderByRelationAggregateInput
    profile?: ProfileOrderByRelationAggregateInput
    session?: SessionOrderByRelationAggregateInput
    software?: SoftwareOrderByRelationAggregateInput
    userQuests?: UserQuestsOrderByRelationAggregateInput
    portfolios?: PortfolioOrderByRelationAggregateInput
    ongoingTrades?: TradeOrderByRelationAggregateInput
    managedFunds?: FundOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    salt?: StringFilter<"User"> | string
    lastAction?: DateTimeFilter<"User"> | Date | string
    created?: DateTimeFilter<"User"> | Date | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    group?: EnumGroupsFilter<"User"> | $Enums.Groups
    accountBook?: AccountBookListRelationFilter
    addressBook?: AddressBookListRelationFilter
    computer?: ComputerListRelationFilter
    dns?: DNSListRelationFilter
    logs?: LogsListRelationFilter
    memory?: MemoryListRelationFilter
    notifications?: NotificationsListRelationFilter
    process?: ProcessListRelationFilter
    profile?: ProfileListRelationFilter
    session?: SessionListRelationFilter
    software?: SoftwareListRelationFilter
    userQuests?: UserQuestsListRelationFilter
    portfolios?: PortfolioListRelationFilter
    ongoingTrades?: TradeListRelationFilter
    managedFunds?: FundListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    group?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    salt?: StringWithAggregatesFilter<"User"> | string
    lastAction?: DateTimeWithAggregatesFilter<"User"> | Date | string
    created?: DateTimeWithAggregatesFilter<"User"> | Date | string
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    group?: EnumGroupsWithAggregatesFilter<"User"> | $Enums.Groups
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    started?: DateTimeFilter<"Game"> | Date | string
    ended?: DateTimeNullableFilter<"Game"> | Date | string | null
    accountBook?: AccountBookListRelationFilter
    addressBook?: AddressBookListRelationFilter
    computer?: ComputerListRelationFilter
    dns?: DNSListRelationFilter
    hardware?: HardwareListRelationFilter
    logs?: LogsListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    profile?: ProfileListRelationFilter
    quests?: QuestsListRelationFilter
    software?: SoftwareListRelationFilter
    userQuests?: UserQuestsListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrderInput | SortOrder
    accountBook?: AccountBookOrderByRelationAggregateInput
    addressBook?: AddressBookOrderByRelationAggregateInput
    computer?: ComputerOrderByRelationAggregateInput
    dns?: DNSOrderByRelationAggregateInput
    hardware?: HardwareOrderByRelationAggregateInput
    logs?: LogsOrderByRelationAggregateInput
    memory?: MemoryOrderByRelationAggregateInput
    process?: ProcessOrderByRelationAggregateInput
    profile?: ProfileOrderByRelationAggregateInput
    quests?: QuestsOrderByRelationAggregateInput
    software?: SoftwareOrderByRelationAggregateInput
    userQuests?: UserQuestsOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    name?: StringFilter<"Game"> | string
    started?: DateTimeFilter<"Game"> | Date | string
    ended?: DateTimeNullableFilter<"Game"> | Date | string | null
    accountBook?: AccountBookListRelationFilter
    addressBook?: AddressBookListRelationFilter
    computer?: ComputerListRelationFilter
    dns?: DNSListRelationFilter
    hardware?: HardwareListRelationFilter
    logs?: LogsListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    profile?: ProfileListRelationFilter
    quests?: QuestsListRelationFilter
    software?: SoftwareListRelationFilter
    userQuests?: UserQuestsListRelationFilter
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrderInput | SortOrder
    _count?: GameCountOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    name?: StringWithAggregatesFilter<"Game"> | string
    started?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    ended?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    lastAction?: DateTimeFilter<"Session"> | Date | string
    created?: DateTimeFilter<"Session"> | Date | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    lastAction?: DateTimeFilter<"Session"> | Date | string
    created?: DateTimeFilter<"Session"> | Date | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntWithAggregatesFilter<"Session"> | number
    token?: StringWithAggregatesFilter<"Session"> | string
    lastAction?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    created?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type HardwareWhereInput = {
    AND?: HardwareWhereInput | HardwareWhereInput[]
    OR?: HardwareWhereInput[]
    NOT?: HardwareWhereInput | HardwareWhereInput[]
    id?: IntFilter<"Hardware"> | number
    computerId?: StringFilter<"Hardware"> | string
    gameId?: StringFilter<"Hardware"> | string
    type?: EnumHardwareTypesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatFilter<"Hardware"> | number
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type HardwareOrderByWithRelationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type HardwareWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HardwareWhereInput | HardwareWhereInput[]
    OR?: HardwareWhereInput[]
    NOT?: HardwareWhereInput | HardwareWhereInput[]
    computerId?: StringFilter<"Hardware"> | string
    gameId?: StringFilter<"Hardware"> | string
    type?: EnumHardwareTypesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatFilter<"Hardware"> | number
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type HardwareOrderByWithAggregationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
    _count?: HardwareCountOrderByAggregateInput
    _avg?: HardwareAvgOrderByAggregateInput
    _max?: HardwareMaxOrderByAggregateInput
    _min?: HardwareMinOrderByAggregateInput
    _sum?: HardwareSumOrderByAggregateInput
  }

  export type HardwareScalarWhereWithAggregatesInput = {
    AND?: HardwareScalarWhereWithAggregatesInput | HardwareScalarWhereWithAggregatesInput[]
    OR?: HardwareScalarWhereWithAggregatesInput[]
    NOT?: HardwareScalarWhereWithAggregatesInput | HardwareScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hardware"> | number
    computerId?: StringWithAggregatesFilter<"Hardware"> | string
    gameId?: StringWithAggregatesFilter<"Hardware"> | string
    type?: EnumHardwareTypesWithAggregatesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatWithAggregatesFilter<"Hardware"> | number
  }

  export type AddressBookWhereInput = {
    AND?: AddressBookWhereInput | AddressBookWhereInput[]
    OR?: AddressBookWhereInput[]
    NOT?: AddressBookWhereInput | AddressBookWhereInput[]
    id?: IntFilter<"AddressBook"> | number
    userId?: IntFilter<"AddressBook"> | number
    access?: EnumAccessLevelFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringFilter<"AddressBook"> | string
    ip?: StringFilter<"AddressBook"> | string
    data?: JsonFilter<"AddressBook">
    gameId?: StringFilter<"AddressBook"> | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AddressBookOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AddressBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressBookWhereInput | AddressBookWhereInput[]
    OR?: AddressBookWhereInput[]
    NOT?: AddressBookWhereInput | AddressBookWhereInput[]
    userId?: IntFilter<"AddressBook"> | number
    access?: EnumAccessLevelFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringFilter<"AddressBook"> | string
    ip?: StringFilter<"AddressBook"> | string
    data?: JsonFilter<"AddressBook">
    gameId?: StringFilter<"AddressBook"> | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AddressBookOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    _count?: AddressBookCountOrderByAggregateInput
    _avg?: AddressBookAvgOrderByAggregateInput
    _max?: AddressBookMaxOrderByAggregateInput
    _min?: AddressBookMinOrderByAggregateInput
    _sum?: AddressBookSumOrderByAggregateInput
  }

  export type AddressBookScalarWhereWithAggregatesInput = {
    AND?: AddressBookScalarWhereWithAggregatesInput | AddressBookScalarWhereWithAggregatesInput[]
    OR?: AddressBookScalarWhereWithAggregatesInput[]
    NOT?: AddressBookScalarWhereWithAggregatesInput | AddressBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddressBook"> | number
    userId?: IntWithAggregatesFilter<"AddressBook"> | number
    access?: EnumAccessLevelWithAggregatesFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringWithAggregatesFilter<"AddressBook"> | string
    ip?: StringWithAggregatesFilter<"AddressBook"> | string
    data?: JsonWithAggregatesFilter<"AddressBook">
    gameId?: StringWithAggregatesFilter<"AddressBook"> | string
  }

  export type DNSWhereInput = {
    AND?: DNSWhereInput | DNSWhereInput[]
    OR?: DNSWhereInput[]
    NOT?: DNSWhereInput | DNSWhereInput[]
    id?: IntFilter<"DNS"> | number
    userId?: IntFilter<"DNS"> | number
    computerId?: StringFilter<"DNS"> | string
    gameId?: StringFilter<"DNS"> | string
    website?: StringFilter<"DNS"> | string
    tags?: StringFilter<"DNS"> | string
    description?: StringFilter<"DNS"> | string
    updated?: DateTimeFilter<"DNS"> | Date | string
    created?: DateTimeFilter<"DNS"> | Date | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DNSOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DNSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DNSWhereInput | DNSWhereInput[]
    OR?: DNSWhereInput[]
    NOT?: DNSWhereInput | DNSWhereInput[]
    userId?: IntFilter<"DNS"> | number
    computerId?: StringFilter<"DNS"> | string
    gameId?: StringFilter<"DNS"> | string
    website?: StringFilter<"DNS"> | string
    tags?: StringFilter<"DNS"> | string
    description?: StringFilter<"DNS"> | string
    updated?: DateTimeFilter<"DNS"> | Date | string
    created?: DateTimeFilter<"DNS"> | Date | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DNSOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
    _count?: DNSCountOrderByAggregateInput
    _avg?: DNSAvgOrderByAggregateInput
    _max?: DNSMaxOrderByAggregateInput
    _min?: DNSMinOrderByAggregateInput
    _sum?: DNSSumOrderByAggregateInput
  }

  export type DNSScalarWhereWithAggregatesInput = {
    AND?: DNSScalarWhereWithAggregatesInput | DNSScalarWhereWithAggregatesInput[]
    OR?: DNSScalarWhereWithAggregatesInput[]
    NOT?: DNSScalarWhereWithAggregatesInput | DNSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DNS"> | number
    userId?: IntWithAggregatesFilter<"DNS"> | number
    computerId?: StringWithAggregatesFilter<"DNS"> | string
    gameId?: StringWithAggregatesFilter<"DNS"> | string
    website?: StringWithAggregatesFilter<"DNS"> | string
    tags?: StringWithAggregatesFilter<"DNS"> | string
    description?: StringWithAggregatesFilter<"DNS"> | string
    updated?: DateTimeWithAggregatesFilter<"DNS"> | Date | string
    created?: DateTimeWithAggregatesFilter<"DNS"> | Date | string
  }

  export type AccountBookWhereInput = {
    AND?: AccountBookWhereInput | AccountBookWhereInput[]
    OR?: AccountBookWhereInput[]
    NOT?: AccountBookWhereInput | AccountBookWhereInput[]
    id?: IntFilter<"AccountBook"> | number
    userId?: IntFilter<"AccountBook"> | number
    computerId?: StringFilter<"AccountBook"> | string
    memoryId?: StringFilter<"AccountBook"> | string
    data?: JsonFilter<"AccountBook">
    gameId?: StringFilter<"AccountBook"> | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    memory?: XOR<MemoryRelationFilter, MemoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountBookOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    memory?: MemoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AccountBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountBookWhereInput | AccountBookWhereInput[]
    OR?: AccountBookWhereInput[]
    NOT?: AccountBookWhereInput | AccountBookWhereInput[]
    userId?: IntFilter<"AccountBook"> | number
    computerId?: StringFilter<"AccountBook"> | string
    memoryId?: StringFilter<"AccountBook"> | string
    data?: JsonFilter<"AccountBook">
    gameId?: StringFilter<"AccountBook"> | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    memory?: XOR<MemoryRelationFilter, MemoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AccountBookOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
    _count?: AccountBookCountOrderByAggregateInput
    _avg?: AccountBookAvgOrderByAggregateInput
    _max?: AccountBookMaxOrderByAggregateInput
    _min?: AccountBookMinOrderByAggregateInput
    _sum?: AccountBookSumOrderByAggregateInput
  }

  export type AccountBookScalarWhereWithAggregatesInput = {
    AND?: AccountBookScalarWhereWithAggregatesInput | AccountBookScalarWhereWithAggregatesInput[]
    OR?: AccountBookScalarWhereWithAggregatesInput[]
    NOT?: AccountBookScalarWhereWithAggregatesInput | AccountBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountBook"> | number
    userId?: IntWithAggregatesFilter<"AccountBook"> | number
    computerId?: StringWithAggregatesFilter<"AccountBook"> | string
    memoryId?: StringWithAggregatesFilter<"AccountBook"> | string
    data?: JsonWithAggregatesFilter<"AccountBook">
    gameId?: StringWithAggregatesFilter<"AccountBook"> | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: IntFilter<"Profile"> | number
    userId?: IntFilter<"Profile"> | number
    gameId?: StringFilter<"Profile"> | string
    data?: JsonFilter<"Profile">
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    data?: SortOrder
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    userId?: IntFilter<"Profile"> | number
    gameId?: StringFilter<"Profile"> | string
    data?: JsonFilter<"Profile">
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    data?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profile"> | number
    userId?: IntWithAggregatesFilter<"Profile"> | number
    gameId?: StringWithAggregatesFilter<"Profile"> | string
    data?: JsonWithAggregatesFilter<"Profile">
  }

  export type MemoryWhereInput = {
    AND?: MemoryWhereInput | MemoryWhereInput[]
    OR?: MemoryWhereInput[]
    NOT?: MemoryWhereInput | MemoryWhereInput[]
    id?: StringFilter<"Memory"> | string
    computerId?: StringFilter<"Memory"> | string
    gameId?: StringFilter<"Memory"> | string
    userId?: IntFilter<"Memory"> | number
    type?: StringFilter<"Memory"> | string
    key?: StringFilter<"Memory"> | string
    value?: FloatNullableFilter<"Memory"> | number | null
    data?: JsonFilter<"Memory">
    accountBook?: AccountBookListRelationFilter
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MemoryOrderByWithRelationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    data?: SortOrder
    accountBook?: AccountBookOrderByRelationAggregateInput
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemoryWhereInput | MemoryWhereInput[]
    OR?: MemoryWhereInput[]
    NOT?: MemoryWhereInput | MemoryWhereInput[]
    computerId?: StringFilter<"Memory"> | string
    gameId?: StringFilter<"Memory"> | string
    userId?: IntFilter<"Memory"> | number
    type?: StringFilter<"Memory"> | string
    key?: StringFilter<"Memory"> | string
    value?: FloatNullableFilter<"Memory"> | number | null
    data?: JsonFilter<"Memory">
    accountBook?: AccountBookListRelationFilter
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MemoryOrderByWithAggregationInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    data?: SortOrder
    _count?: MemoryCountOrderByAggregateInput
    _avg?: MemoryAvgOrderByAggregateInput
    _max?: MemoryMaxOrderByAggregateInput
    _min?: MemoryMinOrderByAggregateInput
    _sum?: MemorySumOrderByAggregateInput
  }

  export type MemoryScalarWhereWithAggregatesInput = {
    AND?: MemoryScalarWhereWithAggregatesInput | MemoryScalarWhereWithAggregatesInput[]
    OR?: MemoryScalarWhereWithAggregatesInput[]
    NOT?: MemoryScalarWhereWithAggregatesInput | MemoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Memory"> | string
    computerId?: StringWithAggregatesFilter<"Memory"> | string
    gameId?: StringWithAggregatesFilter<"Memory"> | string
    userId?: IntWithAggregatesFilter<"Memory"> | number
    type?: StringWithAggregatesFilter<"Memory"> | string
    key?: StringWithAggregatesFilter<"Memory"> | string
    value?: FloatNullableWithAggregatesFilter<"Memory"> | number | null
    data?: JsonWithAggregatesFilter<"Memory">
  }

  export type ComputerWhereInput = {
    AND?: ComputerWhereInput | ComputerWhereInput[]
    OR?: ComputerWhereInput[]
    NOT?: ComputerWhereInput | ComputerWhereInput[]
    id?: StringFilter<"Computer"> | string
    userId?: IntFilter<"Computer"> | number
    type?: StringFilter<"Computer"> | string
    gameId?: StringFilter<"Computer"> | string
    ip?: StringFilter<"Computer"> | string
    data?: JsonFilter<"Computer">
    created?: DateTimeFilter<"Computer"> | Date | string
    updated?: DateTimeFilter<"Computer"> | Date | string
    accountBook?: AccountBookListRelationFilter
    addressBook?: AddressBookListRelationFilter
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dns?: DNSListRelationFilter
    hardware?: HardwareListRelationFilter
    logs?: LogsListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    software?: SoftwareListRelationFilter
  }

  export type ComputerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    accountBook?: AccountBookOrderByRelationAggregateInput
    addressBook?: AddressBookOrderByRelationAggregateInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    dns?: DNSOrderByRelationAggregateInput
    hardware?: HardwareOrderByRelationAggregateInput
    logs?: LogsOrderByRelationAggregateInput
    memory?: MemoryOrderByRelationAggregateInput
    process?: ProcessOrderByRelationAggregateInput
    software?: SoftwareOrderByRelationAggregateInput
  }

  export type ComputerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComputerWhereInput | ComputerWhereInput[]
    OR?: ComputerWhereInput[]
    NOT?: ComputerWhereInput | ComputerWhereInput[]
    userId?: IntFilter<"Computer"> | number
    type?: StringFilter<"Computer"> | string
    gameId?: StringFilter<"Computer"> | string
    ip?: StringFilter<"Computer"> | string
    data?: JsonFilter<"Computer">
    created?: DateTimeFilter<"Computer"> | Date | string
    updated?: DateTimeFilter<"Computer"> | Date | string
    accountBook?: AccountBookListRelationFilter
    addressBook?: AddressBookListRelationFilter
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dns?: DNSListRelationFilter
    hardware?: HardwareListRelationFilter
    logs?: LogsListRelationFilter
    memory?: MemoryListRelationFilter
    process?: ProcessListRelationFilter
    software?: SoftwareListRelationFilter
  }, "id">

  export type ComputerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: ComputerCountOrderByAggregateInput
    _avg?: ComputerAvgOrderByAggregateInput
    _max?: ComputerMaxOrderByAggregateInput
    _min?: ComputerMinOrderByAggregateInput
    _sum?: ComputerSumOrderByAggregateInput
  }

  export type ComputerScalarWhereWithAggregatesInput = {
    AND?: ComputerScalarWhereWithAggregatesInput | ComputerScalarWhereWithAggregatesInput[]
    OR?: ComputerScalarWhereWithAggregatesInput[]
    NOT?: ComputerScalarWhereWithAggregatesInput | ComputerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Computer"> | string
    userId?: IntWithAggregatesFilter<"Computer"> | number
    type?: StringWithAggregatesFilter<"Computer"> | string
    gameId?: StringWithAggregatesFilter<"Computer"> | string
    ip?: StringWithAggregatesFilter<"Computer"> | string
    data?: JsonWithAggregatesFilter<"Computer">
    created?: DateTimeWithAggregatesFilter<"Computer"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Computer"> | Date | string
  }

  export type QuestsWhereInput = {
    AND?: QuestsWhereInput | QuestsWhereInput[]
    OR?: QuestsWhereInput[]
    NOT?: QuestsWhereInput | QuestsWhereInput[]
    id?: StringFilter<"Quests"> | string
    gameId?: StringFilter<"Quests"> | string
    type?: StringFilter<"Quests"> | string
    title?: StringFilter<"Quests"> | string
    reward?: JsonNullableFilter<"Quests">
    open?: BoolFilter<"Quests"> | boolean
    game?: XOR<GameRelationFilter, GameWhereInput>
    userQuests?: UserQuestsListRelationFilter
  }

  export type QuestsOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    reward?: SortOrderInput | SortOrder
    open?: SortOrder
    game?: GameOrderByWithRelationInput
    userQuests?: UserQuestsOrderByRelationAggregateInput
  }

  export type QuestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestsWhereInput | QuestsWhereInput[]
    OR?: QuestsWhereInput[]
    NOT?: QuestsWhereInput | QuestsWhereInput[]
    gameId?: StringFilter<"Quests"> | string
    type?: StringFilter<"Quests"> | string
    title?: StringFilter<"Quests"> | string
    reward?: JsonNullableFilter<"Quests">
    open?: BoolFilter<"Quests"> | boolean
    game?: XOR<GameRelationFilter, GameWhereInput>
    userQuests?: UserQuestsListRelationFilter
  }, "id">

  export type QuestsOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    reward?: SortOrderInput | SortOrder
    open?: SortOrder
    _count?: QuestsCountOrderByAggregateInput
    _max?: QuestsMaxOrderByAggregateInput
    _min?: QuestsMinOrderByAggregateInput
  }

  export type QuestsScalarWhereWithAggregatesInput = {
    AND?: QuestsScalarWhereWithAggregatesInput | QuestsScalarWhereWithAggregatesInput[]
    OR?: QuestsScalarWhereWithAggregatesInput[]
    NOT?: QuestsScalarWhereWithAggregatesInput | QuestsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quests"> | string
    gameId?: StringWithAggregatesFilter<"Quests"> | string
    type?: StringWithAggregatesFilter<"Quests"> | string
    title?: StringWithAggregatesFilter<"Quests"> | string
    reward?: JsonNullableWithAggregatesFilter<"Quests">
    open?: BoolWithAggregatesFilter<"Quests"> | boolean
  }

  export type UserQuestsWhereInput = {
    AND?: UserQuestsWhereInput | UserQuestsWhereInput[]
    OR?: UserQuestsWhereInput[]
    NOT?: UserQuestsWhereInput | UserQuestsWhereInput[]
    id?: StringFilter<"UserQuests"> | string
    questsId?: StringFilter<"UserQuests"> | string
    userId?: IntFilter<"UserQuests"> | number
    gameId?: StringFilter<"UserQuests"> | string
    completed?: BoolFilter<"UserQuests"> | boolean
    created?: DateTimeFilter<"UserQuests"> | Date | string
    updated?: DateTimeFilter<"UserQuests"> | Date | string
    game?: XOR<GameRelationFilter, GameWhereInput>
    quest?: XOR<QuestsRelationFilter, QuestsWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserQuestsOrderByWithRelationInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    game?: GameOrderByWithRelationInput
    quest?: QuestsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserQuestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserQuestsWhereInput | UserQuestsWhereInput[]
    OR?: UserQuestsWhereInput[]
    NOT?: UserQuestsWhereInput | UserQuestsWhereInput[]
    questsId?: StringFilter<"UserQuests"> | string
    userId?: IntFilter<"UserQuests"> | number
    gameId?: StringFilter<"UserQuests"> | string
    completed?: BoolFilter<"UserQuests"> | boolean
    created?: DateTimeFilter<"UserQuests"> | Date | string
    updated?: DateTimeFilter<"UserQuests"> | Date | string
    game?: XOR<GameRelationFilter, GameWhereInput>
    quest?: XOR<QuestsRelationFilter, QuestsWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserQuestsOrderByWithAggregationInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: UserQuestsCountOrderByAggregateInput
    _avg?: UserQuestsAvgOrderByAggregateInput
    _max?: UserQuestsMaxOrderByAggregateInput
    _min?: UserQuestsMinOrderByAggregateInput
    _sum?: UserQuestsSumOrderByAggregateInput
  }

  export type UserQuestsScalarWhereWithAggregatesInput = {
    AND?: UserQuestsScalarWhereWithAggregatesInput | UserQuestsScalarWhereWithAggregatesInput[]
    OR?: UserQuestsScalarWhereWithAggregatesInput[]
    NOT?: UserQuestsScalarWhereWithAggregatesInput | UserQuestsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserQuests"> | string
    questsId?: StringWithAggregatesFilter<"UserQuests"> | string
    userId?: IntWithAggregatesFilter<"UserQuests"> | number
    gameId?: StringWithAggregatesFilter<"UserQuests"> | string
    completed?: BoolWithAggregatesFilter<"UserQuests"> | boolean
    created?: DateTimeWithAggregatesFilter<"UserQuests"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"UserQuests"> | Date | string
  }

  export type SoftwareWhereInput = {
    AND?: SoftwareWhereInput | SoftwareWhereInput[]
    OR?: SoftwareWhereInput[]
    NOT?: SoftwareWhereInput | SoftwareWhereInput[]
    id?: StringFilter<"Software"> | string
    userId?: IntFilter<"Software"> | number
    computerId?: StringFilter<"Software"> | string
    gameId?: StringFilter<"Software"> | string
    type?: StringFilter<"Software"> | string
    level?: FloatFilter<"Software"> | number
    size?: FloatFilter<"Software"> | number
    opacity?: FloatFilter<"Software"> | number
    installed?: BoolFilter<"Software"> | boolean
    executed?: DateTimeFilter<"Software"> | Date | string
    created?: DateTimeFilter<"Software"> | Date | string
    updated?: DateTimeFilter<"Software"> | Date | string
    data?: JsonFilter<"Software">
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SoftwareOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SoftwareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SoftwareWhereInput | SoftwareWhereInput[]
    OR?: SoftwareWhereInput[]
    NOT?: SoftwareWhereInput | SoftwareWhereInput[]
    userId?: IntFilter<"Software"> | number
    computerId?: StringFilter<"Software"> | string
    gameId?: StringFilter<"Software"> | string
    type?: StringFilter<"Software"> | string
    level?: FloatFilter<"Software"> | number
    size?: FloatFilter<"Software"> | number
    opacity?: FloatFilter<"Software"> | number
    installed?: BoolFilter<"Software"> | boolean
    executed?: DateTimeFilter<"Software"> | Date | string
    created?: DateTimeFilter<"Software"> | Date | string
    updated?: DateTimeFilter<"Software"> | Date | string
    data?: JsonFilter<"Software">
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SoftwareOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    _count?: SoftwareCountOrderByAggregateInput
    _avg?: SoftwareAvgOrderByAggregateInput
    _max?: SoftwareMaxOrderByAggregateInput
    _min?: SoftwareMinOrderByAggregateInput
    _sum?: SoftwareSumOrderByAggregateInput
  }

  export type SoftwareScalarWhereWithAggregatesInput = {
    AND?: SoftwareScalarWhereWithAggregatesInput | SoftwareScalarWhereWithAggregatesInput[]
    OR?: SoftwareScalarWhereWithAggregatesInput[]
    NOT?: SoftwareScalarWhereWithAggregatesInput | SoftwareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Software"> | string
    userId?: IntWithAggregatesFilter<"Software"> | number
    computerId?: StringWithAggregatesFilter<"Software"> | string
    gameId?: StringWithAggregatesFilter<"Software"> | string
    type?: StringWithAggregatesFilter<"Software"> | string
    level?: FloatWithAggregatesFilter<"Software"> | number
    size?: FloatWithAggregatesFilter<"Software"> | number
    opacity?: FloatWithAggregatesFilter<"Software"> | number
    installed?: BoolWithAggregatesFilter<"Software"> | boolean
    executed?: DateTimeWithAggregatesFilter<"Software"> | Date | string
    created?: DateTimeWithAggregatesFilter<"Software"> | Date | string
    updated?: DateTimeWithAggregatesFilter<"Software"> | Date | string
    data?: JsonWithAggregatesFilter<"Software">
  }

  export type ProcessWhereInput = {
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    id?: StringFilter<"Process"> | string
    userId?: IntFilter<"Process"> | number
    computerId?: StringFilter<"Process"> | string
    ip?: StringNullableFilter<"Process"> | string | null
    gameId?: StringFilter<"Process"> | string
    type?: StringFilter<"Process"> | string
    started?: DateTimeFilter<"Process"> | Date | string
    completion?: DateTimeFilter<"Process"> | Date | string
    data?: JsonFilter<"Process">
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProcessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrderInput | SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
    data?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    userId?: IntFilter<"Process"> | number
    computerId?: StringFilter<"Process"> | string
    ip?: StringNullableFilter<"Process"> | string | null
    gameId?: StringFilter<"Process"> | string
    type?: StringFilter<"Process"> | string
    started?: DateTimeFilter<"Process"> | Date | string
    completion?: DateTimeFilter<"Process"> | Date | string
    data?: JsonFilter<"Process">
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProcessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrderInput | SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
    data?: SortOrder
    _count?: ProcessCountOrderByAggregateInput
    _avg?: ProcessAvgOrderByAggregateInput
    _max?: ProcessMaxOrderByAggregateInput
    _min?: ProcessMinOrderByAggregateInput
    _sum?: ProcessSumOrderByAggregateInput
  }

  export type ProcessScalarWhereWithAggregatesInput = {
    AND?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    OR?: ProcessScalarWhereWithAggregatesInput[]
    NOT?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Process"> | string
    userId?: IntWithAggregatesFilter<"Process"> | number
    computerId?: StringWithAggregatesFilter<"Process"> | string
    ip?: StringNullableWithAggregatesFilter<"Process"> | string | null
    gameId?: StringWithAggregatesFilter<"Process"> | string
    type?: StringWithAggregatesFilter<"Process"> | string
    started?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    completion?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    data?: JsonWithAggregatesFilter<"Process">
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: IntFilter<"Notifications"> | number
    userId?: IntFilter<"Notifications"> | number
    type?: StringFilter<"Notifications"> | string
    content?: JsonFilter<"Notifications">
    read?: BoolFilter<"Notifications"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    userId?: IntFilter<"Notifications"> | number
    type?: StringFilter<"Notifications"> | string
    content?: JsonFilter<"Notifications">
    read?: BoolFilter<"Notifications"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _avg?: NotificationsAvgOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
    _sum?: NotificationsSumOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notifications"> | number
    userId?: IntWithAggregatesFilter<"Notifications"> | number
    type?: StringWithAggregatesFilter<"Notifications"> | string
    content?: JsonWithAggregatesFilter<"Notifications">
    read?: BoolWithAggregatesFilter<"Notifications"> | boolean
  }

  export type LogsWhereInput = {
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    id?: IntFilter<"Logs"> | number
    userId?: IntFilter<"Logs"> | number
    computerId?: StringFilter<"Logs"> | string
    senderId?: StringFilter<"Logs"> | string
    senderIp?: StringFilter<"Logs"> | string
    gameId?: StringFilter<"Logs"> | string
    message?: StringFilter<"Logs"> | string
    created?: DateTimeFilter<"Logs"> | Date | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
    computer?: ComputerOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    userId?: IntFilter<"Logs"> | number
    computerId?: StringFilter<"Logs"> | string
    senderId?: StringFilter<"Logs"> | string
    senderIp?: StringFilter<"Logs"> | string
    gameId?: StringFilter<"Logs"> | string
    message?: StringFilter<"Logs"> | string
    created?: DateTimeFilter<"Logs"> | Date | string
    computer?: XOR<ComputerRelationFilter, ComputerWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
    _count?: LogsCountOrderByAggregateInput
    _avg?: LogsAvgOrderByAggregateInput
    _max?: LogsMaxOrderByAggregateInput
    _min?: LogsMinOrderByAggregateInput
    _sum?: LogsSumOrderByAggregateInput
  }

  export type LogsScalarWhereWithAggregatesInput = {
    AND?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    OR?: LogsScalarWhereWithAggregatesInput[]
    NOT?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Logs"> | number
    userId?: IntWithAggregatesFilter<"Logs"> | number
    computerId?: StringWithAggregatesFilter<"Logs"> | string
    senderId?: StringWithAggregatesFilter<"Logs"> | string
    senderIp?: StringWithAggregatesFilter<"Logs"> | string
    gameId?: StringWithAggregatesFilter<"Logs"> | string
    message?: StringWithAggregatesFilter<"Logs"> | string
    created?: DateTimeWithAggregatesFilter<"Logs"> | Date | string
  }

  export type TradeWhereInput = {
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    id?: IntFilter<"Trade"> | number
    userId?: IntFilter<"Trade"> | number
    marketId?: IntFilter<"Trade"> | number
    portfolioId?: IntFilter<"Trade"> | number
    type?: StringFilter<"Trade"> | string
    quantity?: IntFilter<"Trade"> | number
    price?: BigIntFilter<"Trade"> | bigint | number
    totalValue?: IntFilter<"Trade"> | number
    status?: StringFilter<"Trade"> | string
    executedAt?: DateTimeFilter<"Trade"> | Date | string
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    buyIntoTargetFundid?: IntFilter<"Trade"> | number
    instructionType?: EnumInstructionNamedTypeFilter<"Trade"> | $Enums.InstructionNamedType
    buyIntoTargetFund?: XOR<FundRelationFilter, FundWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    portfolio?: XOR<PortfolioRelationFilter, PortfolioWhereInput>
  }

  export type TradeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    portfolioId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalValue?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    buyIntoTargetFundid?: SortOrder
    instructionType?: SortOrder
    buyIntoTargetFund?: FundOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    portfolio?: PortfolioOrderByWithRelationInput
  }

  export type TradeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    userId?: IntFilter<"Trade"> | number
    marketId?: IntFilter<"Trade"> | number
    portfolioId?: IntFilter<"Trade"> | number
    type?: StringFilter<"Trade"> | string
    quantity?: IntFilter<"Trade"> | number
    price?: BigIntFilter<"Trade"> | bigint | number
    totalValue?: IntFilter<"Trade"> | number
    status?: StringFilter<"Trade"> | string
    executedAt?: DateTimeFilter<"Trade"> | Date | string
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    buyIntoTargetFundid?: IntFilter<"Trade"> | number
    instructionType?: EnumInstructionNamedTypeFilter<"Trade"> | $Enums.InstructionNamedType
    buyIntoTargetFund?: XOR<FundRelationFilter, FundWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    portfolio?: XOR<PortfolioRelationFilter, PortfolioWhereInput>
  }, "id">

  export type TradeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    portfolioId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalValue?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    buyIntoTargetFundid?: SortOrder
    instructionType?: SortOrder
    _count?: TradeCountOrderByAggregateInput
    _avg?: TradeAvgOrderByAggregateInput
    _max?: TradeMaxOrderByAggregateInput
    _min?: TradeMinOrderByAggregateInput
    _sum?: TradeSumOrderByAggregateInput
  }

  export type TradeScalarWhereWithAggregatesInput = {
    AND?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    OR?: TradeScalarWhereWithAggregatesInput[]
    NOT?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Trade"> | number
    userId?: IntWithAggregatesFilter<"Trade"> | number
    marketId?: IntWithAggregatesFilter<"Trade"> | number
    portfolioId?: IntWithAggregatesFilter<"Trade"> | number
    type?: StringWithAggregatesFilter<"Trade"> | string
    quantity?: IntWithAggregatesFilter<"Trade"> | number
    price?: BigIntWithAggregatesFilter<"Trade"> | bigint | number
    totalValue?: IntWithAggregatesFilter<"Trade"> | number
    status?: StringWithAggregatesFilter<"Trade"> | string
    executedAt?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
    buyIntoTargetFundid?: IntWithAggregatesFilter<"Trade"> | number
    instructionType?: EnumInstructionNamedTypeWithAggregatesFilter<"Trade"> | $Enums.InstructionNamedType
  }

  export type FundWhereInput = {
    AND?: FundWhereInput | FundWhereInput[]
    OR?: FundWhereInput[]
    NOT?: FundWhereInput | FundWhereInput[]
    id?: IntFilter<"Fund"> | number
    fundManagerId?: IntFilter<"Fund"> | number
    name?: StringFilter<"Fund"> | string
    minimumInvestmentAmount?: BigIntFilter<"Fund"> | bigint | number
    totalFundCharge?: DecimalFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFilter<"Fund"> | bigint | number
    isActive?: BoolFilter<"Fund"> | boolean
    maxInvestors?: IntFilter<"Fund"> | number
    createdAt?: DateTimeFilter<"Fund"> | Date | string
    updatedAt?: DateTimeFilter<"Fund"> | Date | string
    fundManager?: XOR<UserRelationFilter, UserWhereInput>
    trades?: TradeListRelationFilter
    holdings?: PortfolioHoldingListRelationFilter
    hedgeFunds?: HedgeFundListRelationFilter
  }

  export type FundOrderByWithRelationInput = {
    id?: SortOrder
    fundManagerId?: SortOrder
    name?: SortOrder
    minimumInvestmentAmount?: SortOrder
    totalFundCharge?: SortOrder
    totalFundCost?: SortOrder
    totalAssets?: SortOrder
    isActive?: SortOrder
    maxInvestors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fundManager?: UserOrderByWithRelationInput
    trades?: TradeOrderByRelationAggregateInput
    holdings?: PortfolioHoldingOrderByRelationAggregateInput
    hedgeFunds?: HedgeFundOrderByRelationAggregateInput
  }

  export type FundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FundWhereInput | FundWhereInput[]
    OR?: FundWhereInput[]
    NOT?: FundWhereInput | FundWhereInput[]
    fundManagerId?: IntFilter<"Fund"> | number
    name?: StringFilter<"Fund"> | string
    minimumInvestmentAmount?: BigIntFilter<"Fund"> | bigint | number
    totalFundCharge?: DecimalFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFilter<"Fund"> | bigint | number
    isActive?: BoolFilter<"Fund"> | boolean
    maxInvestors?: IntFilter<"Fund"> | number
    createdAt?: DateTimeFilter<"Fund"> | Date | string
    updatedAt?: DateTimeFilter<"Fund"> | Date | string
    fundManager?: XOR<UserRelationFilter, UserWhereInput>
    trades?: TradeListRelationFilter
    holdings?: PortfolioHoldingListRelationFilter
    hedgeFunds?: HedgeFundListRelationFilter
  }, "id">

  export type FundOrderByWithAggregationInput = {
    id?: SortOrder
    fundManagerId?: SortOrder
    name?: SortOrder
    minimumInvestmentAmount?: SortOrder
    totalFundCharge?: SortOrder
    totalFundCost?: SortOrder
    totalAssets?: SortOrder
    isActive?: SortOrder
    maxInvestors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FundCountOrderByAggregateInput
    _avg?: FundAvgOrderByAggregateInput
    _max?: FundMaxOrderByAggregateInput
    _min?: FundMinOrderByAggregateInput
    _sum?: FundSumOrderByAggregateInput
  }

  export type FundScalarWhereWithAggregatesInput = {
    AND?: FundScalarWhereWithAggregatesInput | FundScalarWhereWithAggregatesInput[]
    OR?: FundScalarWhereWithAggregatesInput[]
    NOT?: FundScalarWhereWithAggregatesInput | FundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fund"> | number
    fundManagerId?: IntWithAggregatesFilter<"Fund"> | number
    name?: StringWithAggregatesFilter<"Fund"> | string
    minimumInvestmentAmount?: BigIntWithAggregatesFilter<"Fund"> | bigint | number
    totalFundCharge?: DecimalWithAggregatesFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalWithAggregatesFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntWithAggregatesFilter<"Fund"> | bigint | number
    isActive?: BoolWithAggregatesFilter<"Fund"> | boolean
    maxInvestors?: IntWithAggregatesFilter<"Fund"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Fund"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fund"> | Date | string
  }

  export type PortfolioWhereInput = {
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    id?: IntFilter<"Portfolio"> | number
    userId?: IntFilter<"Portfolio"> | number
    name?: StringFilter<"Portfolio"> | string
    totalValue?: BigIntFilter<"Portfolio"> | bigint | number
    isActive?: BoolFilter<"Portfolio"> | boolean
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    holdings?: PortfolioHoldingListRelationFilter
    trades?: TradeListRelationFilter
  }

  export type PortfolioOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    totalValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    holdings?: PortfolioHoldingOrderByRelationAggregateInput
    trades?: TradeOrderByRelationAggregateInput
  }

  export type PortfolioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    userId?: IntFilter<"Portfolio"> | number
    name?: StringFilter<"Portfolio"> | string
    totalValue?: BigIntFilter<"Portfolio"> | bigint | number
    isActive?: BoolFilter<"Portfolio"> | boolean
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    holdings?: PortfolioHoldingListRelationFilter
    trades?: TradeListRelationFilter
  }, "id">

  export type PortfolioOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    totalValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioCountOrderByAggregateInput
    _avg?: PortfolioAvgOrderByAggregateInput
    _max?: PortfolioMaxOrderByAggregateInput
    _min?: PortfolioMinOrderByAggregateInput
    _sum?: PortfolioSumOrderByAggregateInput
  }

  export type PortfolioScalarWhereWithAggregatesInput = {
    AND?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    OR?: PortfolioScalarWhereWithAggregatesInput[]
    NOT?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Portfolio"> | number
    userId?: IntWithAggregatesFilter<"Portfolio"> | number
    name?: StringWithAggregatesFilter<"Portfolio"> | string
    totalValue?: BigIntWithAggregatesFilter<"Portfolio"> | bigint | number
    isActive?: BoolWithAggregatesFilter<"Portfolio"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
  }

  export type PortfolioHoldingWhereInput = {
    AND?: PortfolioHoldingWhereInput | PortfolioHoldingWhereInput[]
    OR?: PortfolioHoldingWhereInput[]
    NOT?: PortfolioHoldingWhereInput | PortfolioHoldingWhereInput[]
    id?: IntFilter<"PortfolioHolding"> | number
    portfolioId?: IntFilter<"PortfolioHolding"> | number
    fundId?: IntFilter<"PortfolioHolding"> | number
    quantity?: BigIntFilter<"PortfolioHolding"> | bigint | number
    averagePrice?: BigIntFilter<"PortfolioHolding"> | bigint | number
    createdAt?: DateTimeFilter<"PortfolioHolding"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioHolding"> | Date | string
    portfolio?: XOR<PortfolioRelationFilter, PortfolioWhereInput>
    fund?: XOR<FundRelationFilter, FundWhereInput>
  }

  export type PortfolioHoldingOrderByWithRelationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    fundId?: SortOrder
    quantity?: SortOrder
    averagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
    fund?: FundOrderByWithRelationInput
  }

  export type PortfolioHoldingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PortfolioHoldingWhereInput | PortfolioHoldingWhereInput[]
    OR?: PortfolioHoldingWhereInput[]
    NOT?: PortfolioHoldingWhereInput | PortfolioHoldingWhereInput[]
    portfolioId?: IntFilter<"PortfolioHolding"> | number
    fundId?: IntFilter<"PortfolioHolding"> | number
    quantity?: BigIntFilter<"PortfolioHolding"> | bigint | number
    averagePrice?: BigIntFilter<"PortfolioHolding"> | bigint | number
    createdAt?: DateTimeFilter<"PortfolioHolding"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioHolding"> | Date | string
    portfolio?: XOR<PortfolioRelationFilter, PortfolioWhereInput>
    fund?: XOR<FundRelationFilter, FundWhereInput>
  }, "id">

  export type PortfolioHoldingOrderByWithAggregationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    fundId?: SortOrder
    quantity?: SortOrder
    averagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioHoldingCountOrderByAggregateInput
    _avg?: PortfolioHoldingAvgOrderByAggregateInput
    _max?: PortfolioHoldingMaxOrderByAggregateInput
    _min?: PortfolioHoldingMinOrderByAggregateInput
    _sum?: PortfolioHoldingSumOrderByAggregateInput
  }

  export type PortfolioHoldingScalarWhereWithAggregatesInput = {
    AND?: PortfolioHoldingScalarWhereWithAggregatesInput | PortfolioHoldingScalarWhereWithAggregatesInput[]
    OR?: PortfolioHoldingScalarWhereWithAggregatesInput[]
    NOT?: PortfolioHoldingScalarWhereWithAggregatesInput | PortfolioHoldingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PortfolioHolding"> | number
    portfolioId?: IntWithAggregatesFilter<"PortfolioHolding"> | number
    fundId?: IntWithAggregatesFilter<"PortfolioHolding"> | number
    quantity?: BigIntWithAggregatesFilter<"PortfolioHolding"> | bigint | number
    averagePrice?: BigIntWithAggregatesFilter<"PortfolioHolding"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioHolding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioHolding"> | Date | string
  }

  export type HedgeFundWhereInput = {
    AND?: HedgeFundWhereInput | HedgeFundWhereInput[]
    OR?: HedgeFundWhereInput[]
    NOT?: HedgeFundWhereInput | HedgeFundWhereInput[]
    id?: IntFilter<"HedgeFund"> | number
    fundId?: IntFilter<"HedgeFund"> | number
    strategy?: StringFilter<"HedgeFund"> | string
    riskLevel?: StringFilter<"HedgeFund"> | string
    minimumLockPeriod?: IntFilter<"HedgeFund"> | number
    managementFee?: DecimalFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFilter<"HedgeFund"> | bigint | number
    createdAt?: DateTimeFilter<"HedgeFund"> | Date | string
    updatedAt?: DateTimeFilter<"HedgeFund"> | Date | string
    fund?: XOR<FundRelationFilter, FundWhereInput>
  }

  export type HedgeFundOrderByWithRelationInput = {
    id?: SortOrder
    fundId?: SortOrder
    strategy?: SortOrder
    riskLevel?: SortOrder
    minimumLockPeriod?: SortOrder
    managementFee?: SortOrder
    performanceFee?: SortOrder
    highWaterMark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fund?: FundOrderByWithRelationInput
  }

  export type HedgeFundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fundId?: number
    AND?: HedgeFundWhereInput | HedgeFundWhereInput[]
    OR?: HedgeFundWhereInput[]
    NOT?: HedgeFundWhereInput | HedgeFundWhereInput[]
    strategy?: StringFilter<"HedgeFund"> | string
    riskLevel?: StringFilter<"HedgeFund"> | string
    minimumLockPeriod?: IntFilter<"HedgeFund"> | number
    managementFee?: DecimalFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFilter<"HedgeFund"> | bigint | number
    createdAt?: DateTimeFilter<"HedgeFund"> | Date | string
    updatedAt?: DateTimeFilter<"HedgeFund"> | Date | string
    fund?: XOR<FundRelationFilter, FundWhereInput>
  }, "id" | "fundId">

  export type HedgeFundOrderByWithAggregationInput = {
    id?: SortOrder
    fundId?: SortOrder
    strategy?: SortOrder
    riskLevel?: SortOrder
    minimumLockPeriod?: SortOrder
    managementFee?: SortOrder
    performanceFee?: SortOrder
    highWaterMark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HedgeFundCountOrderByAggregateInput
    _avg?: HedgeFundAvgOrderByAggregateInput
    _max?: HedgeFundMaxOrderByAggregateInput
    _min?: HedgeFundMinOrderByAggregateInput
    _sum?: HedgeFundSumOrderByAggregateInput
  }

  export type HedgeFundScalarWhereWithAggregatesInput = {
    AND?: HedgeFundScalarWhereWithAggregatesInput | HedgeFundScalarWhereWithAggregatesInput[]
    OR?: HedgeFundScalarWhereWithAggregatesInput[]
    NOT?: HedgeFundScalarWhereWithAggregatesInput | HedgeFundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HedgeFund"> | number
    fundId?: IntWithAggregatesFilter<"HedgeFund"> | number
    strategy?: StringWithAggregatesFilter<"HedgeFund"> | string
    riskLevel?: StringWithAggregatesFilter<"HedgeFund"> | string
    minimumLockPeriod?: IntWithAggregatesFilter<"HedgeFund"> | number
    managementFee?: DecimalWithAggregatesFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalWithAggregatesFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntWithAggregatesFilter<"HedgeFund"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"HedgeFund"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HedgeFund"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
  }

  export type GameCreateInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    userId: number
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id: string
    userId: number
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HardwareCreateInput = {
    type: $Enums.HardwareTypes
    strength: number
    computer: ComputerCreateNestedOneWithoutHardwareInput
    game: GameCreateNestedOneWithoutHardwareInput
  }

  export type HardwareUncheckedCreateInput = {
    id?: number
    computerId: string
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareUpdateInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
    computer?: ComputerUpdateOneRequiredWithoutHardwareNestedInput
    game?: GameUpdateOneRequiredWithoutHardwareNestedInput
  }

  export type HardwareUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareCreateManyInput = {
    id?: number
    computerId: string
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareUpdateManyMutationInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type AddressBookCreateInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAddressBookInput
    game: GameCreateNestedOneWithoutAddressBookInput
    user: UserCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookUpdateInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAddressBookNestedInput
    game?: GameUpdateOneRequiredWithoutAddressBookNestedInput
    user?: UserUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookCreateManyInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookUpdateManyMutationInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type DNSCreateInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutDnsInput
    game: GameCreateNestedOneWithoutDnsInput
    user: UserCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateInput = {
    id?: number
    userId: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSUpdateInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutDnsNestedInput
    game?: GameUpdateOneRequiredWithoutDnsNestedInput
    user?: UserUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSCreateManyInput = {
    id?: number
    userId: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSUpdateManyMutationInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBookCreateInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    game: GameCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
    user: UserCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookCreateManyInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    data?: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    userId: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateManyInput = {
    id?: number
    userId: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryCreateInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
    computer: ComputerCreateNestedOneWithoutMemoryInput
    game: GameCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
  }

  export type MemoryUncheckedCreateInput = {
    id?: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryCreateManyInput = {
    id?: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ComputerCreateInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type ComputerCreateManyInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
  }

  export type ComputerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComputerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestsCreateInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    game: GameCreateNestedOneWithoutQuestsInput
    userQuests?: UserQuestsCreateNestedManyWithoutQuestInput
  }

  export type QuestsUncheckedCreateInput = {
    id?: string
    gameId: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    game?: GameUpdateOneRequiredWithoutQuestsNestedInput
    userQuests?: UserQuestsUpdateManyWithoutQuestNestedInput
  }

  export type QuestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    userQuests?: UserQuestsUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestsCreateManyInput = {
    id?: string
    gameId: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
  }

  export type QuestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserQuestsCreateInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    game: GameCreateNestedOneWithoutUserQuestsInput
    quest: QuestsCreateNestedOneWithoutUserQuestsInput
    user: UserCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateInput = {
    id?: string
    questsId: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutUserQuestsNestedInput
    quest?: QuestsUpdateOneRequiredWithoutUserQuestsNestedInput
    user?: UserUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsCreateManyInput = {
    id?: string
    questsId: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoftwareCreateInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutSoftwareInput
    game: GameCreateNestedOneWithoutSoftwareInput
    user: UserCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateInput = {
    id?: string
    userId: number
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutSoftwareNestedInput
    game?: GameUpdateOneRequiredWithoutSoftwareNestedInput
    user?: UserUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateManyInput = {
    id?: string
    userId: number
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutProcessInput
    game: GameCreateNestedOneWithoutProcessInput
    user: UserCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutProcessNestedInput
    game?: GameUpdateOneRequiredWithoutProcessNestedInput
    user?: UserUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateManyInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationsCreateInput = {
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsCreateManyInput = {
    id?: number
    userId: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogsCreateInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutLogsInput
    game: GameCreateNestedOneWithoutLogsInput
    user: UserCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsUpdateInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutLogsNestedInput
    game?: GameUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsCreateManyInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsUpdateManyMutationInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeCreateInput = {
    marketId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    instructionType: $Enums.InstructionNamedType
    buyIntoTargetFund: FundCreateNestedOneWithoutTradesInput
    user: UserCreateNestedOneWithoutOngoingTradesInput
    portfolio: PortfolioCreateNestedOneWithoutTradesInput
  }

  export type TradeUncheckedCreateInput = {
    id?: number
    userId: number
    marketId: number
    portfolioId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    buyIntoTargetFundid: number
    instructionType: $Enums.InstructionNamedType
  }

  export type TradeUpdateInput = {
    marketId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
    buyIntoTargetFund?: FundUpdateOneRequiredWithoutTradesNestedInput
    user?: UserUpdateOneRequiredWithoutOngoingTradesNestedInput
    portfolio?: PortfolioUpdateOneRequiredWithoutTradesNestedInput
  }

  export type TradeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyIntoTargetFundid?: IntFieldUpdateOperationsInput | number
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type TradeCreateManyInput = {
    id?: number
    userId: number
    marketId: number
    portfolioId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    buyIntoTargetFundid: number
    instructionType: $Enums.InstructionNamedType
  }

  export type TradeUpdateManyMutationInput = {
    marketId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type TradeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyIntoTargetFundid?: IntFieldUpdateOperationsInput | number
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type FundCreateInput = {
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fundManager: UserCreateNestedOneWithoutManagedFundsInput
    trades?: TradeCreateNestedManyWithoutBuyIntoTargetFundInput
    holdings?: PortfolioHoldingCreateNestedManyWithoutFundInput
    hedgeFunds?: HedgeFundCreateNestedManyWithoutFundInput
  }

  export type FundUncheckedCreateInput = {
    id?: number
    fundManagerId: number
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: TradeUncheckedCreateNestedManyWithoutBuyIntoTargetFundInput
    holdings?: PortfolioHoldingUncheckedCreateNestedManyWithoutFundInput
    hedgeFunds?: HedgeFundUncheckedCreateNestedManyWithoutFundInput
  }

  export type FundUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundManager?: UserUpdateOneRequiredWithoutManagedFundsNestedInput
    trades?: TradeUpdateManyWithoutBuyIntoTargetFundNestedInput
    holdings?: PortfolioHoldingUpdateManyWithoutFundNestedInput
    hedgeFunds?: HedgeFundUpdateManyWithoutFundNestedInput
  }

  export type FundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundManagerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: TradeUncheckedUpdateManyWithoutBuyIntoTargetFundNestedInput
    holdings?: PortfolioHoldingUncheckedUpdateManyWithoutFundNestedInput
    hedgeFunds?: HedgeFundUncheckedUpdateManyWithoutFundNestedInput
  }

  export type FundCreateManyInput = {
    id?: number
    fundManagerId: number
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundManagerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCreateInput = {
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPortfoliosInput
    holdings?: PortfolioHoldingCreateNestedManyWithoutPortfolioInput
    trades?: TradeCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateInput = {
    id?: number
    userId: number
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    holdings?: PortfolioHoldingUncheckedCreateNestedManyWithoutPortfolioInput
    trades?: TradeUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    holdings?: PortfolioHoldingUpdateManyWithoutPortfolioNestedInput
    trades?: TradeUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdings?: PortfolioHoldingUncheckedUpdateManyWithoutPortfolioNestedInput
    trades?: TradeUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioCreateManyInput = {
    id?: number
    userId: number
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioHoldingCreateInput = {
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutHoldingsInput
    fund: FundCreateNestedOneWithoutHoldingsInput
  }

  export type PortfolioHoldingUncheckedCreateInput = {
    id?: number
    portfolioId: number
    fundId: number
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioHoldingUpdateInput = {
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutHoldingsNestedInput
    fund?: FundUpdateOneRequiredWithoutHoldingsNestedInput
  }

  export type PortfolioHoldingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    fundId?: IntFieldUpdateOperationsInput | number
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioHoldingCreateManyInput = {
    id?: number
    portfolioId: number
    fundId: number
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioHoldingUpdateManyMutationInput = {
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioHoldingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    fundId?: IntFieldUpdateOperationsInput | number
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HedgeFundCreateInput = {
    strategy: string
    riskLevel: string
    minimumLockPeriod?: number
    managementFee?: Decimal | DecimalJsLike | number | string
    performanceFee?: Decimal | DecimalJsLike | number | string
    highWaterMark?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fund: FundCreateNestedOneWithoutHedgeFundsInput
  }

  export type HedgeFundUncheckedCreateInput = {
    id?: number
    fundId: number
    strategy: string
    riskLevel: string
    minimumLockPeriod?: number
    managementFee?: Decimal | DecimalJsLike | number | string
    performanceFee?: Decimal | DecimalJsLike | number | string
    highWaterMark?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HedgeFundUpdateInput = {
    strategy?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    minimumLockPeriod?: IntFieldUpdateOperationsInput | number
    managementFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fund?: FundUpdateOneRequiredWithoutHedgeFundsNestedInput
  }

  export type HedgeFundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundId?: IntFieldUpdateOperationsInput | number
    strategy?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    minimumLockPeriod?: IntFieldUpdateOperationsInput | number
    managementFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HedgeFundCreateManyInput = {
    id?: number
    fundId: number
    strategy: string
    riskLevel: string
    minimumLockPeriod?: number
    managementFee?: Decimal | DecimalJsLike | number | string
    performanceFee?: Decimal | DecimalJsLike | number | string
    highWaterMark?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HedgeFundUpdateManyMutationInput = {
    strategy?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    minimumLockPeriod?: IntFieldUpdateOperationsInput | number
    managementFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HedgeFundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundId?: IntFieldUpdateOperationsInput | number
    strategy?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    minimumLockPeriod?: IntFieldUpdateOperationsInput | number
    managementFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGroupsFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsFilter<$PrismaModel> | $Enums.Groups
  }

  export type AccountBookListRelationFilter = {
    every?: AccountBookWhereInput
    some?: AccountBookWhereInput
    none?: AccountBookWhereInput
  }

  export type AddressBookListRelationFilter = {
    every?: AddressBookWhereInput
    some?: AddressBookWhereInput
    none?: AddressBookWhereInput
  }

  export type ComputerListRelationFilter = {
    every?: ComputerWhereInput
    some?: ComputerWhereInput
    none?: ComputerWhereInput
  }

  export type DNSListRelationFilter = {
    every?: DNSWhereInput
    some?: DNSWhereInput
    none?: DNSWhereInput
  }

  export type LogsListRelationFilter = {
    every?: LogsWhereInput
    some?: LogsWhereInput
    none?: LogsWhereInput
  }

  export type MemoryListRelationFilter = {
    every?: MemoryWhereInput
    some?: MemoryWhereInput
    none?: MemoryWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type ProcessListRelationFilter = {
    every?: ProcessWhereInput
    some?: ProcessWhereInput
    none?: ProcessWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SoftwareListRelationFilter = {
    every?: SoftwareWhereInput
    some?: SoftwareWhereInput
    none?: SoftwareWhereInput
  }

  export type UserQuestsListRelationFilter = {
    every?: UserQuestsWhereInput
    some?: UserQuestsWhereInput
    none?: UserQuestsWhereInput
  }

  export type PortfolioListRelationFilter = {
    every?: PortfolioWhereInput
    some?: PortfolioWhereInput
    none?: PortfolioWhereInput
  }

  export type TradeListRelationFilter = {
    every?: TradeWhereInput
    some?: TradeWhereInput
    none?: TradeWhereInput
  }

  export type FundListRelationFilter = {
    every?: FundWhereInput
    some?: FundWhereInput
    none?: FundWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComputerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DNSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SoftwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserQuestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrder
    group?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrder
    group?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    refreshToken?: SortOrder
    group?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGroupsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsWithAggregatesFilter<$PrismaModel> | $Enums.Groups
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupsFilter<$PrismaModel>
    _max?: NestedEnumGroupsFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type HardwareListRelationFilter = {
    every?: HardwareWhereInput
    some?: HardwareWhereInput
    none?: HardwareWhereInput
  }

  export type QuestsListRelationFilter = {
    every?: QuestsWhereInput
    some?: QuestsWhereInput
    none?: QuestsWhereInput
  }

  export type HardwareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    lastAction?: SortOrder
    created?: SortOrder
    expires?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumHardwareTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesFilter<$PrismaModel> | $Enums.HardwareTypes
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ComputerRelationFilter = {
    is?: ComputerWhereInput
    isNot?: ComputerWhereInput
  }

  export type GameRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type HardwareCountOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
  }

  export type HardwareAvgOrderByAggregateInput = {
    id?: SortOrder
    strength?: SortOrder
  }

  export type HardwareMaxOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
  }

  export type HardwareMinOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    strength?: SortOrder
  }

  export type HardwareSumOrderByAggregateInput = {
    id?: SortOrder
    strength?: SortOrder
  }

  export type EnumHardwareTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesWithAggregatesFilter<$PrismaModel> | $Enums.HardwareTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHardwareTypesFilter<$PrismaModel>
    _max?: NestedEnumHardwareTypesFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AddressBookCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
  }

  export type AddressBookAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AddressBookMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
  }

  export type AddressBookMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    access?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
  }

  export type AddressBookSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DNSCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
  }

  export type DNSAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DNSMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
  }

  export type DNSMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    website?: SortOrder
    tags?: SortOrder
    description?: SortOrder
    updated?: SortOrder
    created?: SortOrder
  }

  export type DNSSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MemoryRelationFilter = {
    is?: MemoryWhereInput
    isNot?: MemoryWhereInput
  }

  export type AccountBookCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    data?: SortOrder
    gameId?: SortOrder
  }

  export type AccountBookAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AccountBookMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    gameId?: SortOrder
  }

  export type AccountBookMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    memoryId?: SortOrder
    gameId?: SortOrder
  }

  export type AccountBookSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    data?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MemoryCountOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
    data?: SortOrder
  }

  export type MemoryAvgOrderByAggregateInput = {
    userId?: SortOrder
    value?: SortOrder
  }

  export type MemoryMaxOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type MemoryMinOrderByAggregateInput = {
    id?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type MemorySumOrderByAggregateInput = {
    userId?: SortOrder
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ComputerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ComputerAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ComputerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ComputerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    gameId?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ComputerSumOrderByAggregateInput = {
    userId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuestsCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    reward?: SortOrder
    open?: SortOrder
  }

  export type QuestsMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    open?: SortOrder
  }

  export type QuestsMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    open?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuestsRelationFilter = {
    is?: QuestsWhereInput
    isNot?: QuestsWhereInput
  }

  export type UserQuestsCountOrderByAggregateInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserQuestsAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserQuestsMaxOrderByAggregateInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserQuestsMinOrderByAggregateInput = {
    id?: SortOrder
    questsId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    completed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserQuestsSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SoftwareCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
  }

  export type SoftwareAvgOrderByAggregateInput = {
    userId?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
  }

  export type SoftwareMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SoftwareMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
    installed?: SortOrder
    executed?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SoftwareSumOrderByAggregateInput = {
    userId?: SortOrder
    level?: SortOrder
    size?: SortOrder
    opacity?: SortOrder
  }

  export type ProcessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
    data?: SortOrder
  }

  export type ProcessAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
  }

  export type ProcessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    ip?: SortOrder
    gameId?: SortOrder
    type?: SortOrder
    started?: SortOrder
    completion?: SortOrder
  }

  export type ProcessSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
  }

  export type NotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    read?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    read?: SortOrder
  }

  export type NotificationsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type LogsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type LogsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    computerId?: SortOrder
    senderId?: SortOrder
    senderIp?: SortOrder
    gameId?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type LogsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumInstructionNamedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstructionNamedType | EnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstructionNamedTypeFilter<$PrismaModel> | $Enums.InstructionNamedType
  }

  export type FundRelationFilter = {
    is?: FundWhereInput
    isNot?: FundWhereInput
  }

  export type PortfolioRelationFilter = {
    is?: PortfolioWhereInput
    isNot?: PortfolioWhereInput
  }

  export type TradeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    portfolioId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalValue?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    buyIntoTargetFundid?: SortOrder
    instructionType?: SortOrder
  }

  export type TradeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    portfolioId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalValue?: SortOrder
    buyIntoTargetFundid?: SortOrder
  }

  export type TradeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    portfolioId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalValue?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    buyIntoTargetFundid?: SortOrder
    instructionType?: SortOrder
  }

  export type TradeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    portfolioId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalValue?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    buyIntoTargetFundid?: SortOrder
    instructionType?: SortOrder
  }

  export type TradeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketId?: SortOrder
    portfolioId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalValue?: SortOrder
    buyIntoTargetFundid?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumInstructionNamedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstructionNamedType | EnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstructionNamedTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstructionNamedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstructionNamedTypeFilter<$PrismaModel>
    _max?: NestedEnumInstructionNamedTypeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PortfolioHoldingListRelationFilter = {
    every?: PortfolioHoldingWhereInput
    some?: PortfolioHoldingWhereInput
    none?: PortfolioHoldingWhereInput
  }

  export type HedgeFundListRelationFilter = {
    every?: HedgeFundWhereInput
    some?: HedgeFundWhereInput
    none?: HedgeFundWhereInput
  }

  export type PortfolioHoldingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HedgeFundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FundCountOrderByAggregateInput = {
    id?: SortOrder
    fundManagerId?: SortOrder
    name?: SortOrder
    minimumInvestmentAmount?: SortOrder
    totalFundCharge?: SortOrder
    totalFundCost?: SortOrder
    totalAssets?: SortOrder
    isActive?: SortOrder
    maxInvestors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundAvgOrderByAggregateInput = {
    id?: SortOrder
    fundManagerId?: SortOrder
    minimumInvestmentAmount?: SortOrder
    totalFundCharge?: SortOrder
    totalFundCost?: SortOrder
    totalAssets?: SortOrder
    maxInvestors?: SortOrder
  }

  export type FundMaxOrderByAggregateInput = {
    id?: SortOrder
    fundManagerId?: SortOrder
    name?: SortOrder
    minimumInvestmentAmount?: SortOrder
    totalFundCharge?: SortOrder
    totalFundCost?: SortOrder
    totalAssets?: SortOrder
    isActive?: SortOrder
    maxInvestors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundMinOrderByAggregateInput = {
    id?: SortOrder
    fundManagerId?: SortOrder
    name?: SortOrder
    minimumInvestmentAmount?: SortOrder
    totalFundCharge?: SortOrder
    totalFundCost?: SortOrder
    totalAssets?: SortOrder
    isActive?: SortOrder
    maxInvestors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundSumOrderByAggregateInput = {
    id?: SortOrder
    fundManagerId?: SortOrder
    minimumInvestmentAmount?: SortOrder
    totalFundCharge?: SortOrder
    totalFundCost?: SortOrder
    totalAssets?: SortOrder
    maxInvestors?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PortfolioCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    totalValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalValue?: SortOrder
  }

  export type PortfolioMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    totalValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    totalValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalValue?: SortOrder
  }

  export type PortfolioHoldingCountOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    fundId?: SortOrder
    quantity?: SortOrder
    averagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioHoldingAvgOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    fundId?: SortOrder
    quantity?: SortOrder
    averagePrice?: SortOrder
  }

  export type PortfolioHoldingMaxOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    fundId?: SortOrder
    quantity?: SortOrder
    averagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioHoldingMinOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    fundId?: SortOrder
    quantity?: SortOrder
    averagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioHoldingSumOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    fundId?: SortOrder
    quantity?: SortOrder
    averagePrice?: SortOrder
  }

  export type HedgeFundCountOrderByAggregateInput = {
    id?: SortOrder
    fundId?: SortOrder
    strategy?: SortOrder
    riskLevel?: SortOrder
    minimumLockPeriod?: SortOrder
    managementFee?: SortOrder
    performanceFee?: SortOrder
    highWaterMark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HedgeFundAvgOrderByAggregateInput = {
    id?: SortOrder
    fundId?: SortOrder
    minimumLockPeriod?: SortOrder
    managementFee?: SortOrder
    performanceFee?: SortOrder
    highWaterMark?: SortOrder
  }

  export type HedgeFundMaxOrderByAggregateInput = {
    id?: SortOrder
    fundId?: SortOrder
    strategy?: SortOrder
    riskLevel?: SortOrder
    minimumLockPeriod?: SortOrder
    managementFee?: SortOrder
    performanceFee?: SortOrder
    highWaterMark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HedgeFundMinOrderByAggregateInput = {
    id?: SortOrder
    fundId?: SortOrder
    strategy?: SortOrder
    riskLevel?: SortOrder
    minimumLockPeriod?: SortOrder
    managementFee?: SortOrder
    performanceFee?: SortOrder
    highWaterMark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HedgeFundSumOrderByAggregateInput = {
    id?: SortOrder
    fundId?: SortOrder
    minimumLockPeriod?: SortOrder
    managementFee?: SortOrder
    performanceFee?: SortOrder
    highWaterMark?: SortOrder
  }

  export type AccountBookCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type AddressBookCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type ComputerCreateNestedManyWithoutUserInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type DNSCreateNestedManyWithoutUserInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutUserInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type MemoryCreateNestedManyWithoutUserInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SoftwareCreateNestedManyWithoutUserInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type UserQuestsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type PortfolioCreateNestedManyWithoutUserInput = {
    create?: XOR<PortfolioCreateWithoutUserInput, PortfolioUncheckedCreateWithoutUserInput> | PortfolioCreateWithoutUserInput[] | PortfolioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutUserInput | PortfolioCreateOrConnectWithoutUserInput[]
    createMany?: PortfolioCreateManyUserInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type TradeCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type FundCreateNestedManyWithoutFundManagerInput = {
    create?: XOR<FundCreateWithoutFundManagerInput, FundUncheckedCreateWithoutFundManagerInput> | FundCreateWithoutFundManagerInput[] | FundUncheckedCreateWithoutFundManagerInput[]
    connectOrCreate?: FundCreateOrConnectWithoutFundManagerInput | FundCreateOrConnectWithoutFundManagerInput[]
    createMany?: FundCreateManyFundManagerInputEnvelope
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
  }

  export type AccountBookUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type AddressBookUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type ComputerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type DNSUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type MemoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SoftwareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type UserQuestsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type PortfolioUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PortfolioCreateWithoutUserInput, PortfolioUncheckedCreateWithoutUserInput> | PortfolioCreateWithoutUserInput[] | PortfolioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutUserInput | PortfolioCreateOrConnectWithoutUserInput[]
    createMany?: PortfolioCreateManyUserInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type FundUncheckedCreateNestedManyWithoutFundManagerInput = {
    create?: XOR<FundCreateWithoutFundManagerInput, FundUncheckedCreateWithoutFundManagerInput> | FundCreateWithoutFundManagerInput[] | FundUncheckedCreateWithoutFundManagerInput[]
    connectOrCreate?: FundCreateOrConnectWithoutFundManagerInput | FundCreateOrConnectWithoutFundManagerInput[]
    createMany?: FundCreateManyFundManagerInputEnvelope
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGroupsFieldUpdateOperationsInput = {
    set?: $Enums.Groups
  }

  export type AccountBookUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutUserInput | AccountBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutUserInput | AccountBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutUserInput | AccountBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AddressBookUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutUserInput | AddressBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutUserInput | AddressBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutUserInput | AddressBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type ComputerUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutUserInput | ComputerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutUserInput | ComputerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutUserInput | ComputerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type DNSUpdateManyWithoutUserNestedInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutUserInput | DNSUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutUserInput | DNSUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutUserInput | DNSUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUserInput | LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUserInput | LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUserInput | LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type MemoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutUserInput | MemoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutUserInput | MemoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutUserInput | MemoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SoftwareUpdateManyWithoutUserNestedInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutUserInput | SoftwareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutUserInput | SoftwareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutUserInput | SoftwareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type UserQuestsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutUserInput | UserQuestsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutUserInput | UserQuestsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutUserInput | UserQuestsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type PortfolioUpdateManyWithoutUserNestedInput = {
    create?: XOR<PortfolioCreateWithoutUserInput, PortfolioUncheckedCreateWithoutUserInput> | PortfolioCreateWithoutUserInput[] | PortfolioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutUserInput | PortfolioCreateOrConnectWithoutUserInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutUserInput | PortfolioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PortfolioCreateManyUserInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutUserInput | PortfolioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutUserInput | PortfolioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type TradeUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutUserInput | TradeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutUserInput | TradeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutUserInput | TradeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type FundUpdateManyWithoutFundManagerNestedInput = {
    create?: XOR<FundCreateWithoutFundManagerInput, FundUncheckedCreateWithoutFundManagerInput> | FundCreateWithoutFundManagerInput[] | FundUncheckedCreateWithoutFundManagerInput[]
    connectOrCreate?: FundCreateOrConnectWithoutFundManagerInput | FundCreateOrConnectWithoutFundManagerInput[]
    upsert?: FundUpsertWithWhereUniqueWithoutFundManagerInput | FundUpsertWithWhereUniqueWithoutFundManagerInput[]
    createMany?: FundCreateManyFundManagerInputEnvelope
    set?: FundWhereUniqueInput | FundWhereUniqueInput[]
    disconnect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    delete?: FundWhereUniqueInput | FundWhereUniqueInput[]
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    update?: FundUpdateWithWhereUniqueWithoutFundManagerInput | FundUpdateWithWhereUniqueWithoutFundManagerInput[]
    updateMany?: FundUpdateManyWithWhereWithoutFundManagerInput | FundUpdateManyWithWhereWithoutFundManagerInput[]
    deleteMany?: FundScalarWhereInput | FundScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountBookUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput> | AccountBookCreateWithoutUserInput[] | AccountBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutUserInput | AccountBookCreateOrConnectWithoutUserInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutUserInput | AccountBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountBookCreateManyUserInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutUserInput | AccountBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutUserInput | AccountBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AddressBookUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput> | AddressBookCreateWithoutUserInput[] | AddressBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutUserInput | AddressBookCreateOrConnectWithoutUserInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutUserInput | AddressBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressBookCreateManyUserInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutUserInput | AddressBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutUserInput | AddressBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type ComputerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput> | ComputerCreateWithoutUserInput[] | ComputerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutUserInput | ComputerCreateOrConnectWithoutUserInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutUserInput | ComputerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComputerCreateManyUserInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutUserInput | ComputerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutUserInput | ComputerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type DNSUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput> | DNSCreateWithoutUserInput[] | DNSUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutUserInput | DNSCreateOrConnectWithoutUserInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutUserInput | DNSUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DNSCreateManyUserInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutUserInput | DNSUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutUserInput | DNSUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUserInput | LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUserInput | LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUserInput | LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type MemoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput> | MemoryCreateWithoutUserInput[] | MemoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutUserInput | MemoryCreateOrConnectWithoutUserInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutUserInput | MemoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemoryCreateManyUserInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutUserInput | MemoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutUserInput | MemoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SoftwareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput> | SoftwareCreateWithoutUserInput[] | SoftwareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutUserInput | SoftwareCreateOrConnectWithoutUserInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutUserInput | SoftwareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SoftwareCreateManyUserInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutUserInput | SoftwareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutUserInput | SoftwareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type UserQuestsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput> | UserQuestsCreateWithoutUserInput[] | UserQuestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutUserInput | UserQuestsCreateOrConnectWithoutUserInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutUserInput | UserQuestsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQuestsCreateManyUserInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutUserInput | UserQuestsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutUserInput | UserQuestsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type PortfolioUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PortfolioCreateWithoutUserInput, PortfolioUncheckedCreateWithoutUserInput> | PortfolioCreateWithoutUserInput[] | PortfolioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutUserInput | PortfolioCreateOrConnectWithoutUserInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutUserInput | PortfolioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PortfolioCreateManyUserInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutUserInput | PortfolioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutUserInput | PortfolioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutUserInput | TradeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutUserInput | TradeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutUserInput | TradeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type FundUncheckedUpdateManyWithoutFundManagerNestedInput = {
    create?: XOR<FundCreateWithoutFundManagerInput, FundUncheckedCreateWithoutFundManagerInput> | FundCreateWithoutFundManagerInput[] | FundUncheckedCreateWithoutFundManagerInput[]
    connectOrCreate?: FundCreateOrConnectWithoutFundManagerInput | FundCreateOrConnectWithoutFundManagerInput[]
    upsert?: FundUpsertWithWhereUniqueWithoutFundManagerInput | FundUpsertWithWhereUniqueWithoutFundManagerInput[]
    createMany?: FundCreateManyFundManagerInputEnvelope
    set?: FundWhereUniqueInput | FundWhereUniqueInput[]
    disconnect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    delete?: FundWhereUniqueInput | FundWhereUniqueInput[]
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    update?: FundUpdateWithWhereUniqueWithoutFundManagerInput | FundUpdateWithWhereUniqueWithoutFundManagerInput[]
    updateMany?: FundUpdateManyWithWhereWithoutFundManagerInput | FundUpdateManyWithWhereWithoutFundManagerInput[]
    deleteMany?: FundScalarWhereInput | FundScalarWhereInput[]
  }

  export type AccountBookCreateNestedManyWithoutGameInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type AddressBookCreateNestedManyWithoutGameInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type ComputerCreateNestedManyWithoutGameInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type DNSCreateNestedManyWithoutGameInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type HardwareCreateNestedManyWithoutGameInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutGameInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type MemoryCreateNestedManyWithoutGameInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutGameInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutGameInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type QuestsCreateNestedManyWithoutGameInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
  }

  export type SoftwareCreateNestedManyWithoutGameInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type UserQuestsCreateNestedManyWithoutGameInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type AccountBookUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type AddressBookUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type ComputerUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
  }

  export type DNSUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type HardwareUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type MemoryUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type QuestsUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
  }

  export type SoftwareUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type UserQuestsUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountBookUpdateManyWithoutGameNestedInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutGameInput | AccountBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutGameInput | AccountBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutGameInput | AccountBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AddressBookUpdateManyWithoutGameNestedInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutGameInput | AddressBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutGameInput | AddressBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutGameInput | AddressBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type ComputerUpdateManyWithoutGameNestedInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutGameInput | ComputerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutGameInput | ComputerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutGameInput | ComputerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type DNSUpdateManyWithoutGameNestedInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutGameInput | DNSUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutGameInput | DNSUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutGameInput | DNSUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type HardwareUpdateManyWithoutGameNestedInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutGameInput | HardwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutGameInput | HardwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutGameInput | HardwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutGameNestedInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutGameInput | LogsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutGameInput | LogsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutGameInput | LogsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type MemoryUpdateManyWithoutGameNestedInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutGameInput | MemoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutGameInput | MemoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutGameInput | MemoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutGameInput | ProcessUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutGameInput | ProcessUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutGameInput | ProcessUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutGameInput | ProfileUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutGameInput | ProfileUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutGameInput | ProfileUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type QuestsUpdateManyWithoutGameNestedInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    upsert?: QuestsUpsertWithWhereUniqueWithoutGameInput | QuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    set?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    disconnect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    delete?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    update?: QuestsUpdateWithWhereUniqueWithoutGameInput | QuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: QuestsUpdateManyWithWhereWithoutGameInput | QuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
  }

  export type SoftwareUpdateManyWithoutGameNestedInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutGameInput | SoftwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutGameInput | SoftwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutGameInput | SoftwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type UserQuestsUpdateManyWithoutGameNestedInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutGameInput | UserQuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutGameInput | UserQuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutGameInput | UserQuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type AccountBookUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput> | AccountBookCreateWithoutGameInput[] | AccountBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutGameInput | AccountBookCreateOrConnectWithoutGameInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutGameInput | AccountBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AccountBookCreateManyGameInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutGameInput | AccountBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutGameInput | AccountBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AddressBookUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput> | AddressBookCreateWithoutGameInput[] | AddressBookUncheckedCreateWithoutGameInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutGameInput | AddressBookCreateOrConnectWithoutGameInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutGameInput | AddressBookUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: AddressBookCreateManyGameInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutGameInput | AddressBookUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutGameInput | AddressBookUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type ComputerUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput> | ComputerCreateWithoutGameInput[] | ComputerUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ComputerCreateOrConnectWithoutGameInput | ComputerCreateOrConnectWithoutGameInput[]
    upsert?: ComputerUpsertWithWhereUniqueWithoutGameInput | ComputerUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ComputerCreateManyGameInputEnvelope
    set?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    disconnect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    delete?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    connect?: ComputerWhereUniqueInput | ComputerWhereUniqueInput[]
    update?: ComputerUpdateWithWhereUniqueWithoutGameInput | ComputerUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ComputerUpdateManyWithWhereWithoutGameInput | ComputerUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
  }

  export type DNSUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput> | DNSCreateWithoutGameInput[] | DNSUncheckedCreateWithoutGameInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutGameInput | DNSCreateOrConnectWithoutGameInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutGameInput | DNSUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: DNSCreateManyGameInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutGameInput | DNSUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutGameInput | DNSUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type HardwareUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput> | HardwareCreateWithoutGameInput[] | HardwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutGameInput | HardwareCreateOrConnectWithoutGameInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutGameInput | HardwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: HardwareCreateManyGameInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutGameInput | HardwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutGameInput | HardwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput> | LogsCreateWithoutGameInput[] | LogsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutGameInput | LogsCreateOrConnectWithoutGameInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutGameInput | LogsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: LogsCreateManyGameInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutGameInput | LogsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutGameInput | LogsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type MemoryUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput> | MemoryCreateWithoutGameInput[] | MemoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutGameInput | MemoryCreateOrConnectWithoutGameInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutGameInput | MemoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: MemoryCreateManyGameInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutGameInput | MemoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutGameInput | MemoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput> | ProcessCreateWithoutGameInput[] | ProcessUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGameInput | ProcessCreateOrConnectWithoutGameInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutGameInput | ProcessUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProcessCreateManyGameInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutGameInput | ProcessUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutGameInput | ProcessUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput> | ProfileCreateWithoutGameInput[] | ProfileUncheckedCreateWithoutGameInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutGameInput | ProfileCreateOrConnectWithoutGameInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutGameInput | ProfileUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: ProfileCreateManyGameInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutGameInput | ProfileUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutGameInput | ProfileUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type QuestsUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput> | QuestsCreateWithoutGameInput[] | QuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: QuestsCreateOrConnectWithoutGameInput | QuestsCreateOrConnectWithoutGameInput[]
    upsert?: QuestsUpsertWithWhereUniqueWithoutGameInput | QuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: QuestsCreateManyGameInputEnvelope
    set?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    disconnect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    delete?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    connect?: QuestsWhereUniqueInput | QuestsWhereUniqueInput[]
    update?: QuestsUpdateWithWhereUniqueWithoutGameInput | QuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: QuestsUpdateManyWithWhereWithoutGameInput | QuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
  }

  export type SoftwareUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput> | SoftwareCreateWithoutGameInput[] | SoftwareUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutGameInput | SoftwareCreateOrConnectWithoutGameInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutGameInput | SoftwareUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: SoftwareCreateManyGameInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutGameInput | SoftwareUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutGameInput | SoftwareUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type UserQuestsUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput> | UserQuestsCreateWithoutGameInput[] | UserQuestsUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutGameInput | UserQuestsCreateOrConnectWithoutGameInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutGameInput | UserQuestsUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: UserQuestsCreateManyGameInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutGameInput | UserQuestsUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutGameInput | UserQuestsUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    upsert?: UserUpsertWithoutSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>
  }

  export type ComputerCreateNestedOneWithoutHardwareInput = {
    create?: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutHardwareInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutHardwareInput = {
    create?: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutHardwareInput
    connect?: GameWhereUniqueInput
  }

  export type EnumHardwareTypesFieldUpdateOperationsInput = {
    set?: $Enums.HardwareTypes
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComputerUpdateOneRequiredWithoutHardwareNestedInput = {
    create?: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutHardwareInput
    upsert?: ComputerUpsertWithoutHardwareInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutHardwareInput, ComputerUpdateWithoutHardwareInput>, ComputerUncheckedUpdateWithoutHardwareInput>
  }

  export type GameUpdateOneRequiredWithoutHardwareNestedInput = {
    create?: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutHardwareInput
    upsert?: GameUpsertWithoutHardwareInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutHardwareInput, GameUpdateWithoutHardwareInput>, GameUncheckedUpdateWithoutHardwareInput>
  }

  export type ComputerCreateNestedOneWithoutAddressBookInput = {
    create?: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAddressBookInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutAddressBookInput = {
    create?: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAddressBookInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAddressBookInput = {
    create?: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressBookInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type ComputerUpdateOneRequiredWithoutAddressBookNestedInput = {
    create?: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAddressBookInput
    upsert?: ComputerUpsertWithoutAddressBookInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutAddressBookInput, ComputerUpdateWithoutAddressBookInput>, ComputerUncheckedUpdateWithoutAddressBookInput>
  }

  export type GameUpdateOneRequiredWithoutAddressBookNestedInput = {
    create?: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAddressBookInput
    upsert?: GameUpsertWithoutAddressBookInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutAddressBookInput, GameUpdateWithoutAddressBookInput>, GameUncheckedUpdateWithoutAddressBookInput>
  }

  export type UserUpdateOneRequiredWithoutAddressBookNestedInput = {
    create?: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressBookInput
    upsert?: UserUpsertWithoutAddressBookInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressBookInput, UserUpdateWithoutAddressBookInput>, UserUncheckedUpdateWithoutAddressBookInput>
  }

  export type ComputerCreateNestedOneWithoutDnsInput = {
    create?: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutDnsInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutDnsInput = {
    create?: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
    connectOrCreate?: GameCreateOrConnectWithoutDnsInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDnsInput = {
    create?: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDnsInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerUpdateOneRequiredWithoutDnsNestedInput = {
    create?: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutDnsInput
    upsert?: ComputerUpsertWithoutDnsInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutDnsInput, ComputerUpdateWithoutDnsInput>, ComputerUncheckedUpdateWithoutDnsInput>
  }

  export type GameUpdateOneRequiredWithoutDnsNestedInput = {
    create?: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
    connectOrCreate?: GameCreateOrConnectWithoutDnsInput
    upsert?: GameUpsertWithoutDnsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutDnsInput, GameUpdateWithoutDnsInput>, GameUncheckedUpdateWithoutDnsInput>
  }

  export type UserUpdateOneRequiredWithoutDnsNestedInput = {
    create?: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDnsInput
    upsert?: UserUpsertWithoutDnsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDnsInput, UserUpdateWithoutDnsInput>, UserUncheckedUpdateWithoutDnsInput>
  }

  export type ComputerCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAccountBookInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAccountBookInput
    connect?: GameWhereUniqueInput
  }

  export type MemoryCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: MemoryCreateOrConnectWithoutAccountBookInput
    connect?: MemoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAccountBookInput = {
    create?: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountBookInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutAccountBookInput
    upsert?: ComputerUpsertWithoutAccountBookInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutAccountBookInput, ComputerUpdateWithoutAccountBookInput>, ComputerUncheckedUpdateWithoutAccountBookInput>
  }

  export type GameUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: GameCreateOrConnectWithoutAccountBookInput
    upsert?: GameUpsertWithoutAccountBookInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutAccountBookInput, GameUpdateWithoutAccountBookInput>, GameUncheckedUpdateWithoutAccountBookInput>
  }

  export type MemoryUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: MemoryCreateOrConnectWithoutAccountBookInput
    upsert?: MemoryUpsertWithoutAccountBookInput
    connect?: MemoryWhereUniqueInput
    update?: XOR<XOR<MemoryUpdateToOneWithWhereWithoutAccountBookInput, MemoryUpdateWithoutAccountBookInput>, MemoryUncheckedUpdateWithoutAccountBookInput>
  }

  export type UserUpdateOneRequiredWithoutAccountBookNestedInput = {
    create?: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountBookInput
    upsert?: UserUpsertWithoutAccountBookInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountBookInput, UserUpdateWithoutAccountBookInput>, UserUncheckedUpdateWithoutAccountBookInput>
  }

  export type GameCreateNestedOneWithoutProfileInput = {
    create?: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
    connectOrCreate?: GameCreateOrConnectWithoutProfileInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
    connectOrCreate?: GameCreateOrConnectWithoutProfileInput
    upsert?: GameUpsertWithoutProfileInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutProfileInput, GameUpdateWithoutProfileInput>, GameUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type AccountBookCreateNestedManyWithoutMemoryInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type ComputerCreateNestedOneWithoutMemoryInput = {
    create?: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutMemoryInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutMemoryInput = {
    create?: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: GameCreateOrConnectWithoutMemoryInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMemoryInput = {
    create?: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemoryInput
    connect?: UserWhereUniqueInput
  }

  export type AccountBookUncheckedCreateNestedManyWithoutMemoryInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountBookUpdateManyWithoutMemoryNestedInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutMemoryInput | AccountBookUpsertWithWhereUniqueWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutMemoryInput | AccountBookUpdateWithWhereUniqueWithoutMemoryInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutMemoryInput | AccountBookUpdateManyWithWhereWithoutMemoryInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type ComputerUpdateOneRequiredWithoutMemoryNestedInput = {
    create?: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutMemoryInput
    upsert?: ComputerUpsertWithoutMemoryInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutMemoryInput, ComputerUpdateWithoutMemoryInput>, ComputerUncheckedUpdateWithoutMemoryInput>
  }

  export type GameUpdateOneRequiredWithoutMemoryNestedInput = {
    create?: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: GameCreateOrConnectWithoutMemoryInput
    upsert?: GameUpsertWithoutMemoryInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutMemoryInput, GameUpdateWithoutMemoryInput>, GameUncheckedUpdateWithoutMemoryInput>
  }

  export type UserUpdateOneRequiredWithoutMemoryNestedInput = {
    create?: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemoryInput
    upsert?: UserUpsertWithoutMemoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemoryInput, UserUpdateWithoutMemoryInput>, UserUncheckedUpdateWithoutMemoryInput>
  }

  export type AccountBookUncheckedUpdateManyWithoutMemoryNestedInput = {
    create?: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput> | AccountBookCreateWithoutMemoryInput[] | AccountBookUncheckedCreateWithoutMemoryInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutMemoryInput | AccountBookCreateOrConnectWithoutMemoryInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutMemoryInput | AccountBookUpsertWithWhereUniqueWithoutMemoryInput[]
    createMany?: AccountBookCreateManyMemoryInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutMemoryInput | AccountBookUpdateWithWhereUniqueWithoutMemoryInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutMemoryInput | AccountBookUpdateManyWithWhereWithoutMemoryInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AccountBookCreateNestedManyWithoutComputerInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type AddressBookCreateNestedManyWithoutComputerInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type GameCreateNestedOneWithoutComputerInput = {
    create?: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
    connectOrCreate?: GameCreateOrConnectWithoutComputerInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComputerInput = {
    create?: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
    connectOrCreate?: UserCreateOrConnectWithoutComputerInput
    connect?: UserWhereUniqueInput
  }

  export type DNSCreateNestedManyWithoutComputerInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type HardwareCreateNestedManyWithoutComputerInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutComputerInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type MemoryCreateNestedManyWithoutComputerInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutComputerInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type SoftwareCreateNestedManyWithoutComputerInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type AccountBookUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
  }

  export type AddressBookUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
  }

  export type DNSUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
  }

  export type HardwareUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type MemoryUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type SoftwareUncheckedCreateNestedManyWithoutComputerInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
  }

  export type AccountBookUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutComputerInput | AccountBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutComputerInput | AccountBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutComputerInput | AccountBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AddressBookUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutComputerInput | AddressBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutComputerInput | AddressBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutComputerInput | AddressBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type GameUpdateOneRequiredWithoutComputerNestedInput = {
    create?: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
    connectOrCreate?: GameCreateOrConnectWithoutComputerInput
    upsert?: GameUpsertWithoutComputerInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutComputerInput, GameUpdateWithoutComputerInput>, GameUncheckedUpdateWithoutComputerInput>
  }

  export type UserUpdateOneRequiredWithoutComputerNestedInput = {
    create?: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
    connectOrCreate?: UserCreateOrConnectWithoutComputerInput
    upsert?: UserUpsertWithoutComputerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComputerInput, UserUpdateWithoutComputerInput>, UserUncheckedUpdateWithoutComputerInput>
  }

  export type DNSUpdateManyWithoutComputerNestedInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutComputerInput | DNSUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutComputerInput | DNSUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutComputerInput | DNSUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type HardwareUpdateManyWithoutComputerNestedInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutComputerInput | HardwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutComputerInput | HardwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutComputerInput | HardwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutComputerNestedInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutComputerInput | LogsUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutComputerInput | LogsUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutComputerInput | LogsUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type MemoryUpdateManyWithoutComputerNestedInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutComputerInput | MemoryUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutComputerInput | MemoryUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutComputerInput | MemoryUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutComputerNestedInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutComputerInput | ProcessUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutComputerInput | ProcessUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutComputerInput | ProcessUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type SoftwareUpdateManyWithoutComputerNestedInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutComputerInput | SoftwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutComputerInput | SoftwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutComputerInput | SoftwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type AccountBookUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput> | AccountBookCreateWithoutComputerInput[] | AccountBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AccountBookCreateOrConnectWithoutComputerInput | AccountBookCreateOrConnectWithoutComputerInput[]
    upsert?: AccountBookUpsertWithWhereUniqueWithoutComputerInput | AccountBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AccountBookCreateManyComputerInputEnvelope
    set?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    disconnect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    delete?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    connect?: AccountBookWhereUniqueInput | AccountBookWhereUniqueInput[]
    update?: AccountBookUpdateWithWhereUniqueWithoutComputerInput | AccountBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AccountBookUpdateManyWithWhereWithoutComputerInput | AccountBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
  }

  export type AddressBookUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput> | AddressBookCreateWithoutComputerInput[] | AddressBookUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: AddressBookCreateOrConnectWithoutComputerInput | AddressBookCreateOrConnectWithoutComputerInput[]
    upsert?: AddressBookUpsertWithWhereUniqueWithoutComputerInput | AddressBookUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: AddressBookCreateManyComputerInputEnvelope
    set?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    disconnect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    delete?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    connect?: AddressBookWhereUniqueInput | AddressBookWhereUniqueInput[]
    update?: AddressBookUpdateWithWhereUniqueWithoutComputerInput | AddressBookUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: AddressBookUpdateManyWithWhereWithoutComputerInput | AddressBookUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
  }

  export type DNSUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput> | DNSCreateWithoutComputerInput[] | DNSUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: DNSCreateOrConnectWithoutComputerInput | DNSCreateOrConnectWithoutComputerInput[]
    upsert?: DNSUpsertWithWhereUniqueWithoutComputerInput | DNSUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: DNSCreateManyComputerInputEnvelope
    set?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    disconnect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    delete?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    connect?: DNSWhereUniqueInput | DNSWhereUniqueInput[]
    update?: DNSUpdateWithWhereUniqueWithoutComputerInput | DNSUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: DNSUpdateManyWithWhereWithoutComputerInput | DNSUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: DNSScalarWhereInput | DNSScalarWhereInput[]
  }

  export type HardwareUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput> | HardwareCreateWithoutComputerInput[] | HardwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: HardwareCreateOrConnectWithoutComputerInput | HardwareCreateOrConnectWithoutComputerInput[]
    upsert?: HardwareUpsertWithWhereUniqueWithoutComputerInput | HardwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: HardwareCreateManyComputerInputEnvelope
    set?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    disconnect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    delete?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    connect?: HardwareWhereUniqueInput | HardwareWhereUniqueInput[]
    update?: HardwareUpdateWithWhereUniqueWithoutComputerInput | HardwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: HardwareUpdateManyWithWhereWithoutComputerInput | HardwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput> | LogsCreateWithoutComputerInput[] | LogsUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutComputerInput | LogsCreateOrConnectWithoutComputerInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutComputerInput | LogsUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: LogsCreateManyComputerInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutComputerInput | LogsUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutComputerInput | LogsUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type MemoryUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput> | MemoryCreateWithoutComputerInput[] | MemoryUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: MemoryCreateOrConnectWithoutComputerInput | MemoryCreateOrConnectWithoutComputerInput[]
    upsert?: MemoryUpsertWithWhereUniqueWithoutComputerInput | MemoryUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: MemoryCreateManyComputerInputEnvelope
    set?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    disconnect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    delete?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    connect?: MemoryWhereUniqueInput | MemoryWhereUniqueInput[]
    update?: MemoryUpdateWithWhereUniqueWithoutComputerInput | MemoryUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: MemoryUpdateManyWithWhereWithoutComputerInput | MemoryUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput> | ProcessCreateWithoutComputerInput[] | ProcessUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutComputerInput | ProcessCreateOrConnectWithoutComputerInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutComputerInput | ProcessUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: ProcessCreateManyComputerInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutComputerInput | ProcessUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutComputerInput | ProcessUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type SoftwareUncheckedUpdateManyWithoutComputerNestedInput = {
    create?: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput> | SoftwareCreateWithoutComputerInput[] | SoftwareUncheckedCreateWithoutComputerInput[]
    connectOrCreate?: SoftwareCreateOrConnectWithoutComputerInput | SoftwareCreateOrConnectWithoutComputerInput[]
    upsert?: SoftwareUpsertWithWhereUniqueWithoutComputerInput | SoftwareUpsertWithWhereUniqueWithoutComputerInput[]
    createMany?: SoftwareCreateManyComputerInputEnvelope
    set?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    disconnect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    delete?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    connect?: SoftwareWhereUniqueInput | SoftwareWhereUniqueInput[]
    update?: SoftwareUpdateWithWhereUniqueWithoutComputerInput | SoftwareUpdateWithWhereUniqueWithoutComputerInput[]
    updateMany?: SoftwareUpdateManyWithWhereWithoutComputerInput | SoftwareUpdateManyWithWhereWithoutComputerInput[]
    deleteMany?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutQuestsInput = {
    create?: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutQuestsInput
    connect?: GameWhereUniqueInput
  }

  export type UserQuestsCreateNestedManyWithoutQuestInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type UserQuestsUncheckedCreateNestedManyWithoutQuestInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GameUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutQuestsInput
    upsert?: GameUpsertWithoutQuestsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutQuestsInput, GameUpdateWithoutQuestsInput>, GameUncheckedUpdateWithoutQuestsInput>
  }

  export type UserQuestsUpdateManyWithoutQuestNestedInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutQuestInput | UserQuestsUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutQuestInput | UserQuestsUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutQuestInput | UserQuestsUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type UserQuestsUncheckedUpdateManyWithoutQuestNestedInput = {
    create?: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput> | UserQuestsCreateWithoutQuestInput[] | UserQuestsUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: UserQuestsCreateOrConnectWithoutQuestInput | UserQuestsCreateOrConnectWithoutQuestInput[]
    upsert?: UserQuestsUpsertWithWhereUniqueWithoutQuestInput | UserQuestsUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: UserQuestsCreateManyQuestInputEnvelope
    set?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    disconnect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    delete?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    connect?: UserQuestsWhereUniqueInput | UserQuestsWhereUniqueInput[]
    update?: UserQuestsUpdateWithWhereUniqueWithoutQuestInput | UserQuestsUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: UserQuestsUpdateManyWithWhereWithoutQuestInput | UserQuestsUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutUserQuestsInput = {
    create?: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutUserQuestsInput
    connect?: GameWhereUniqueInput
  }

  export type QuestsCreateNestedOneWithoutUserQuestsInput = {
    create?: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: QuestsCreateOrConnectWithoutUserQuestsInput
    connect?: QuestsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserQuestsInput = {
    create?: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserQuestsInput
    connect?: UserWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutUserQuestsNestedInput = {
    create?: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: GameCreateOrConnectWithoutUserQuestsInput
    upsert?: GameUpsertWithoutUserQuestsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutUserQuestsInput, GameUpdateWithoutUserQuestsInput>, GameUncheckedUpdateWithoutUserQuestsInput>
  }

  export type QuestsUpdateOneRequiredWithoutUserQuestsNestedInput = {
    create?: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: QuestsCreateOrConnectWithoutUserQuestsInput
    upsert?: QuestsUpsertWithoutUserQuestsInput
    connect?: QuestsWhereUniqueInput
    update?: XOR<XOR<QuestsUpdateToOneWithWhereWithoutUserQuestsInput, QuestsUpdateWithoutUserQuestsInput>, QuestsUncheckedUpdateWithoutUserQuestsInput>
  }

  export type UserUpdateOneRequiredWithoutUserQuestsNestedInput = {
    create?: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserQuestsInput
    upsert?: UserUpsertWithoutUserQuestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserQuestsInput, UserUpdateWithoutUserQuestsInput>, UserUncheckedUpdateWithoutUserQuestsInput>
  }

  export type ComputerCreateNestedOneWithoutSoftwareInput = {
    create?: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutSoftwareInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutSoftwareInput = {
    create?: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutSoftwareInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSoftwareInput = {
    create?: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoftwareInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerUpdateOneRequiredWithoutSoftwareNestedInput = {
    create?: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutSoftwareInput
    upsert?: ComputerUpsertWithoutSoftwareInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutSoftwareInput, ComputerUpdateWithoutSoftwareInput>, ComputerUncheckedUpdateWithoutSoftwareInput>
  }

  export type GameUpdateOneRequiredWithoutSoftwareNestedInput = {
    create?: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: GameCreateOrConnectWithoutSoftwareInput
    upsert?: GameUpsertWithoutSoftwareInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutSoftwareInput, GameUpdateWithoutSoftwareInput>, GameUncheckedUpdateWithoutSoftwareInput>
  }

  export type UserUpdateOneRequiredWithoutSoftwareNestedInput = {
    create?: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoftwareInput
    upsert?: UserUpsertWithoutSoftwareInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSoftwareInput, UserUpdateWithoutSoftwareInput>, UserUncheckedUpdateWithoutSoftwareInput>
  }

  export type ComputerCreateNestedOneWithoutProcessInput = {
    create?: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutProcessInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutProcessInput = {
    create?: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
    connectOrCreate?: GameCreateOrConnectWithoutProcessInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProcessInput = {
    create?: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerUpdateOneRequiredWithoutProcessNestedInput = {
    create?: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutProcessInput
    upsert?: ComputerUpsertWithoutProcessInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutProcessInput, ComputerUpdateWithoutProcessInput>, ComputerUncheckedUpdateWithoutProcessInput>
  }

  export type GameUpdateOneRequiredWithoutProcessNestedInput = {
    create?: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
    connectOrCreate?: GameCreateOrConnectWithoutProcessInput
    upsert?: GameUpsertWithoutProcessInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutProcessInput, GameUpdateWithoutProcessInput>, GameUncheckedUpdateWithoutProcessInput>
  }

  export type UserUpdateOneRequiredWithoutProcessNestedInput = {
    create?: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessInput
    upsert?: UserUpsertWithoutProcessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessInput, UserUpdateWithoutProcessInput>, UserUncheckedUpdateWithoutProcessInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ComputerCreateNestedOneWithoutLogsInput = {
    create?: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutLogsInput
    connect?: ComputerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutLogsInput = {
    create?: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
    connectOrCreate?: GameCreateOrConnectWithoutLogsInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ComputerUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ComputerCreateOrConnectWithoutLogsInput
    upsert?: ComputerUpsertWithoutLogsInput
    connect?: ComputerWhereUniqueInput
    update?: XOR<XOR<ComputerUpdateToOneWithWhereWithoutLogsInput, ComputerUpdateWithoutLogsInput>, ComputerUncheckedUpdateWithoutLogsInput>
  }

  export type GameUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
    connectOrCreate?: GameCreateOrConnectWithoutLogsInput
    upsert?: GameUpsertWithoutLogsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutLogsInput, GameUpdateWithoutLogsInput>, GameUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type FundCreateNestedOneWithoutTradesInput = {
    create?: XOR<FundCreateWithoutTradesInput, FundUncheckedCreateWithoutTradesInput>
    connectOrCreate?: FundCreateOrConnectWithoutTradesInput
    connect?: FundWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOngoingTradesInput = {
    create?: XOR<UserCreateWithoutOngoingTradesInput, UserUncheckedCreateWithoutOngoingTradesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOngoingTradesInput
    connect?: UserWhereUniqueInput
  }

  export type PortfolioCreateNestedOneWithoutTradesInput = {
    create?: XOR<PortfolioCreateWithoutTradesInput, PortfolioUncheckedCreateWithoutTradesInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutTradesInput
    connect?: PortfolioWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumInstructionNamedTypeFieldUpdateOperationsInput = {
    set?: $Enums.InstructionNamedType
  }

  export type FundUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<FundCreateWithoutTradesInput, FundUncheckedCreateWithoutTradesInput>
    connectOrCreate?: FundCreateOrConnectWithoutTradesInput
    upsert?: FundUpsertWithoutTradesInput
    connect?: FundWhereUniqueInput
    update?: XOR<XOR<FundUpdateToOneWithWhereWithoutTradesInput, FundUpdateWithoutTradesInput>, FundUncheckedUpdateWithoutTradesInput>
  }

  export type UserUpdateOneRequiredWithoutOngoingTradesNestedInput = {
    create?: XOR<UserCreateWithoutOngoingTradesInput, UserUncheckedCreateWithoutOngoingTradesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOngoingTradesInput
    upsert?: UserUpsertWithoutOngoingTradesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOngoingTradesInput, UserUpdateWithoutOngoingTradesInput>, UserUncheckedUpdateWithoutOngoingTradesInput>
  }

  export type PortfolioUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<PortfolioCreateWithoutTradesInput, PortfolioUncheckedCreateWithoutTradesInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutTradesInput
    upsert?: PortfolioUpsertWithoutTradesInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutTradesInput, PortfolioUpdateWithoutTradesInput>, PortfolioUncheckedUpdateWithoutTradesInput>
  }

  export type UserCreateNestedOneWithoutManagedFundsInput = {
    create?: XOR<UserCreateWithoutManagedFundsInput, UserUncheckedCreateWithoutManagedFundsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedFundsInput
    connect?: UserWhereUniqueInput
  }

  export type TradeCreateNestedManyWithoutBuyIntoTargetFundInput = {
    create?: XOR<TradeCreateWithoutBuyIntoTargetFundInput, TradeUncheckedCreateWithoutBuyIntoTargetFundInput> | TradeCreateWithoutBuyIntoTargetFundInput[] | TradeUncheckedCreateWithoutBuyIntoTargetFundInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutBuyIntoTargetFundInput | TradeCreateOrConnectWithoutBuyIntoTargetFundInput[]
    createMany?: TradeCreateManyBuyIntoTargetFundInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type PortfolioHoldingCreateNestedManyWithoutFundInput = {
    create?: XOR<PortfolioHoldingCreateWithoutFundInput, PortfolioHoldingUncheckedCreateWithoutFundInput> | PortfolioHoldingCreateWithoutFundInput[] | PortfolioHoldingUncheckedCreateWithoutFundInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutFundInput | PortfolioHoldingCreateOrConnectWithoutFundInput[]
    createMany?: PortfolioHoldingCreateManyFundInputEnvelope
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
  }

  export type HedgeFundCreateNestedManyWithoutFundInput = {
    create?: XOR<HedgeFundCreateWithoutFundInput, HedgeFundUncheckedCreateWithoutFundInput> | HedgeFundCreateWithoutFundInput[] | HedgeFundUncheckedCreateWithoutFundInput[]
    connectOrCreate?: HedgeFundCreateOrConnectWithoutFundInput | HedgeFundCreateOrConnectWithoutFundInput[]
    createMany?: HedgeFundCreateManyFundInputEnvelope
    connect?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutBuyIntoTargetFundInput = {
    create?: XOR<TradeCreateWithoutBuyIntoTargetFundInput, TradeUncheckedCreateWithoutBuyIntoTargetFundInput> | TradeCreateWithoutBuyIntoTargetFundInput[] | TradeUncheckedCreateWithoutBuyIntoTargetFundInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutBuyIntoTargetFundInput | TradeCreateOrConnectWithoutBuyIntoTargetFundInput[]
    createMany?: TradeCreateManyBuyIntoTargetFundInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type PortfolioHoldingUncheckedCreateNestedManyWithoutFundInput = {
    create?: XOR<PortfolioHoldingCreateWithoutFundInput, PortfolioHoldingUncheckedCreateWithoutFundInput> | PortfolioHoldingCreateWithoutFundInput[] | PortfolioHoldingUncheckedCreateWithoutFundInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutFundInput | PortfolioHoldingCreateOrConnectWithoutFundInput[]
    createMany?: PortfolioHoldingCreateManyFundInputEnvelope
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
  }

  export type HedgeFundUncheckedCreateNestedManyWithoutFundInput = {
    create?: XOR<HedgeFundCreateWithoutFundInput, HedgeFundUncheckedCreateWithoutFundInput> | HedgeFundCreateWithoutFundInput[] | HedgeFundUncheckedCreateWithoutFundInput[]
    connectOrCreate?: HedgeFundCreateOrConnectWithoutFundInput | HedgeFundCreateOrConnectWithoutFundInput[]
    createMany?: HedgeFundCreateManyFundInputEnvelope
    connect?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutManagedFundsNestedInput = {
    create?: XOR<UserCreateWithoutManagedFundsInput, UserUncheckedCreateWithoutManagedFundsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedFundsInput
    upsert?: UserUpsertWithoutManagedFundsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedFundsInput, UserUpdateWithoutManagedFundsInput>, UserUncheckedUpdateWithoutManagedFundsInput>
  }

  export type TradeUpdateManyWithoutBuyIntoTargetFundNestedInput = {
    create?: XOR<TradeCreateWithoutBuyIntoTargetFundInput, TradeUncheckedCreateWithoutBuyIntoTargetFundInput> | TradeCreateWithoutBuyIntoTargetFundInput[] | TradeUncheckedCreateWithoutBuyIntoTargetFundInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutBuyIntoTargetFundInput | TradeCreateOrConnectWithoutBuyIntoTargetFundInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutBuyIntoTargetFundInput | TradeUpsertWithWhereUniqueWithoutBuyIntoTargetFundInput[]
    createMany?: TradeCreateManyBuyIntoTargetFundInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutBuyIntoTargetFundInput | TradeUpdateWithWhereUniqueWithoutBuyIntoTargetFundInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutBuyIntoTargetFundInput | TradeUpdateManyWithWhereWithoutBuyIntoTargetFundInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type PortfolioHoldingUpdateManyWithoutFundNestedInput = {
    create?: XOR<PortfolioHoldingCreateWithoutFundInput, PortfolioHoldingUncheckedCreateWithoutFundInput> | PortfolioHoldingCreateWithoutFundInput[] | PortfolioHoldingUncheckedCreateWithoutFundInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutFundInput | PortfolioHoldingCreateOrConnectWithoutFundInput[]
    upsert?: PortfolioHoldingUpsertWithWhereUniqueWithoutFundInput | PortfolioHoldingUpsertWithWhereUniqueWithoutFundInput[]
    createMany?: PortfolioHoldingCreateManyFundInputEnvelope
    set?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    disconnect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    delete?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    update?: PortfolioHoldingUpdateWithWhereUniqueWithoutFundInput | PortfolioHoldingUpdateWithWhereUniqueWithoutFundInput[]
    updateMany?: PortfolioHoldingUpdateManyWithWhereWithoutFundInput | PortfolioHoldingUpdateManyWithWhereWithoutFundInput[]
    deleteMany?: PortfolioHoldingScalarWhereInput | PortfolioHoldingScalarWhereInput[]
  }

  export type HedgeFundUpdateManyWithoutFundNestedInput = {
    create?: XOR<HedgeFundCreateWithoutFundInput, HedgeFundUncheckedCreateWithoutFundInput> | HedgeFundCreateWithoutFundInput[] | HedgeFundUncheckedCreateWithoutFundInput[]
    connectOrCreate?: HedgeFundCreateOrConnectWithoutFundInput | HedgeFundCreateOrConnectWithoutFundInput[]
    upsert?: HedgeFundUpsertWithWhereUniqueWithoutFundInput | HedgeFundUpsertWithWhereUniqueWithoutFundInput[]
    createMany?: HedgeFundCreateManyFundInputEnvelope
    set?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    disconnect?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    delete?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    connect?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    update?: HedgeFundUpdateWithWhereUniqueWithoutFundInput | HedgeFundUpdateWithWhereUniqueWithoutFundInput[]
    updateMany?: HedgeFundUpdateManyWithWhereWithoutFundInput | HedgeFundUpdateManyWithWhereWithoutFundInput[]
    deleteMany?: HedgeFundScalarWhereInput | HedgeFundScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutBuyIntoTargetFundNestedInput = {
    create?: XOR<TradeCreateWithoutBuyIntoTargetFundInput, TradeUncheckedCreateWithoutBuyIntoTargetFundInput> | TradeCreateWithoutBuyIntoTargetFundInput[] | TradeUncheckedCreateWithoutBuyIntoTargetFundInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutBuyIntoTargetFundInput | TradeCreateOrConnectWithoutBuyIntoTargetFundInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutBuyIntoTargetFundInput | TradeUpsertWithWhereUniqueWithoutBuyIntoTargetFundInput[]
    createMany?: TradeCreateManyBuyIntoTargetFundInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutBuyIntoTargetFundInput | TradeUpdateWithWhereUniqueWithoutBuyIntoTargetFundInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutBuyIntoTargetFundInput | TradeUpdateManyWithWhereWithoutBuyIntoTargetFundInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type PortfolioHoldingUncheckedUpdateManyWithoutFundNestedInput = {
    create?: XOR<PortfolioHoldingCreateWithoutFundInput, PortfolioHoldingUncheckedCreateWithoutFundInput> | PortfolioHoldingCreateWithoutFundInput[] | PortfolioHoldingUncheckedCreateWithoutFundInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutFundInput | PortfolioHoldingCreateOrConnectWithoutFundInput[]
    upsert?: PortfolioHoldingUpsertWithWhereUniqueWithoutFundInput | PortfolioHoldingUpsertWithWhereUniqueWithoutFundInput[]
    createMany?: PortfolioHoldingCreateManyFundInputEnvelope
    set?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    disconnect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    delete?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    update?: PortfolioHoldingUpdateWithWhereUniqueWithoutFundInput | PortfolioHoldingUpdateWithWhereUniqueWithoutFundInput[]
    updateMany?: PortfolioHoldingUpdateManyWithWhereWithoutFundInput | PortfolioHoldingUpdateManyWithWhereWithoutFundInput[]
    deleteMany?: PortfolioHoldingScalarWhereInput | PortfolioHoldingScalarWhereInput[]
  }

  export type HedgeFundUncheckedUpdateManyWithoutFundNestedInput = {
    create?: XOR<HedgeFundCreateWithoutFundInput, HedgeFundUncheckedCreateWithoutFundInput> | HedgeFundCreateWithoutFundInput[] | HedgeFundUncheckedCreateWithoutFundInput[]
    connectOrCreate?: HedgeFundCreateOrConnectWithoutFundInput | HedgeFundCreateOrConnectWithoutFundInput[]
    upsert?: HedgeFundUpsertWithWhereUniqueWithoutFundInput | HedgeFundUpsertWithWhereUniqueWithoutFundInput[]
    createMany?: HedgeFundCreateManyFundInputEnvelope
    set?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    disconnect?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    delete?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    connect?: HedgeFundWhereUniqueInput | HedgeFundWhereUniqueInput[]
    update?: HedgeFundUpdateWithWhereUniqueWithoutFundInput | HedgeFundUpdateWithWhereUniqueWithoutFundInput[]
    updateMany?: HedgeFundUpdateManyWithWhereWithoutFundInput | HedgeFundUpdateManyWithWhereWithoutFundInput[]
    deleteMany?: HedgeFundScalarWhereInput | HedgeFundScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPortfoliosInput = {
    create?: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfoliosInput
    connect?: UserWhereUniqueInput
  }

  export type PortfolioHoldingCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioHoldingCreateWithoutPortfolioInput, PortfolioHoldingUncheckedCreateWithoutPortfolioInput> | PortfolioHoldingCreateWithoutPortfolioInput[] | PortfolioHoldingUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutPortfolioInput | PortfolioHoldingCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioHoldingCreateManyPortfolioInputEnvelope
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
  }

  export type TradeCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<TradeCreateWithoutPortfolioInput, TradeUncheckedCreateWithoutPortfolioInput> | TradeCreateWithoutPortfolioInput[] | TradeUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutPortfolioInput | TradeCreateOrConnectWithoutPortfolioInput[]
    createMany?: TradeCreateManyPortfolioInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type PortfolioHoldingUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioHoldingCreateWithoutPortfolioInput, PortfolioHoldingUncheckedCreateWithoutPortfolioInput> | PortfolioHoldingCreateWithoutPortfolioInput[] | PortfolioHoldingUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutPortfolioInput | PortfolioHoldingCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioHoldingCreateManyPortfolioInputEnvelope
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<TradeCreateWithoutPortfolioInput, TradeUncheckedCreateWithoutPortfolioInput> | TradeCreateWithoutPortfolioInput[] | TradeUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutPortfolioInput | TradeCreateOrConnectWithoutPortfolioInput[]
    createMany?: TradeCreateManyPortfolioInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPortfoliosNestedInput = {
    create?: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortfoliosInput
    upsert?: UserUpsertWithoutPortfoliosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPortfoliosInput, UserUpdateWithoutPortfoliosInput>, UserUncheckedUpdateWithoutPortfoliosInput>
  }

  export type PortfolioHoldingUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioHoldingCreateWithoutPortfolioInput, PortfolioHoldingUncheckedCreateWithoutPortfolioInput> | PortfolioHoldingCreateWithoutPortfolioInput[] | PortfolioHoldingUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutPortfolioInput | PortfolioHoldingCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioHoldingUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioHoldingUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioHoldingCreateManyPortfolioInputEnvelope
    set?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    disconnect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    delete?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    update?: PortfolioHoldingUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioHoldingUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioHoldingUpdateManyWithWhereWithoutPortfolioInput | PortfolioHoldingUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioHoldingScalarWhereInput | PortfolioHoldingScalarWhereInput[]
  }

  export type TradeUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<TradeCreateWithoutPortfolioInput, TradeUncheckedCreateWithoutPortfolioInput> | TradeCreateWithoutPortfolioInput[] | TradeUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutPortfolioInput | TradeCreateOrConnectWithoutPortfolioInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutPortfolioInput | TradeUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: TradeCreateManyPortfolioInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutPortfolioInput | TradeUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutPortfolioInput | TradeUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type PortfolioHoldingUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioHoldingCreateWithoutPortfolioInput, PortfolioHoldingUncheckedCreateWithoutPortfolioInput> | PortfolioHoldingCreateWithoutPortfolioInput[] | PortfolioHoldingUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioHoldingCreateOrConnectWithoutPortfolioInput | PortfolioHoldingCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioHoldingUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioHoldingUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioHoldingCreateManyPortfolioInputEnvelope
    set?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    disconnect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    delete?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    connect?: PortfolioHoldingWhereUniqueInput | PortfolioHoldingWhereUniqueInput[]
    update?: PortfolioHoldingUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioHoldingUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioHoldingUpdateManyWithWhereWithoutPortfolioInput | PortfolioHoldingUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioHoldingScalarWhereInput | PortfolioHoldingScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<TradeCreateWithoutPortfolioInput, TradeUncheckedCreateWithoutPortfolioInput> | TradeCreateWithoutPortfolioInput[] | TradeUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutPortfolioInput | TradeCreateOrConnectWithoutPortfolioInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutPortfolioInput | TradeUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: TradeCreateManyPortfolioInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutPortfolioInput | TradeUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutPortfolioInput | TradeUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type PortfolioCreateNestedOneWithoutHoldingsInput = {
    create?: XOR<PortfolioCreateWithoutHoldingsInput, PortfolioUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutHoldingsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type FundCreateNestedOneWithoutHoldingsInput = {
    create?: XOR<FundCreateWithoutHoldingsInput, FundUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: FundCreateOrConnectWithoutHoldingsInput
    connect?: FundWhereUniqueInput
  }

  export type PortfolioUpdateOneRequiredWithoutHoldingsNestedInput = {
    create?: XOR<PortfolioCreateWithoutHoldingsInput, PortfolioUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutHoldingsInput
    upsert?: PortfolioUpsertWithoutHoldingsInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutHoldingsInput, PortfolioUpdateWithoutHoldingsInput>, PortfolioUncheckedUpdateWithoutHoldingsInput>
  }

  export type FundUpdateOneRequiredWithoutHoldingsNestedInput = {
    create?: XOR<FundCreateWithoutHoldingsInput, FundUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: FundCreateOrConnectWithoutHoldingsInput
    upsert?: FundUpsertWithoutHoldingsInput
    connect?: FundWhereUniqueInput
    update?: XOR<XOR<FundUpdateToOneWithWhereWithoutHoldingsInput, FundUpdateWithoutHoldingsInput>, FundUncheckedUpdateWithoutHoldingsInput>
  }

  export type FundCreateNestedOneWithoutHedgeFundsInput = {
    create?: XOR<FundCreateWithoutHedgeFundsInput, FundUncheckedCreateWithoutHedgeFundsInput>
    connectOrCreate?: FundCreateOrConnectWithoutHedgeFundsInput
    connect?: FundWhereUniqueInput
  }

  export type FundUpdateOneRequiredWithoutHedgeFundsNestedInput = {
    create?: XOR<FundCreateWithoutHedgeFundsInput, FundUncheckedCreateWithoutHedgeFundsInput>
    connectOrCreate?: FundCreateOrConnectWithoutHedgeFundsInput
    upsert?: FundUpsertWithoutHedgeFundsInput
    connect?: FundWhereUniqueInput
    update?: XOR<XOR<FundUpdateToOneWithWhereWithoutHedgeFundsInput, FundUpdateWithoutHedgeFundsInput>, FundUncheckedUpdateWithoutHedgeFundsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGroupsFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsFilter<$PrismaModel> | $Enums.Groups
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGroupsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Groups | EnumGroupsFieldRefInput<$PrismaModel>
    in?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Groups[] | ListEnumGroupsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupsWithAggregatesFilter<$PrismaModel> | $Enums.Groups
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupsFilter<$PrismaModel>
    _max?: NestedEnumGroupsFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumHardwareTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesFilter<$PrismaModel> | $Enums.HardwareTypes
  }

  export type NestedEnumHardwareTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HardwareTypes | EnumHardwareTypesFieldRefInput<$PrismaModel>
    in?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.HardwareTypes[] | ListEnumHardwareTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumHardwareTypesWithAggregatesFilter<$PrismaModel> | $Enums.HardwareTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHardwareTypesFilter<$PrismaModel>
    _max?: NestedEnumHardwareTypesFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumInstructionNamedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstructionNamedType | EnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstructionNamedTypeFilter<$PrismaModel> | $Enums.InstructionNamedType
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumInstructionNamedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstructionNamedType | EnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstructionNamedType[] | ListEnumInstructionNamedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstructionNamedTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstructionNamedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstructionNamedTypeFilter<$PrismaModel>
    _max?: NestedEnumInstructionNamedTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AccountBookCreateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    game: GameCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutUserInput = {
    id?: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateOrConnectWithoutUserInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput>
  }

  export type AccountBookCreateManyUserInputEnvelope = {
    data: AccountBookCreateManyUserInput | AccountBookCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressBookCreateWithoutUserInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAddressBookInput
    game: GameCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateWithoutUserInput = {
    id?: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookCreateOrConnectWithoutUserInput = {
    where: AddressBookWhereUniqueInput
    create: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput>
  }

  export type AddressBookCreateManyUserInputEnvelope = {
    data: AddressBookCreateManyUserInput | AddressBookCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComputerCreateWithoutUserInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutUserInput = {
    id?: string
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutUserInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput>
  }

  export type ComputerCreateManyUserInputEnvelope = {
    data: ComputerCreateManyUserInput | ComputerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DNSCreateWithoutUserInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutDnsInput
    game: GameCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateWithoutUserInput = {
    id?: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSCreateOrConnectWithoutUserInput = {
    where: DNSWhereUniqueInput
    create: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput>
  }

  export type DNSCreateManyUserInputEnvelope = {
    data: DNSCreateManyUserInput | DNSCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogsCreateWithoutUserInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutLogsInput
    game: GameCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateWithoutUserInput = {
    id?: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsCreateOrConnectWithoutUserInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type LogsCreateManyUserInputEnvelope = {
    data: LogsCreateManyUserInput | LogsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemoryCreateWithoutUserInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
    computer: ComputerCreateNestedOneWithoutMemoryInput
    game: GameCreateNestedOneWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryCreateOrConnectWithoutUserInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput>
  }

  export type MemoryCreateManyUserInputEnvelope = {
    data: MemoryCreateManyUserInput | MemoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutUserInput = {
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type NotificationsCreateOrConnectWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsCreateManyUserInputEnvelope = {
    data: NotificationsCreateManyUserInput | NotificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCreateWithoutUserInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutProcessInput
    game: GameCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutUserInput = {
    id?: string
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateOrConnectWithoutUserInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessCreateManyUserInputEnvelope = {
    data: ProcessCreateManyUserInput | ProcessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileCreateManyUserInputEnvelope = {
    data: ProfileCreateManyUserInput | ProfileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareCreateWithoutUserInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutSoftwareInput
    game: GameCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateWithoutUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateOrConnectWithoutUserInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput>
  }

  export type SoftwareCreateManyUserInputEnvelope = {
    data: SoftwareCreateManyUserInput | SoftwareCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserQuestsCreateWithoutUserInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    game: GameCreateNestedOneWithoutUserQuestsInput
    quest: QuestsCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateWithoutUserInput = {
    id?: string
    questsId: string
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsCreateOrConnectWithoutUserInput = {
    where: UserQuestsWhereUniqueInput
    create: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput>
  }

  export type UserQuestsCreateManyUserInputEnvelope = {
    data: UserQuestsCreateManyUserInput | UserQuestsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioCreateWithoutUserInput = {
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    holdings?: PortfolioHoldingCreateNestedManyWithoutPortfolioInput
    trades?: TradeCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    holdings?: PortfolioHoldingUncheckedCreateNestedManyWithoutPortfolioInput
    trades?: TradeUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutUserInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutUserInput, PortfolioUncheckedCreateWithoutUserInput>
  }

  export type PortfolioCreateManyUserInputEnvelope = {
    data: PortfolioCreateManyUserInput | PortfolioCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TradeCreateWithoutUserInput = {
    marketId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    instructionType: $Enums.InstructionNamedType
    buyIntoTargetFund: FundCreateNestedOneWithoutTradesInput
    portfolio: PortfolioCreateNestedOneWithoutTradesInput
  }

  export type TradeUncheckedCreateWithoutUserInput = {
    id?: number
    marketId: number
    portfolioId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    buyIntoTargetFundid: number
    instructionType: $Enums.InstructionNamedType
  }

  export type TradeCreateOrConnectWithoutUserInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput>
  }

  export type TradeCreateManyUserInputEnvelope = {
    data: TradeCreateManyUserInput | TradeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FundCreateWithoutFundManagerInput = {
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: TradeCreateNestedManyWithoutBuyIntoTargetFundInput
    holdings?: PortfolioHoldingCreateNestedManyWithoutFundInput
    hedgeFunds?: HedgeFundCreateNestedManyWithoutFundInput
  }

  export type FundUncheckedCreateWithoutFundManagerInput = {
    id?: number
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: TradeUncheckedCreateNestedManyWithoutBuyIntoTargetFundInput
    holdings?: PortfolioHoldingUncheckedCreateNestedManyWithoutFundInput
    hedgeFunds?: HedgeFundUncheckedCreateNestedManyWithoutFundInput
  }

  export type FundCreateOrConnectWithoutFundManagerInput = {
    where: FundWhereUniqueInput
    create: XOR<FundCreateWithoutFundManagerInput, FundUncheckedCreateWithoutFundManagerInput>
  }

  export type FundCreateManyFundManagerInputEnvelope = {
    data: FundCreateManyFundManagerInput | FundCreateManyFundManagerInput[]
    skipDuplicates?: boolean
  }

  export type AccountBookUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutUserInput, AccountBookUncheckedUpdateWithoutUserInput>
    create: XOR<AccountBookCreateWithoutUserInput, AccountBookUncheckedCreateWithoutUserInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutUserInput, AccountBookUncheckedUpdateWithoutUserInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutUserInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountBookScalarWhereInput = {
    AND?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
    OR?: AccountBookScalarWhereInput[]
    NOT?: AccountBookScalarWhereInput | AccountBookScalarWhereInput[]
    id?: IntFilter<"AccountBook"> | number
    userId?: IntFilter<"AccountBook"> | number
    computerId?: StringFilter<"AccountBook"> | string
    memoryId?: StringFilter<"AccountBook"> | string
    data?: JsonFilter<"AccountBook">
    gameId?: StringFilter<"AccountBook"> | string
  }

  export type AddressBookUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressBookWhereUniqueInput
    update: XOR<AddressBookUpdateWithoutUserInput, AddressBookUncheckedUpdateWithoutUserInput>
    create: XOR<AddressBookCreateWithoutUserInput, AddressBookUncheckedCreateWithoutUserInput>
  }

  export type AddressBookUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressBookWhereUniqueInput
    data: XOR<AddressBookUpdateWithoutUserInput, AddressBookUncheckedUpdateWithoutUserInput>
  }

  export type AddressBookUpdateManyWithWhereWithoutUserInput = {
    where: AddressBookScalarWhereInput
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressBookScalarWhereInput = {
    AND?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
    OR?: AddressBookScalarWhereInput[]
    NOT?: AddressBookScalarWhereInput | AddressBookScalarWhereInput[]
    id?: IntFilter<"AddressBook"> | number
    userId?: IntFilter<"AddressBook"> | number
    access?: EnumAccessLevelFilter<"AddressBook"> | $Enums.AccessLevel
    computerId?: StringFilter<"AddressBook"> | string
    ip?: StringFilter<"AddressBook"> | string
    data?: JsonFilter<"AddressBook">
    gameId?: StringFilter<"AddressBook"> | string
  }

  export type ComputerUpsertWithWhereUniqueWithoutUserInput = {
    where: ComputerWhereUniqueInput
    update: XOR<ComputerUpdateWithoutUserInput, ComputerUncheckedUpdateWithoutUserInput>
    create: XOR<ComputerCreateWithoutUserInput, ComputerUncheckedCreateWithoutUserInput>
  }

  export type ComputerUpdateWithWhereUniqueWithoutUserInput = {
    where: ComputerWhereUniqueInput
    data: XOR<ComputerUpdateWithoutUserInput, ComputerUncheckedUpdateWithoutUserInput>
  }

  export type ComputerUpdateManyWithWhereWithoutUserInput = {
    where: ComputerScalarWhereInput
    data: XOR<ComputerUpdateManyMutationInput, ComputerUncheckedUpdateManyWithoutUserInput>
  }

  export type ComputerScalarWhereInput = {
    AND?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
    OR?: ComputerScalarWhereInput[]
    NOT?: ComputerScalarWhereInput | ComputerScalarWhereInput[]
    id?: StringFilter<"Computer"> | string
    userId?: IntFilter<"Computer"> | number
    type?: StringFilter<"Computer"> | string
    gameId?: StringFilter<"Computer"> | string
    ip?: StringFilter<"Computer"> | string
    data?: JsonFilter<"Computer">
    created?: DateTimeFilter<"Computer"> | Date | string
    updated?: DateTimeFilter<"Computer"> | Date | string
  }

  export type DNSUpsertWithWhereUniqueWithoutUserInput = {
    where: DNSWhereUniqueInput
    update: XOR<DNSUpdateWithoutUserInput, DNSUncheckedUpdateWithoutUserInput>
    create: XOR<DNSCreateWithoutUserInput, DNSUncheckedCreateWithoutUserInput>
  }

  export type DNSUpdateWithWhereUniqueWithoutUserInput = {
    where: DNSWhereUniqueInput
    data: XOR<DNSUpdateWithoutUserInput, DNSUncheckedUpdateWithoutUserInput>
  }

  export type DNSUpdateManyWithWhereWithoutUserInput = {
    where: DNSScalarWhereInput
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyWithoutUserInput>
  }

  export type DNSScalarWhereInput = {
    AND?: DNSScalarWhereInput | DNSScalarWhereInput[]
    OR?: DNSScalarWhereInput[]
    NOT?: DNSScalarWhereInput | DNSScalarWhereInput[]
    id?: IntFilter<"DNS"> | number
    userId?: IntFilter<"DNS"> | number
    computerId?: StringFilter<"DNS"> | string
    gameId?: StringFilter<"DNS"> | string
    website?: StringFilter<"DNS"> | string
    tags?: StringFilter<"DNS"> | string
    description?: StringFilter<"DNS"> | string
    updated?: DateTimeFilter<"DNS"> | Date | string
    created?: DateTimeFilter<"DNS"> | Date | string
  }

  export type LogsUpsertWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
  }

  export type LogsUpdateManyWithWhereWithoutUserInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutUserInput>
  }

  export type LogsScalarWhereInput = {
    AND?: LogsScalarWhereInput | LogsScalarWhereInput[]
    OR?: LogsScalarWhereInput[]
    NOT?: LogsScalarWhereInput | LogsScalarWhereInput[]
    id?: IntFilter<"Logs"> | number
    userId?: IntFilter<"Logs"> | number
    computerId?: StringFilter<"Logs"> | string
    senderId?: StringFilter<"Logs"> | string
    senderIp?: StringFilter<"Logs"> | string
    gameId?: StringFilter<"Logs"> | string
    message?: StringFilter<"Logs"> | string
    created?: DateTimeFilter<"Logs"> | Date | string
  }

  export type MemoryUpsertWithWhereUniqueWithoutUserInput = {
    where: MemoryWhereUniqueInput
    update: XOR<MemoryUpdateWithoutUserInput, MemoryUncheckedUpdateWithoutUserInput>
    create: XOR<MemoryCreateWithoutUserInput, MemoryUncheckedCreateWithoutUserInput>
  }

  export type MemoryUpdateWithWhereUniqueWithoutUserInput = {
    where: MemoryWhereUniqueInput
    data: XOR<MemoryUpdateWithoutUserInput, MemoryUncheckedUpdateWithoutUserInput>
  }

  export type MemoryUpdateManyWithWhereWithoutUserInput = {
    where: MemoryScalarWhereInput
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyWithoutUserInput>
  }

  export type MemoryScalarWhereInput = {
    AND?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
    OR?: MemoryScalarWhereInput[]
    NOT?: MemoryScalarWhereInput | MemoryScalarWhereInput[]
    id?: StringFilter<"Memory"> | string
    computerId?: StringFilter<"Memory"> | string
    gameId?: StringFilter<"Memory"> | string
    userId?: IntFilter<"Memory"> | number
    type?: StringFilter<"Memory"> | string
    key?: StringFilter<"Memory"> | string
    value?: FloatNullableFilter<"Memory"> | number | null
    data?: JsonFilter<"Memory">
  }

  export type NotificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutUserInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: IntFilter<"Notifications"> | number
    userId?: IntFilter<"Notifications"> | number
    type?: StringFilter<"Notifications"> | string
    content?: JsonFilter<"Notifications">
    read?: BoolFilter<"Notifications"> | boolean
  }

  export type ProcessUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
  }

  export type ProcessUpdateManyWithWhereWithoutUserInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessScalarWhereInput = {
    AND?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    OR?: ProcessScalarWhereInput[]
    NOT?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    id?: StringFilter<"Process"> | string
    userId?: IntFilter<"Process"> | number
    computerId?: StringFilter<"Process"> | string
    ip?: StringNullableFilter<"Process"> | string | null
    gameId?: StringFilter<"Process"> | string
    type?: StringFilter<"Process"> | string
    started?: DateTimeFilter<"Process"> | Date | string
    completion?: DateTimeFilter<"Process"> | Date | string
    data?: JsonFilter<"Process">
  }

  export type ProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateManyWithWhereWithoutUserInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: IntFilter<"Profile"> | number
    userId?: IntFilter<"Profile"> | number
    gameId?: StringFilter<"Profile"> | string
    data?: JsonFilter<"Profile">
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    lastAction?: DateTimeFilter<"Session"> | Date | string
    created?: DateTimeFilter<"Session"> | Date | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type SoftwareUpsertWithWhereUniqueWithoutUserInput = {
    where: SoftwareWhereUniqueInput
    update: XOR<SoftwareUpdateWithoutUserInput, SoftwareUncheckedUpdateWithoutUserInput>
    create: XOR<SoftwareCreateWithoutUserInput, SoftwareUncheckedCreateWithoutUserInput>
  }

  export type SoftwareUpdateWithWhereUniqueWithoutUserInput = {
    where: SoftwareWhereUniqueInput
    data: XOR<SoftwareUpdateWithoutUserInput, SoftwareUncheckedUpdateWithoutUserInput>
  }

  export type SoftwareUpdateManyWithWhereWithoutUserInput = {
    where: SoftwareScalarWhereInput
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyWithoutUserInput>
  }

  export type SoftwareScalarWhereInput = {
    AND?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
    OR?: SoftwareScalarWhereInput[]
    NOT?: SoftwareScalarWhereInput | SoftwareScalarWhereInput[]
    id?: StringFilter<"Software"> | string
    userId?: IntFilter<"Software"> | number
    computerId?: StringFilter<"Software"> | string
    gameId?: StringFilter<"Software"> | string
    type?: StringFilter<"Software"> | string
    level?: FloatFilter<"Software"> | number
    size?: FloatFilter<"Software"> | number
    opacity?: FloatFilter<"Software"> | number
    installed?: BoolFilter<"Software"> | boolean
    executed?: DateTimeFilter<"Software"> | Date | string
    created?: DateTimeFilter<"Software"> | Date | string
    updated?: DateTimeFilter<"Software"> | Date | string
    data?: JsonFilter<"Software">
  }

  export type UserQuestsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserQuestsWhereUniqueInput
    update: XOR<UserQuestsUpdateWithoutUserInput, UserQuestsUncheckedUpdateWithoutUserInput>
    create: XOR<UserQuestsCreateWithoutUserInput, UserQuestsUncheckedCreateWithoutUserInput>
  }

  export type UserQuestsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserQuestsWhereUniqueInput
    data: XOR<UserQuestsUpdateWithoutUserInput, UserQuestsUncheckedUpdateWithoutUserInput>
  }

  export type UserQuestsUpdateManyWithWhereWithoutUserInput = {
    where: UserQuestsScalarWhereInput
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserQuestsScalarWhereInput = {
    AND?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
    OR?: UserQuestsScalarWhereInput[]
    NOT?: UserQuestsScalarWhereInput | UserQuestsScalarWhereInput[]
    id?: StringFilter<"UserQuests"> | string
    questsId?: StringFilter<"UserQuests"> | string
    userId?: IntFilter<"UserQuests"> | number
    gameId?: StringFilter<"UserQuests"> | string
    completed?: BoolFilter<"UserQuests"> | boolean
    created?: DateTimeFilter<"UserQuests"> | Date | string
    updated?: DateTimeFilter<"UserQuests"> | Date | string
  }

  export type PortfolioUpsertWithWhereUniqueWithoutUserInput = {
    where: PortfolioWhereUniqueInput
    update: XOR<PortfolioUpdateWithoutUserInput, PortfolioUncheckedUpdateWithoutUserInput>
    create: XOR<PortfolioCreateWithoutUserInput, PortfolioUncheckedCreateWithoutUserInput>
  }

  export type PortfolioUpdateWithWhereUniqueWithoutUserInput = {
    where: PortfolioWhereUniqueInput
    data: XOR<PortfolioUpdateWithoutUserInput, PortfolioUncheckedUpdateWithoutUserInput>
  }

  export type PortfolioUpdateManyWithWhereWithoutUserInput = {
    where: PortfolioScalarWhereInput
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyWithoutUserInput>
  }

  export type PortfolioScalarWhereInput = {
    AND?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    OR?: PortfolioScalarWhereInput[]
    NOT?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    id?: IntFilter<"Portfolio"> | number
    userId?: IntFilter<"Portfolio"> | number
    name?: StringFilter<"Portfolio"> | string
    totalValue?: BigIntFilter<"Portfolio"> | bigint | number
    isActive?: BoolFilter<"Portfolio"> | boolean
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
  }

  export type TradeUpsertWithWhereUniqueWithoutUserInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutUserInput, TradeUncheckedUpdateWithoutUserInput>
    create: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutUserInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutUserInput, TradeUncheckedUpdateWithoutUserInput>
  }

  export type TradeUpdateManyWithWhereWithoutUserInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutUserInput>
  }

  export type TradeScalarWhereInput = {
    AND?: TradeScalarWhereInput | TradeScalarWhereInput[]
    OR?: TradeScalarWhereInput[]
    NOT?: TradeScalarWhereInput | TradeScalarWhereInput[]
    id?: IntFilter<"Trade"> | number
    userId?: IntFilter<"Trade"> | number
    marketId?: IntFilter<"Trade"> | number
    portfolioId?: IntFilter<"Trade"> | number
    type?: StringFilter<"Trade"> | string
    quantity?: IntFilter<"Trade"> | number
    price?: BigIntFilter<"Trade"> | bigint | number
    totalValue?: IntFilter<"Trade"> | number
    status?: StringFilter<"Trade"> | string
    executedAt?: DateTimeFilter<"Trade"> | Date | string
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    buyIntoTargetFundid?: IntFilter<"Trade"> | number
    instructionType?: EnumInstructionNamedTypeFilter<"Trade"> | $Enums.InstructionNamedType
  }

  export type FundUpsertWithWhereUniqueWithoutFundManagerInput = {
    where: FundWhereUniqueInput
    update: XOR<FundUpdateWithoutFundManagerInput, FundUncheckedUpdateWithoutFundManagerInput>
    create: XOR<FundCreateWithoutFundManagerInput, FundUncheckedCreateWithoutFundManagerInput>
  }

  export type FundUpdateWithWhereUniqueWithoutFundManagerInput = {
    where: FundWhereUniqueInput
    data: XOR<FundUpdateWithoutFundManagerInput, FundUncheckedUpdateWithoutFundManagerInput>
  }

  export type FundUpdateManyWithWhereWithoutFundManagerInput = {
    where: FundScalarWhereInput
    data: XOR<FundUpdateManyMutationInput, FundUncheckedUpdateManyWithoutFundManagerInput>
  }

  export type FundScalarWhereInput = {
    AND?: FundScalarWhereInput | FundScalarWhereInput[]
    OR?: FundScalarWhereInput[]
    NOT?: FundScalarWhereInput | FundScalarWhereInput[]
    id?: IntFilter<"Fund"> | number
    fundManagerId?: IntFilter<"Fund"> | number
    name?: StringFilter<"Fund"> | string
    minimumInvestmentAmount?: BigIntFilter<"Fund"> | bigint | number
    totalFundCharge?: DecimalFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFilter<"Fund"> | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFilter<"Fund"> | bigint | number
    isActive?: BoolFilter<"Fund"> | boolean
    maxInvestors?: IntFilter<"Fund"> | number
    createdAt?: DateTimeFilter<"Fund"> | Date | string
    updatedAt?: DateTimeFilter<"Fund"> | Date | string
  }

  export type AccountBookCreateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
    user: UserCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookCreateOrConnectWithoutGameInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput>
  }

  export type AccountBookCreateManyGameInputEnvelope = {
    data: AccountBookCreateManyGameInput | AccountBookCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type AddressBookCreateWithoutGameInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAddressBookInput
    user: UserCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookCreateOrConnectWithoutGameInput = {
    where: AddressBookWhereUniqueInput
    create: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput>
  }

  export type AddressBookCreateManyGameInputEnvelope = {
    data: AddressBookCreateManyGameInput | AddressBookCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type ComputerCreateWithoutGameInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutGameInput = {
    id?: string
    userId: number
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutGameInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput>
  }

  export type ComputerCreateManyGameInputEnvelope = {
    data: ComputerCreateManyGameInput | ComputerCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type DNSCreateWithoutGameInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutDnsInput
    user: UserCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    computerId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSCreateOrConnectWithoutGameInput = {
    where: DNSWhereUniqueInput
    create: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput>
  }

  export type DNSCreateManyGameInputEnvelope = {
    data: DNSCreateManyGameInput | DNSCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type HardwareCreateWithoutGameInput = {
    type: $Enums.HardwareTypes
    strength: number
    computer: ComputerCreateNestedOneWithoutHardwareInput
  }

  export type HardwareUncheckedCreateWithoutGameInput = {
    id?: number
    computerId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareCreateOrConnectWithoutGameInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput>
  }

  export type HardwareCreateManyGameInputEnvelope = {
    data: HardwareCreateManyGameInput | HardwareCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type LogsCreateWithoutGameInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    computer: ComputerCreateNestedOneWithoutLogsInput
    user: UserCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
  }

  export type LogsCreateOrConnectWithoutGameInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput>
  }

  export type LogsCreateManyGameInputEnvelope = {
    data: LogsCreateManyGameInput | LogsCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type MemoryCreateWithoutGameInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
    computer: ComputerCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutGameInput = {
    id?: string
    computerId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryCreateOrConnectWithoutGameInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput>
  }

  export type MemoryCreateManyGameInputEnvelope = {
    data: MemoryCreateManyGameInput | MemoryCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCreateWithoutGameInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutProcessInput
    user: UserCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutGameInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateOrConnectWithoutGameInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput>
  }

  export type ProcessCreateManyGameInputEnvelope = {
    data: ProcessCreateManyGameInput | ProcessCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutGameInput = {
    id?: number
    userId: number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateOrConnectWithoutGameInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput>
  }

  export type ProfileCreateManyGameInputEnvelope = {
    data: ProfileCreateManyGameInput | ProfileCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type QuestsCreateWithoutGameInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    userQuests?: UserQuestsCreateNestedManyWithoutQuestInput
  }

  export type QuestsUncheckedCreateWithoutGameInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestsCreateOrConnectWithoutGameInput = {
    where: QuestsWhereUniqueInput
    create: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput>
  }

  export type QuestsCreateManyGameInputEnvelope = {
    data: QuestsCreateManyGameInput | QuestsCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareCreateWithoutGameInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutSoftwareInput
    user: UserCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateWithoutGameInput = {
    id?: string
    userId: number
    computerId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateOrConnectWithoutGameInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput>
  }

  export type SoftwareCreateManyGameInputEnvelope = {
    data: SoftwareCreateManyGameInput | SoftwareCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type UserQuestsCreateWithoutGameInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    quest: QuestsCreateNestedOneWithoutUserQuestsInput
    user: UserCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateWithoutGameInput = {
    id?: string
    questsId: string
    userId: number
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsCreateOrConnectWithoutGameInput = {
    where: UserQuestsWhereUniqueInput
    create: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput>
  }

  export type UserQuestsCreateManyGameInputEnvelope = {
    data: UserQuestsCreateManyGameInput | UserQuestsCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type AccountBookUpsertWithWhereUniqueWithoutGameInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutGameInput, AccountBookUncheckedUpdateWithoutGameInput>
    create: XOR<AccountBookCreateWithoutGameInput, AccountBookUncheckedCreateWithoutGameInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutGameInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutGameInput, AccountBookUncheckedUpdateWithoutGameInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutGameInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutGameInput>
  }

  export type AddressBookUpsertWithWhereUniqueWithoutGameInput = {
    where: AddressBookWhereUniqueInput
    update: XOR<AddressBookUpdateWithoutGameInput, AddressBookUncheckedUpdateWithoutGameInput>
    create: XOR<AddressBookCreateWithoutGameInput, AddressBookUncheckedCreateWithoutGameInput>
  }

  export type AddressBookUpdateWithWhereUniqueWithoutGameInput = {
    where: AddressBookWhereUniqueInput
    data: XOR<AddressBookUpdateWithoutGameInput, AddressBookUncheckedUpdateWithoutGameInput>
  }

  export type AddressBookUpdateManyWithWhereWithoutGameInput = {
    where: AddressBookScalarWhereInput
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyWithoutGameInput>
  }

  export type ComputerUpsertWithWhereUniqueWithoutGameInput = {
    where: ComputerWhereUniqueInput
    update: XOR<ComputerUpdateWithoutGameInput, ComputerUncheckedUpdateWithoutGameInput>
    create: XOR<ComputerCreateWithoutGameInput, ComputerUncheckedCreateWithoutGameInput>
  }

  export type ComputerUpdateWithWhereUniqueWithoutGameInput = {
    where: ComputerWhereUniqueInput
    data: XOR<ComputerUpdateWithoutGameInput, ComputerUncheckedUpdateWithoutGameInput>
  }

  export type ComputerUpdateManyWithWhereWithoutGameInput = {
    where: ComputerScalarWhereInput
    data: XOR<ComputerUpdateManyMutationInput, ComputerUncheckedUpdateManyWithoutGameInput>
  }

  export type DNSUpsertWithWhereUniqueWithoutGameInput = {
    where: DNSWhereUniqueInput
    update: XOR<DNSUpdateWithoutGameInput, DNSUncheckedUpdateWithoutGameInput>
    create: XOR<DNSCreateWithoutGameInput, DNSUncheckedCreateWithoutGameInput>
  }

  export type DNSUpdateWithWhereUniqueWithoutGameInput = {
    where: DNSWhereUniqueInput
    data: XOR<DNSUpdateWithoutGameInput, DNSUncheckedUpdateWithoutGameInput>
  }

  export type DNSUpdateManyWithWhereWithoutGameInput = {
    where: DNSScalarWhereInput
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyWithoutGameInput>
  }

  export type HardwareUpsertWithWhereUniqueWithoutGameInput = {
    where: HardwareWhereUniqueInput
    update: XOR<HardwareUpdateWithoutGameInput, HardwareUncheckedUpdateWithoutGameInput>
    create: XOR<HardwareCreateWithoutGameInput, HardwareUncheckedCreateWithoutGameInput>
  }

  export type HardwareUpdateWithWhereUniqueWithoutGameInput = {
    where: HardwareWhereUniqueInput
    data: XOR<HardwareUpdateWithoutGameInput, HardwareUncheckedUpdateWithoutGameInput>
  }

  export type HardwareUpdateManyWithWhereWithoutGameInput = {
    where: HardwareScalarWhereInput
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyWithoutGameInput>
  }

  export type HardwareScalarWhereInput = {
    AND?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
    OR?: HardwareScalarWhereInput[]
    NOT?: HardwareScalarWhereInput | HardwareScalarWhereInput[]
    id?: IntFilter<"Hardware"> | number
    computerId?: StringFilter<"Hardware"> | string
    gameId?: StringFilter<"Hardware"> | string
    type?: EnumHardwareTypesFilter<"Hardware"> | $Enums.HardwareTypes
    strength?: FloatFilter<"Hardware"> | number
  }

  export type LogsUpsertWithWhereUniqueWithoutGameInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutGameInput, LogsUncheckedUpdateWithoutGameInput>
    create: XOR<LogsCreateWithoutGameInput, LogsUncheckedCreateWithoutGameInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutGameInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutGameInput, LogsUncheckedUpdateWithoutGameInput>
  }

  export type LogsUpdateManyWithWhereWithoutGameInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutGameInput>
  }

  export type MemoryUpsertWithWhereUniqueWithoutGameInput = {
    where: MemoryWhereUniqueInput
    update: XOR<MemoryUpdateWithoutGameInput, MemoryUncheckedUpdateWithoutGameInput>
    create: XOR<MemoryCreateWithoutGameInput, MemoryUncheckedCreateWithoutGameInput>
  }

  export type MemoryUpdateWithWhereUniqueWithoutGameInput = {
    where: MemoryWhereUniqueInput
    data: XOR<MemoryUpdateWithoutGameInput, MemoryUncheckedUpdateWithoutGameInput>
  }

  export type MemoryUpdateManyWithWhereWithoutGameInput = {
    where: MemoryScalarWhereInput
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyWithoutGameInput>
  }

  export type ProcessUpsertWithWhereUniqueWithoutGameInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutGameInput, ProcessUncheckedUpdateWithoutGameInput>
    create: XOR<ProcessCreateWithoutGameInput, ProcessUncheckedCreateWithoutGameInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutGameInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutGameInput, ProcessUncheckedUpdateWithoutGameInput>
  }

  export type ProcessUpdateManyWithWhereWithoutGameInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutGameInput>
  }

  export type ProfileUpsertWithWhereUniqueWithoutGameInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutGameInput, ProfileUncheckedUpdateWithoutGameInput>
    create: XOR<ProfileCreateWithoutGameInput, ProfileUncheckedCreateWithoutGameInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutGameInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutGameInput, ProfileUncheckedUpdateWithoutGameInput>
  }

  export type ProfileUpdateManyWithWhereWithoutGameInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutGameInput>
  }

  export type QuestsUpsertWithWhereUniqueWithoutGameInput = {
    where: QuestsWhereUniqueInput
    update: XOR<QuestsUpdateWithoutGameInput, QuestsUncheckedUpdateWithoutGameInput>
    create: XOR<QuestsCreateWithoutGameInput, QuestsUncheckedCreateWithoutGameInput>
  }

  export type QuestsUpdateWithWhereUniqueWithoutGameInput = {
    where: QuestsWhereUniqueInput
    data: XOR<QuestsUpdateWithoutGameInput, QuestsUncheckedUpdateWithoutGameInput>
  }

  export type QuestsUpdateManyWithWhereWithoutGameInput = {
    where: QuestsScalarWhereInput
    data: XOR<QuestsUpdateManyMutationInput, QuestsUncheckedUpdateManyWithoutGameInput>
  }

  export type QuestsScalarWhereInput = {
    AND?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
    OR?: QuestsScalarWhereInput[]
    NOT?: QuestsScalarWhereInput | QuestsScalarWhereInput[]
    id?: StringFilter<"Quests"> | string
    gameId?: StringFilter<"Quests"> | string
    type?: StringFilter<"Quests"> | string
    title?: StringFilter<"Quests"> | string
    reward?: JsonNullableFilter<"Quests">
    open?: BoolFilter<"Quests"> | boolean
  }

  export type SoftwareUpsertWithWhereUniqueWithoutGameInput = {
    where: SoftwareWhereUniqueInput
    update: XOR<SoftwareUpdateWithoutGameInput, SoftwareUncheckedUpdateWithoutGameInput>
    create: XOR<SoftwareCreateWithoutGameInput, SoftwareUncheckedCreateWithoutGameInput>
  }

  export type SoftwareUpdateWithWhereUniqueWithoutGameInput = {
    where: SoftwareWhereUniqueInput
    data: XOR<SoftwareUpdateWithoutGameInput, SoftwareUncheckedUpdateWithoutGameInput>
  }

  export type SoftwareUpdateManyWithWhereWithoutGameInput = {
    where: SoftwareScalarWhereInput
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyWithoutGameInput>
  }

  export type UserQuestsUpsertWithWhereUniqueWithoutGameInput = {
    where: UserQuestsWhereUniqueInput
    update: XOR<UserQuestsUpdateWithoutGameInput, UserQuestsUncheckedUpdateWithoutGameInput>
    create: XOR<UserQuestsCreateWithoutGameInput, UserQuestsUncheckedCreateWithoutGameInput>
  }

  export type UserQuestsUpdateWithWhereUniqueWithoutGameInput = {
    where: UserQuestsWhereUniqueInput
    data: XOR<UserQuestsUpdateWithoutGameInput, UserQuestsUncheckedUpdateWithoutGameInput>
  }

  export type UserQuestsUpdateManyWithWhereWithoutGameInput = {
    where: UserQuestsScalarWhereInput
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyWithoutGameInput>
  }

  export type UserCreateWithoutSessionInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutSessionInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
  }

  export type UserUpdateWithoutSessionInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type ComputerCreateWithoutHardwareInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutHardwareInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutHardwareInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
  }

  export type GameCreateWithoutHardwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutHardwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutHardwareInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
  }

  export type ComputerUpsertWithoutHardwareInput = {
    update: XOR<ComputerUpdateWithoutHardwareInput, ComputerUncheckedUpdateWithoutHardwareInput>
    create: XOR<ComputerCreateWithoutHardwareInput, ComputerUncheckedCreateWithoutHardwareInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutHardwareInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutHardwareInput, ComputerUncheckedUpdateWithoutHardwareInput>
  }

  export type ComputerUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutHardwareInput = {
    update: XOR<GameUpdateWithoutHardwareInput, GameUncheckedUpdateWithoutHardwareInput>
    create: XOR<GameCreateWithoutHardwareInput, GameUncheckedCreateWithoutHardwareInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutHardwareInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutHardwareInput, GameUncheckedUpdateWithoutHardwareInput>
  }

  export type GameUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutHardwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type ComputerCreateWithoutAddressBookInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutAddressBookInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutAddressBookInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
  }

  export type GameCreateWithoutAddressBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutAddressBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAddressBookInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
  }

  export type UserCreateWithoutAddressBookInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutAddressBookInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutAddressBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
  }

  export type ComputerUpsertWithoutAddressBookInput = {
    update: XOR<ComputerUpdateWithoutAddressBookInput, ComputerUncheckedUpdateWithoutAddressBookInput>
    create: XOR<ComputerCreateWithoutAddressBookInput, ComputerUncheckedCreateWithoutAddressBookInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutAddressBookInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutAddressBookInput, ComputerUncheckedUpdateWithoutAddressBookInput>
  }

  export type ComputerUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutAddressBookInput = {
    update: XOR<GameUpdateWithoutAddressBookInput, GameUncheckedUpdateWithoutAddressBookInput>
    create: XOR<GameCreateWithoutAddressBookInput, GameUncheckedCreateWithoutAddressBookInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutAddressBookInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutAddressBookInput, GameUncheckedUpdateWithoutAddressBookInput>
  }

  export type GameUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutAddressBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutAddressBookInput = {
    update: XOR<UserUpdateWithoutAddressBookInput, UserUncheckedUpdateWithoutAddressBookInput>
    create: XOR<UserCreateWithoutAddressBookInput, UserUncheckedCreateWithoutAddressBookInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressBookInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressBookInput, UserUncheckedUpdateWithoutAddressBookInput>
  }

  export type UserUpdateWithoutAddressBookInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type ComputerCreateWithoutDnsInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutDnsInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutDnsInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
  }

  export type GameCreateWithoutDnsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutDnsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutDnsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
  }

  export type UserCreateWithoutDnsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutDnsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutDnsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
  }

  export type ComputerUpsertWithoutDnsInput = {
    update: XOR<ComputerUpdateWithoutDnsInput, ComputerUncheckedUpdateWithoutDnsInput>
    create: XOR<ComputerCreateWithoutDnsInput, ComputerUncheckedCreateWithoutDnsInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutDnsInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutDnsInput, ComputerUncheckedUpdateWithoutDnsInput>
  }

  export type ComputerUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutDnsInput = {
    update: XOR<GameUpdateWithoutDnsInput, GameUncheckedUpdateWithoutDnsInput>
    create: XOR<GameCreateWithoutDnsInput, GameUncheckedCreateWithoutDnsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutDnsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutDnsInput, GameUncheckedUpdateWithoutDnsInput>
  }

  export type GameUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutDnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutDnsInput = {
    update: XOR<UserUpdateWithoutDnsInput, UserUncheckedUpdateWithoutDnsInput>
    create: XOR<UserCreateWithoutDnsInput, UserUncheckedCreateWithoutDnsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDnsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDnsInput, UserUncheckedUpdateWithoutDnsInput>
  }

  export type UserUpdateWithoutDnsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutDnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type ComputerCreateWithoutAccountBookInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutAccountBookInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutAccountBookInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
  }

  export type GameCreateWithoutAccountBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutAccountBookInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAccountBookInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
  }

  export type MemoryCreateWithoutAccountBookInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutMemoryInput
    game: GameCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutAccountBookInput = {
    id?: string
    computerId: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type MemoryCreateOrConnectWithoutAccountBookInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
  }

  export type UserCreateWithoutAccountBookInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutAccountBookInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutAccountBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
  }

  export type ComputerUpsertWithoutAccountBookInput = {
    update: XOR<ComputerUpdateWithoutAccountBookInput, ComputerUncheckedUpdateWithoutAccountBookInput>
    create: XOR<ComputerCreateWithoutAccountBookInput, ComputerUncheckedCreateWithoutAccountBookInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutAccountBookInput, ComputerUncheckedUpdateWithoutAccountBookInput>
  }

  export type ComputerUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutAccountBookInput = {
    update: XOR<GameUpdateWithoutAccountBookInput, GameUncheckedUpdateWithoutAccountBookInput>
    create: XOR<GameCreateWithoutAccountBookInput, GameUncheckedCreateWithoutAccountBookInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutAccountBookInput, GameUncheckedUpdateWithoutAccountBookInput>
  }

  export type GameUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type MemoryUpsertWithoutAccountBookInput = {
    update: XOR<MemoryUpdateWithoutAccountBookInput, MemoryUncheckedUpdateWithoutAccountBookInput>
    create: XOR<MemoryCreateWithoutAccountBookInput, MemoryUncheckedCreateWithoutAccountBookInput>
    where?: MemoryWhereInput
  }

  export type MemoryUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: MemoryWhereInput
    data: XOR<MemoryUpdateWithoutAccountBookInput, MemoryUncheckedUpdateWithoutAccountBookInput>
  }

  export type MemoryUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutAccountBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UserUpsertWithoutAccountBookInput = {
    update: XOR<UserUpdateWithoutAccountBookInput, UserUncheckedUpdateWithoutAccountBookInput>
    create: XOR<UserCreateWithoutAccountBookInput, UserUncheckedCreateWithoutAccountBookInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountBookInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountBookInput, UserUncheckedUpdateWithoutAccountBookInput>
  }

  export type UserUpdateWithoutAccountBookInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type GameCreateWithoutProfileInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutProfileInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
  }

  export type UserCreateWithoutProfileInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type GameUpsertWithoutProfileInput = {
    update: XOR<GameUpdateWithoutProfileInput, GameUncheckedUpdateWithoutProfileInput>
    create: XOR<GameCreateWithoutProfileInput, GameUncheckedCreateWithoutProfileInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutProfileInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutProfileInput, GameUncheckedUpdateWithoutProfileInput>
  }

  export type GameUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type AccountBookCreateWithoutMemoryInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer: ComputerCreateNestedOneWithoutAccountBookInput
    game: GameCreateNestedOneWithoutAccountBookInput
    user: UserCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutMemoryInput = {
    id?: number
    userId: number
    computerId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateOrConnectWithoutMemoryInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput>
  }

  export type AccountBookCreateManyMemoryInputEnvelope = {
    data: AccountBookCreateManyMemoryInput | AccountBookCreateManyMemoryInput[]
    skipDuplicates?: boolean
  }

  export type ComputerCreateWithoutMemoryInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutMemoryInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutMemoryInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
  }

  export type GameCreateWithoutMemoryInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutMemoryInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutMemoryInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
  }

  export type UserCreateWithoutMemoryInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutMemoryInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutMemoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
  }

  export type AccountBookUpsertWithWhereUniqueWithoutMemoryInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutMemoryInput, AccountBookUncheckedUpdateWithoutMemoryInput>
    create: XOR<AccountBookCreateWithoutMemoryInput, AccountBookUncheckedCreateWithoutMemoryInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutMemoryInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutMemoryInput, AccountBookUncheckedUpdateWithoutMemoryInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutMemoryInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutMemoryInput>
  }

  export type ComputerUpsertWithoutMemoryInput = {
    update: XOR<ComputerUpdateWithoutMemoryInput, ComputerUncheckedUpdateWithoutMemoryInput>
    create: XOR<ComputerCreateWithoutMemoryInput, ComputerUncheckedCreateWithoutMemoryInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutMemoryInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutMemoryInput, ComputerUncheckedUpdateWithoutMemoryInput>
  }

  export type ComputerUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutMemoryInput = {
    update: XOR<GameUpdateWithoutMemoryInput, GameUncheckedUpdateWithoutMemoryInput>
    create: XOR<GameCreateWithoutMemoryInput, GameUncheckedCreateWithoutMemoryInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutMemoryInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutMemoryInput, GameUncheckedUpdateWithoutMemoryInput>
  }

  export type GameUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutMemoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutMemoryInput = {
    update: XOR<UserUpdateWithoutMemoryInput, UserUncheckedUpdateWithoutMemoryInput>
    create: XOR<UserCreateWithoutMemoryInput, UserUncheckedCreateWithoutMemoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemoryInput, UserUncheckedUpdateWithoutMemoryInput>
  }

  export type UserUpdateWithoutMemoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutMemoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type AccountBookCreateWithoutComputerInput = {
    data?: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutAccountBookInput
    memory: MemoryCreateNestedOneWithoutAccountBookInput
    user: UserCreateNestedOneWithoutAccountBookInput
  }

  export type AccountBookUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookCreateOrConnectWithoutComputerInput = {
    where: AccountBookWhereUniqueInput
    create: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput>
  }

  export type AccountBookCreateManyComputerInputEnvelope = {
    data: AccountBookCreateManyComputerInput | AccountBookCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type AddressBookCreateWithoutComputerInput = {
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutAddressBookInput
    user: UserCreateNestedOneWithoutAddressBookInput
  }

  export type AddressBookUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookCreateOrConnectWithoutComputerInput = {
    where: AddressBookWhereUniqueInput
    create: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput>
  }

  export type AddressBookCreateManyComputerInputEnvelope = {
    data: AddressBookCreateManyComputerInput | AddressBookCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutComputerInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutComputerInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutComputerInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
  }

  export type UserCreateWithoutComputerInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutComputerInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutComputerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
  }

  export type DNSCreateWithoutComputerInput = {
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
    game: GameCreateNestedOneWithoutDnsInput
    user: UserCreateNestedOneWithoutDnsInput
  }

  export type DNSUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type DNSCreateOrConnectWithoutComputerInput = {
    where: DNSWhereUniqueInput
    create: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput>
  }

  export type DNSCreateManyComputerInputEnvelope = {
    data: DNSCreateManyComputerInput | DNSCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type HardwareCreateWithoutComputerInput = {
    type: $Enums.HardwareTypes
    strength: number
    game: GameCreateNestedOneWithoutHardwareInput
  }

  export type HardwareUncheckedCreateWithoutComputerInput = {
    id?: number
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type HardwareCreateOrConnectWithoutComputerInput = {
    where: HardwareWhereUniqueInput
    create: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput>
  }

  export type HardwareCreateManyComputerInputEnvelope = {
    data: HardwareCreateManyComputerInput | HardwareCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type LogsCreateWithoutComputerInput = {
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
    game: GameCreateNestedOneWithoutLogsInput
    user: UserCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateWithoutComputerInput = {
    id?: number
    userId: number
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type LogsCreateOrConnectWithoutComputerInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput>
  }

  export type LogsCreateManyComputerInputEnvelope = {
    data: LogsCreateManyComputerInput | LogsCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type MemoryCreateWithoutComputerInput = {
    id?: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookCreateNestedManyWithoutMemoryInput
    game: GameCreateNestedOneWithoutMemoryInput
    user: UserCreateNestedOneWithoutMemoryInput
  }

  export type MemoryUncheckedCreateWithoutComputerInput = {
    id?: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutMemoryInput
  }

  export type MemoryCreateOrConnectWithoutComputerInput = {
    where: MemoryWhereUniqueInput
    create: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput>
  }

  export type MemoryCreateManyComputerInputEnvelope = {
    data: MemoryCreateManyComputerInput | MemoryCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCreateWithoutComputerInput = {
    id?: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutProcessInput
    user: UserCreateNestedOneWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutComputerInput = {
    id?: string
    userId: number
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateOrConnectWithoutComputerInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput>
  }

  export type ProcessCreateManyComputerInputEnvelope = {
    data: ProcessCreateManyComputerInput | ProcessCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type SoftwareCreateWithoutComputerInput = {
    id?: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
    game: GameCreateNestedOneWithoutSoftwareInput
    user: UserCreateNestedOneWithoutSoftwareInput
  }

  export type SoftwareUncheckedCreateWithoutComputerInput = {
    id?: string
    userId: number
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateOrConnectWithoutComputerInput = {
    where: SoftwareWhereUniqueInput
    create: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput>
  }

  export type SoftwareCreateManyComputerInputEnvelope = {
    data: SoftwareCreateManyComputerInput | SoftwareCreateManyComputerInput[]
    skipDuplicates?: boolean
  }

  export type AccountBookUpsertWithWhereUniqueWithoutComputerInput = {
    where: AccountBookWhereUniqueInput
    update: XOR<AccountBookUpdateWithoutComputerInput, AccountBookUncheckedUpdateWithoutComputerInput>
    create: XOR<AccountBookCreateWithoutComputerInput, AccountBookUncheckedCreateWithoutComputerInput>
  }

  export type AccountBookUpdateWithWhereUniqueWithoutComputerInput = {
    where: AccountBookWhereUniqueInput
    data: XOR<AccountBookUpdateWithoutComputerInput, AccountBookUncheckedUpdateWithoutComputerInput>
  }

  export type AccountBookUpdateManyWithWhereWithoutComputerInput = {
    where: AccountBookScalarWhereInput
    data: XOR<AccountBookUpdateManyMutationInput, AccountBookUncheckedUpdateManyWithoutComputerInput>
  }

  export type AddressBookUpsertWithWhereUniqueWithoutComputerInput = {
    where: AddressBookWhereUniqueInput
    update: XOR<AddressBookUpdateWithoutComputerInput, AddressBookUncheckedUpdateWithoutComputerInput>
    create: XOR<AddressBookCreateWithoutComputerInput, AddressBookUncheckedCreateWithoutComputerInput>
  }

  export type AddressBookUpdateWithWhereUniqueWithoutComputerInput = {
    where: AddressBookWhereUniqueInput
    data: XOR<AddressBookUpdateWithoutComputerInput, AddressBookUncheckedUpdateWithoutComputerInput>
  }

  export type AddressBookUpdateManyWithWhereWithoutComputerInput = {
    where: AddressBookScalarWhereInput
    data: XOR<AddressBookUpdateManyMutationInput, AddressBookUncheckedUpdateManyWithoutComputerInput>
  }

  export type GameUpsertWithoutComputerInput = {
    update: XOR<GameUpdateWithoutComputerInput, GameUncheckedUpdateWithoutComputerInput>
    create: XOR<GameCreateWithoutComputerInput, GameUncheckedCreateWithoutComputerInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutComputerInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutComputerInput, GameUncheckedUpdateWithoutComputerInput>
  }

  export type GameUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutComputerInput = {
    update: XOR<UserUpdateWithoutComputerInput, UserUncheckedUpdateWithoutComputerInput>
    create: XOR<UserCreateWithoutComputerInput, UserUncheckedCreateWithoutComputerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComputerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComputerInput, UserUncheckedUpdateWithoutComputerInput>
  }

  export type UserUpdateWithoutComputerInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type DNSUpsertWithWhereUniqueWithoutComputerInput = {
    where: DNSWhereUniqueInput
    update: XOR<DNSUpdateWithoutComputerInput, DNSUncheckedUpdateWithoutComputerInput>
    create: XOR<DNSCreateWithoutComputerInput, DNSUncheckedCreateWithoutComputerInput>
  }

  export type DNSUpdateWithWhereUniqueWithoutComputerInput = {
    where: DNSWhereUniqueInput
    data: XOR<DNSUpdateWithoutComputerInput, DNSUncheckedUpdateWithoutComputerInput>
  }

  export type DNSUpdateManyWithWhereWithoutComputerInput = {
    where: DNSScalarWhereInput
    data: XOR<DNSUpdateManyMutationInput, DNSUncheckedUpdateManyWithoutComputerInput>
  }

  export type HardwareUpsertWithWhereUniqueWithoutComputerInput = {
    where: HardwareWhereUniqueInput
    update: XOR<HardwareUpdateWithoutComputerInput, HardwareUncheckedUpdateWithoutComputerInput>
    create: XOR<HardwareCreateWithoutComputerInput, HardwareUncheckedCreateWithoutComputerInput>
  }

  export type HardwareUpdateWithWhereUniqueWithoutComputerInput = {
    where: HardwareWhereUniqueInput
    data: XOR<HardwareUpdateWithoutComputerInput, HardwareUncheckedUpdateWithoutComputerInput>
  }

  export type HardwareUpdateManyWithWhereWithoutComputerInput = {
    where: HardwareScalarWhereInput
    data: XOR<HardwareUpdateManyMutationInput, HardwareUncheckedUpdateManyWithoutComputerInput>
  }

  export type LogsUpsertWithWhereUniqueWithoutComputerInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutComputerInput, LogsUncheckedUpdateWithoutComputerInput>
    create: XOR<LogsCreateWithoutComputerInput, LogsUncheckedCreateWithoutComputerInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutComputerInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutComputerInput, LogsUncheckedUpdateWithoutComputerInput>
  }

  export type LogsUpdateManyWithWhereWithoutComputerInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutComputerInput>
  }

  export type MemoryUpsertWithWhereUniqueWithoutComputerInput = {
    where: MemoryWhereUniqueInput
    update: XOR<MemoryUpdateWithoutComputerInput, MemoryUncheckedUpdateWithoutComputerInput>
    create: XOR<MemoryCreateWithoutComputerInput, MemoryUncheckedCreateWithoutComputerInput>
  }

  export type MemoryUpdateWithWhereUniqueWithoutComputerInput = {
    where: MemoryWhereUniqueInput
    data: XOR<MemoryUpdateWithoutComputerInput, MemoryUncheckedUpdateWithoutComputerInput>
  }

  export type MemoryUpdateManyWithWhereWithoutComputerInput = {
    where: MemoryScalarWhereInput
    data: XOR<MemoryUpdateManyMutationInput, MemoryUncheckedUpdateManyWithoutComputerInput>
  }

  export type ProcessUpsertWithWhereUniqueWithoutComputerInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutComputerInput, ProcessUncheckedUpdateWithoutComputerInput>
    create: XOR<ProcessCreateWithoutComputerInput, ProcessUncheckedCreateWithoutComputerInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutComputerInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutComputerInput, ProcessUncheckedUpdateWithoutComputerInput>
  }

  export type ProcessUpdateManyWithWhereWithoutComputerInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutComputerInput>
  }

  export type SoftwareUpsertWithWhereUniqueWithoutComputerInput = {
    where: SoftwareWhereUniqueInput
    update: XOR<SoftwareUpdateWithoutComputerInput, SoftwareUncheckedUpdateWithoutComputerInput>
    create: XOR<SoftwareCreateWithoutComputerInput, SoftwareUncheckedCreateWithoutComputerInput>
  }

  export type SoftwareUpdateWithWhereUniqueWithoutComputerInput = {
    where: SoftwareWhereUniqueInput
    data: XOR<SoftwareUpdateWithoutComputerInput, SoftwareUncheckedUpdateWithoutComputerInput>
  }

  export type SoftwareUpdateManyWithWhereWithoutComputerInput = {
    where: SoftwareScalarWhereInput
    data: XOR<SoftwareUpdateManyMutationInput, SoftwareUncheckedUpdateManyWithoutComputerInput>
  }

  export type GameCreateWithoutQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutQuestsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
  }

  export type UserQuestsCreateWithoutQuestInput = {
    id?: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
    game: GameCreateNestedOneWithoutUserQuestsInput
    user: UserCreateNestedOneWithoutUserQuestsInput
  }

  export type UserQuestsUncheckedCreateWithoutQuestInput = {
    id?: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsCreateOrConnectWithoutQuestInput = {
    where: UserQuestsWhereUniqueInput
    create: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput>
  }

  export type UserQuestsCreateManyQuestInputEnvelope = {
    data: UserQuestsCreateManyQuestInput | UserQuestsCreateManyQuestInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithoutQuestsInput = {
    update: XOR<GameUpdateWithoutQuestsInput, GameUncheckedUpdateWithoutQuestsInput>
    create: XOR<GameCreateWithoutQuestsInput, GameUncheckedCreateWithoutQuestsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutQuestsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutQuestsInput, GameUncheckedUpdateWithoutQuestsInput>
  }

  export type GameUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserQuestsUpsertWithWhereUniqueWithoutQuestInput = {
    where: UserQuestsWhereUniqueInput
    update: XOR<UserQuestsUpdateWithoutQuestInput, UserQuestsUncheckedUpdateWithoutQuestInput>
    create: XOR<UserQuestsCreateWithoutQuestInput, UserQuestsUncheckedCreateWithoutQuestInput>
  }

  export type UserQuestsUpdateWithWhereUniqueWithoutQuestInput = {
    where: UserQuestsWhereUniqueInput
    data: XOR<UserQuestsUpdateWithoutQuestInput, UserQuestsUncheckedUpdateWithoutQuestInput>
  }

  export type UserQuestsUpdateManyWithWhereWithoutQuestInput = {
    where: UserQuestsScalarWhereInput
    data: XOR<UserQuestsUpdateManyMutationInput, UserQuestsUncheckedUpdateManyWithoutQuestInput>
  }

  export type GameCreateWithoutUserQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutUserQuestsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutUserQuestsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
  }

  export type QuestsCreateWithoutUserQuestsInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
    game: GameCreateNestedOneWithoutQuestsInput
  }

  export type QuestsUncheckedCreateWithoutUserQuestsInput = {
    id?: string
    gameId: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
  }

  export type QuestsCreateOrConnectWithoutUserQuestsInput = {
    where: QuestsWhereUniqueInput
    create: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
  }

  export type UserCreateWithoutUserQuestsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutUserQuestsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutUserQuestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
  }

  export type GameUpsertWithoutUserQuestsInput = {
    update: XOR<GameUpdateWithoutUserQuestsInput, GameUncheckedUpdateWithoutUserQuestsInput>
    create: XOR<GameCreateWithoutUserQuestsInput, GameUncheckedCreateWithoutUserQuestsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutUserQuestsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutUserQuestsInput, GameUncheckedUpdateWithoutUserQuestsInput>
  }

  export type GameUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
  }

  export type QuestsUpsertWithoutUserQuestsInput = {
    update: XOR<QuestsUpdateWithoutUserQuestsInput, QuestsUncheckedUpdateWithoutUserQuestsInput>
    create: XOR<QuestsCreateWithoutUserQuestsInput, QuestsUncheckedCreateWithoutUserQuestsInput>
    where?: QuestsWhereInput
  }

  export type QuestsUpdateToOneWithWhereWithoutUserQuestsInput = {
    where?: QuestsWhereInput
    data: XOR<QuestsUpdateWithoutUserQuestsInput, QuestsUncheckedUpdateWithoutUserQuestsInput>
  }

  export type QuestsUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    game?: GameUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type QuestsUncheckedUpdateWithoutUserQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutUserQuestsInput = {
    update: XOR<UserUpdateWithoutUserQuestsInput, UserUncheckedUpdateWithoutUserQuestsInput>
    create: XOR<UserCreateWithoutUserQuestsInput, UserUncheckedCreateWithoutUserQuestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserQuestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserQuestsInput, UserUncheckedUpdateWithoutUserQuestsInput>
  }

  export type UserUpdateWithoutUserQuestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutUserQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type ComputerCreateWithoutSoftwareInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutSoftwareInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutSoftwareInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
  }

  export type GameCreateWithoutSoftwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSoftwareInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSoftwareInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
  }

  export type UserCreateWithoutSoftwareInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutSoftwareInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutSoftwareInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
  }

  export type ComputerUpsertWithoutSoftwareInput = {
    update: XOR<ComputerUpdateWithoutSoftwareInput, ComputerUncheckedUpdateWithoutSoftwareInput>
    create: XOR<ComputerCreateWithoutSoftwareInput, ComputerUncheckedCreateWithoutSoftwareInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutSoftwareInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutSoftwareInput, ComputerUncheckedUpdateWithoutSoftwareInput>
  }

  export type ComputerUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutSoftwareInput = {
    update: XOR<GameUpdateWithoutSoftwareInput, GameUncheckedUpdateWithoutSoftwareInput>
    create: XOR<GameCreateWithoutSoftwareInput, GameUncheckedCreateWithoutSoftwareInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutSoftwareInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutSoftwareInput, GameUncheckedUpdateWithoutSoftwareInput>
  }

  export type GameUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSoftwareInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutSoftwareInput = {
    update: XOR<UserUpdateWithoutSoftwareInput, UserUncheckedUpdateWithoutSoftwareInput>
    create: XOR<UserCreateWithoutSoftwareInput, UserUncheckedCreateWithoutSoftwareInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSoftwareInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSoftwareInput, UserUncheckedUpdateWithoutSoftwareInput>
  }

  export type UserUpdateWithoutSoftwareInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutSoftwareInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type ComputerCreateWithoutProcessInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    logs?: LogsCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutProcessInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    logs?: LogsUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutProcessInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
  }

  export type GameCreateWithoutProcessInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    logs?: LogsCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutProcessInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    logs?: LogsUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutProcessInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
  }

  export type UserCreateWithoutProcessInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutProcessInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutProcessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
  }

  export type ComputerUpsertWithoutProcessInput = {
    update: XOR<ComputerUpdateWithoutProcessInput, ComputerUncheckedUpdateWithoutProcessInput>
    create: XOR<ComputerCreateWithoutProcessInput, ComputerUncheckedCreateWithoutProcessInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutProcessInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutProcessInput, ComputerUncheckedUpdateWithoutProcessInput>
  }

  export type ComputerUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutProcessInput = {
    update: XOR<GameUpdateWithoutProcessInput, GameUncheckedUpdateWithoutProcessInput>
    create: XOR<GameCreateWithoutProcessInput, GameUncheckedCreateWithoutProcessInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutProcessInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutProcessInput, GameUncheckedUpdateWithoutProcessInput>
  }

  export type GameUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    logs?: LogsUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    logs?: LogsUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutProcessInput = {
    update: XOR<UserUpdateWithoutProcessInput, UserUncheckedUpdateWithoutProcessInput>
    create: XOR<UserCreateWithoutProcessInput, UserUncheckedCreateWithoutProcessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessInput, UserUncheckedUpdateWithoutProcessInput>
  }

  export type UserUpdateWithoutProcessInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type ComputerCreateWithoutLogsInput = {
    id?: string
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookCreateNestedManyWithoutComputerInput
    game: GameCreateNestedOneWithoutComputerInput
    user: UserCreateNestedOneWithoutComputerInput
    dns?: DNSCreateNestedManyWithoutComputerInput
    hardware?: HardwareCreateNestedManyWithoutComputerInput
    memory?: MemoryCreateNestedManyWithoutComputerInput
    process?: ProcessCreateNestedManyWithoutComputerInput
    software?: SoftwareCreateNestedManyWithoutComputerInput
  }

  export type ComputerUncheckedCreateWithoutLogsInput = {
    id?: string
    userId: number
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutComputerInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutComputerInput
    dns?: DNSUncheckedCreateNestedManyWithoutComputerInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutComputerInput
    memory?: MemoryUncheckedCreateNestedManyWithoutComputerInput
    process?: ProcessUncheckedCreateNestedManyWithoutComputerInput
    software?: SoftwareUncheckedCreateNestedManyWithoutComputerInput
  }

  export type ComputerCreateOrConnectWithoutLogsInput = {
    where: ComputerWhereUniqueInput
    create: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
  }

  export type GameCreateWithoutLogsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookCreateNestedManyWithoutGameInput
    addressBook?: AddressBookCreateNestedManyWithoutGameInput
    computer?: ComputerCreateNestedManyWithoutGameInput
    dns?: DNSCreateNestedManyWithoutGameInput
    hardware?: HardwareCreateNestedManyWithoutGameInput
    memory?: MemoryCreateNestedManyWithoutGameInput
    process?: ProcessCreateNestedManyWithoutGameInput
    profile?: ProfileCreateNestedManyWithoutGameInput
    quests?: QuestsCreateNestedManyWithoutGameInput
    software?: SoftwareCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    started?: Date | string
    ended?: Date | string | null
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutGameInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutGameInput
    computer?: ComputerUncheckedCreateNestedManyWithoutGameInput
    dns?: DNSUncheckedCreateNestedManyWithoutGameInput
    hardware?: HardwareUncheckedCreateNestedManyWithoutGameInput
    memory?: MemoryUncheckedCreateNestedManyWithoutGameInput
    process?: ProcessUncheckedCreateNestedManyWithoutGameInput
    profile?: ProfileUncheckedCreateNestedManyWithoutGameInput
    quests?: QuestsUncheckedCreateNestedManyWithoutGameInput
    software?: SoftwareUncheckedCreateNestedManyWithoutGameInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutLogsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutLogsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type ComputerUpsertWithoutLogsInput = {
    update: XOR<ComputerUpdateWithoutLogsInput, ComputerUncheckedUpdateWithoutLogsInput>
    create: XOR<ComputerCreateWithoutLogsInput, ComputerUncheckedCreateWithoutLogsInput>
    where?: ComputerWhereInput
  }

  export type ComputerUpdateToOneWithWhereWithoutLogsInput = {
    where?: ComputerWhereInput
    data: XOR<ComputerUpdateWithoutLogsInput, ComputerUncheckedUpdateWithoutLogsInput>
  }

  export type ComputerUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type GameUpsertWithoutLogsInput = {
    update: XOR<GameUpdateWithoutLogsInput, GameUncheckedUpdateWithoutLogsInput>
    create: XOR<GameCreateWithoutLogsInput, GameUncheckedCreateWithoutLogsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutLogsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutLogsInput, GameUncheckedUpdateWithoutLogsInput>
  }

  export type GameUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUpdateManyWithoutGameNestedInput
    computer?: ComputerUpdateManyWithoutGameNestedInput
    dns?: DNSUpdateManyWithoutGameNestedInput
    hardware?: HardwareUpdateManyWithoutGameNestedInput
    memory?: MemoryUpdateManyWithoutGameNestedInput
    process?: ProcessUpdateManyWithoutGameNestedInput
    profile?: ProfileUpdateManyWithoutGameNestedInput
    quests?: QuestsUpdateManyWithoutGameNestedInput
    software?: SoftwareUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBook?: AccountBookUncheckedUpdateManyWithoutGameNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutGameNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutGameNestedInput
    dns?: DNSUncheckedUpdateManyWithoutGameNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutGameNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutGameNestedInput
    process?: ProcessUncheckedUpdateManyWithoutGameNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutGameNestedInput
    quests?: QuestsUncheckedUpdateManyWithoutGameNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutGameNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type FundCreateWithoutTradesInput = {
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fundManager: UserCreateNestedOneWithoutManagedFundsInput
    holdings?: PortfolioHoldingCreateNestedManyWithoutFundInput
    hedgeFunds?: HedgeFundCreateNestedManyWithoutFundInput
  }

  export type FundUncheckedCreateWithoutTradesInput = {
    id?: number
    fundManagerId: number
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdings?: PortfolioHoldingUncheckedCreateNestedManyWithoutFundInput
    hedgeFunds?: HedgeFundUncheckedCreateNestedManyWithoutFundInput
  }

  export type FundCreateOrConnectWithoutTradesInput = {
    where: FundWhereUniqueInput
    create: XOR<FundCreateWithoutTradesInput, FundUncheckedCreateWithoutTradesInput>
  }

  export type UserCreateWithoutOngoingTradesInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutOngoingTradesInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutOngoingTradesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOngoingTradesInput, UserUncheckedCreateWithoutOngoingTradesInput>
  }

  export type PortfolioCreateWithoutTradesInput = {
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPortfoliosInput
    holdings?: PortfolioHoldingCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutTradesInput = {
    id?: number
    userId: number
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    holdings?: PortfolioHoldingUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutTradesInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutTradesInput, PortfolioUncheckedCreateWithoutTradesInput>
  }

  export type FundUpsertWithoutTradesInput = {
    update: XOR<FundUpdateWithoutTradesInput, FundUncheckedUpdateWithoutTradesInput>
    create: XOR<FundCreateWithoutTradesInput, FundUncheckedCreateWithoutTradesInput>
    where?: FundWhereInput
  }

  export type FundUpdateToOneWithWhereWithoutTradesInput = {
    where?: FundWhereInput
    data: XOR<FundUpdateWithoutTradesInput, FundUncheckedUpdateWithoutTradesInput>
  }

  export type FundUpdateWithoutTradesInput = {
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundManager?: UserUpdateOneRequiredWithoutManagedFundsNestedInput
    holdings?: PortfolioHoldingUpdateManyWithoutFundNestedInput
    hedgeFunds?: HedgeFundUpdateManyWithoutFundNestedInput
  }

  export type FundUncheckedUpdateWithoutTradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundManagerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdings?: PortfolioHoldingUncheckedUpdateManyWithoutFundNestedInput
    hedgeFunds?: HedgeFundUncheckedUpdateManyWithoutFundNestedInput
  }

  export type UserUpsertWithoutOngoingTradesInput = {
    update: XOR<UserUpdateWithoutOngoingTradesInput, UserUncheckedUpdateWithoutOngoingTradesInput>
    create: XOR<UserCreateWithoutOngoingTradesInput, UserUncheckedCreateWithoutOngoingTradesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOngoingTradesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOngoingTradesInput, UserUncheckedUpdateWithoutOngoingTradesInput>
  }

  export type UserUpdateWithoutOngoingTradesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutOngoingTradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type PortfolioUpsertWithoutTradesInput = {
    update: XOR<PortfolioUpdateWithoutTradesInput, PortfolioUncheckedUpdateWithoutTradesInput>
    create: XOR<PortfolioCreateWithoutTradesInput, PortfolioUncheckedCreateWithoutTradesInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutTradesInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutTradesInput, PortfolioUncheckedUpdateWithoutTradesInput>
  }

  export type PortfolioUpdateWithoutTradesInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    holdings?: PortfolioHoldingUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutTradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdings?: PortfolioHoldingUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type UserCreateWithoutManagedFundsInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    portfolios?: PortfolioCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagedFundsInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagedFundsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedFundsInput, UserUncheckedCreateWithoutManagedFundsInput>
  }

  export type TradeCreateWithoutBuyIntoTargetFundInput = {
    marketId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    instructionType: $Enums.InstructionNamedType
    user: UserCreateNestedOneWithoutOngoingTradesInput
    portfolio: PortfolioCreateNestedOneWithoutTradesInput
  }

  export type TradeUncheckedCreateWithoutBuyIntoTargetFundInput = {
    id?: number
    userId: number
    marketId: number
    portfolioId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    instructionType: $Enums.InstructionNamedType
  }

  export type TradeCreateOrConnectWithoutBuyIntoTargetFundInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutBuyIntoTargetFundInput, TradeUncheckedCreateWithoutBuyIntoTargetFundInput>
  }

  export type TradeCreateManyBuyIntoTargetFundInputEnvelope = {
    data: TradeCreateManyBuyIntoTargetFundInput | TradeCreateManyBuyIntoTargetFundInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioHoldingCreateWithoutFundInput = {
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutHoldingsInput
  }

  export type PortfolioHoldingUncheckedCreateWithoutFundInput = {
    id?: number
    portfolioId: number
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioHoldingCreateOrConnectWithoutFundInput = {
    where: PortfolioHoldingWhereUniqueInput
    create: XOR<PortfolioHoldingCreateWithoutFundInput, PortfolioHoldingUncheckedCreateWithoutFundInput>
  }

  export type PortfolioHoldingCreateManyFundInputEnvelope = {
    data: PortfolioHoldingCreateManyFundInput | PortfolioHoldingCreateManyFundInput[]
    skipDuplicates?: boolean
  }

  export type HedgeFundCreateWithoutFundInput = {
    strategy: string
    riskLevel: string
    minimumLockPeriod?: number
    managementFee?: Decimal | DecimalJsLike | number | string
    performanceFee?: Decimal | DecimalJsLike | number | string
    highWaterMark?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HedgeFundUncheckedCreateWithoutFundInput = {
    id?: number
    strategy: string
    riskLevel: string
    minimumLockPeriod?: number
    managementFee?: Decimal | DecimalJsLike | number | string
    performanceFee?: Decimal | DecimalJsLike | number | string
    highWaterMark?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HedgeFundCreateOrConnectWithoutFundInput = {
    where: HedgeFundWhereUniqueInput
    create: XOR<HedgeFundCreateWithoutFundInput, HedgeFundUncheckedCreateWithoutFundInput>
  }

  export type HedgeFundCreateManyFundInputEnvelope = {
    data: HedgeFundCreateManyFundInput | HedgeFundCreateManyFundInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutManagedFundsInput = {
    update: XOR<UserUpdateWithoutManagedFundsInput, UserUncheckedUpdateWithoutManagedFundsInput>
    create: XOR<UserCreateWithoutManagedFundsInput, UserUncheckedCreateWithoutManagedFundsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedFundsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedFundsInput, UserUncheckedUpdateWithoutManagedFundsInput>
  }

  export type UserUpdateWithoutManagedFundsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedFundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TradeUpsertWithWhereUniqueWithoutBuyIntoTargetFundInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutBuyIntoTargetFundInput, TradeUncheckedUpdateWithoutBuyIntoTargetFundInput>
    create: XOR<TradeCreateWithoutBuyIntoTargetFundInput, TradeUncheckedCreateWithoutBuyIntoTargetFundInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutBuyIntoTargetFundInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutBuyIntoTargetFundInput, TradeUncheckedUpdateWithoutBuyIntoTargetFundInput>
  }

  export type TradeUpdateManyWithWhereWithoutBuyIntoTargetFundInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutBuyIntoTargetFundInput>
  }

  export type PortfolioHoldingUpsertWithWhereUniqueWithoutFundInput = {
    where: PortfolioHoldingWhereUniqueInput
    update: XOR<PortfolioHoldingUpdateWithoutFundInput, PortfolioHoldingUncheckedUpdateWithoutFundInput>
    create: XOR<PortfolioHoldingCreateWithoutFundInput, PortfolioHoldingUncheckedCreateWithoutFundInput>
  }

  export type PortfolioHoldingUpdateWithWhereUniqueWithoutFundInput = {
    where: PortfolioHoldingWhereUniqueInput
    data: XOR<PortfolioHoldingUpdateWithoutFundInput, PortfolioHoldingUncheckedUpdateWithoutFundInput>
  }

  export type PortfolioHoldingUpdateManyWithWhereWithoutFundInput = {
    where: PortfolioHoldingScalarWhereInput
    data: XOR<PortfolioHoldingUpdateManyMutationInput, PortfolioHoldingUncheckedUpdateManyWithoutFundInput>
  }

  export type PortfolioHoldingScalarWhereInput = {
    AND?: PortfolioHoldingScalarWhereInput | PortfolioHoldingScalarWhereInput[]
    OR?: PortfolioHoldingScalarWhereInput[]
    NOT?: PortfolioHoldingScalarWhereInput | PortfolioHoldingScalarWhereInput[]
    id?: IntFilter<"PortfolioHolding"> | number
    portfolioId?: IntFilter<"PortfolioHolding"> | number
    fundId?: IntFilter<"PortfolioHolding"> | number
    quantity?: BigIntFilter<"PortfolioHolding"> | bigint | number
    averagePrice?: BigIntFilter<"PortfolioHolding"> | bigint | number
    createdAt?: DateTimeFilter<"PortfolioHolding"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioHolding"> | Date | string
  }

  export type HedgeFundUpsertWithWhereUniqueWithoutFundInput = {
    where: HedgeFundWhereUniqueInput
    update: XOR<HedgeFundUpdateWithoutFundInput, HedgeFundUncheckedUpdateWithoutFundInput>
    create: XOR<HedgeFundCreateWithoutFundInput, HedgeFundUncheckedCreateWithoutFundInput>
  }

  export type HedgeFundUpdateWithWhereUniqueWithoutFundInput = {
    where: HedgeFundWhereUniqueInput
    data: XOR<HedgeFundUpdateWithoutFundInput, HedgeFundUncheckedUpdateWithoutFundInput>
  }

  export type HedgeFundUpdateManyWithWhereWithoutFundInput = {
    where: HedgeFundScalarWhereInput
    data: XOR<HedgeFundUpdateManyMutationInput, HedgeFundUncheckedUpdateManyWithoutFundInput>
  }

  export type HedgeFundScalarWhereInput = {
    AND?: HedgeFundScalarWhereInput | HedgeFundScalarWhereInput[]
    OR?: HedgeFundScalarWhereInput[]
    NOT?: HedgeFundScalarWhereInput | HedgeFundScalarWhereInput[]
    id?: IntFilter<"HedgeFund"> | number
    fundId?: IntFilter<"HedgeFund"> | number
    strategy?: StringFilter<"HedgeFund"> | string
    riskLevel?: StringFilter<"HedgeFund"> | string
    minimumLockPeriod?: IntFilter<"HedgeFund"> | number
    managementFee?: DecimalFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFilter<"HedgeFund"> | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFilter<"HedgeFund"> | bigint | number
    createdAt?: DateTimeFilter<"HedgeFund"> | Date | string
    updatedAt?: DateTimeFilter<"HedgeFund"> | Date | string
  }

  export type UserCreateWithoutPortfoliosInput = {
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookCreateNestedManyWithoutUserInput
    addressBook?: AddressBookCreateNestedManyWithoutUserInput
    computer?: ComputerCreateNestedManyWithoutUserInput
    dns?: DNSCreateNestedManyWithoutUserInput
    logs?: LogsCreateNestedManyWithoutUserInput
    memory?: MemoryCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    process?: ProcessCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    software?: SoftwareCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeCreateNestedManyWithoutUserInput
    managedFunds?: FundCreateNestedManyWithoutFundManagerInput
  }

  export type UserUncheckedCreateWithoutPortfoliosInput = {
    id?: number
    email: string
    name?: string
    password: string
    salt: string
    lastAction?: Date | string
    created?: Date | string
    refreshToken?: string | null
    group?: $Enums.Groups
    accountBook?: AccountBookUncheckedCreateNestedManyWithoutUserInput
    addressBook?: AddressBookUncheckedCreateNestedManyWithoutUserInput
    computer?: ComputerUncheckedCreateNestedManyWithoutUserInput
    dns?: DNSUncheckedCreateNestedManyWithoutUserInput
    logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    memory?: MemoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    process?: ProcessUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    software?: SoftwareUncheckedCreateNestedManyWithoutUserInput
    userQuests?: UserQuestsUncheckedCreateNestedManyWithoutUserInput
    ongoingTrades?: TradeUncheckedCreateNestedManyWithoutUserInput
    managedFunds?: FundUncheckedCreateNestedManyWithoutFundManagerInput
  }

  export type UserCreateOrConnectWithoutPortfoliosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
  }

  export type PortfolioHoldingCreateWithoutPortfolioInput = {
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fund: FundCreateNestedOneWithoutHoldingsInput
  }

  export type PortfolioHoldingUncheckedCreateWithoutPortfolioInput = {
    id?: number
    fundId: number
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioHoldingCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioHoldingWhereUniqueInput
    create: XOR<PortfolioHoldingCreateWithoutPortfolioInput, PortfolioHoldingUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioHoldingCreateManyPortfolioInputEnvelope = {
    data: PortfolioHoldingCreateManyPortfolioInput | PortfolioHoldingCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type TradeCreateWithoutPortfolioInput = {
    marketId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    instructionType: $Enums.InstructionNamedType
    buyIntoTargetFund: FundCreateNestedOneWithoutTradesInput
    user: UserCreateNestedOneWithoutOngoingTradesInput
  }

  export type TradeUncheckedCreateWithoutPortfolioInput = {
    id?: number
    userId: number
    marketId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    buyIntoTargetFundid: number
    instructionType: $Enums.InstructionNamedType
  }

  export type TradeCreateOrConnectWithoutPortfolioInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutPortfolioInput, TradeUncheckedCreateWithoutPortfolioInput>
  }

  export type TradeCreateManyPortfolioInputEnvelope = {
    data: TradeCreateManyPortfolioInput | TradeCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPortfoliosInput = {
    update: XOR<UserUpdateWithoutPortfoliosInput, UserUncheckedUpdateWithoutPortfoliosInput>
    create: XOR<UserCreateWithoutPortfoliosInput, UserUncheckedCreateWithoutPortfoliosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPortfoliosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPortfoliosInput, UserUncheckedUpdateWithoutPortfoliosInput>
  }

  export type UserUpdateWithoutPortfoliosInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUpdateManyWithoutUserNestedInput
    computer?: ComputerUpdateManyWithoutUserNestedInput
    dns?: DNSUpdateManyWithoutUserNestedInput
    logs?: LogsUpdateManyWithoutUserNestedInput
    memory?: MemoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    process?: ProcessUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    software?: SoftwareUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUpdateManyWithoutUserNestedInput
    managedFunds?: FundUpdateManyWithoutFundManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutPortfoliosInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    group?: EnumGroupsFieldUpdateOperationsInput | $Enums.Groups
    accountBook?: AccountBookUncheckedUpdateManyWithoutUserNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutUserNestedInput
    computer?: ComputerUncheckedUpdateManyWithoutUserNestedInput
    dns?: DNSUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    process?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutUserNestedInput
    userQuests?: UserQuestsUncheckedUpdateManyWithoutUserNestedInput
    ongoingTrades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    managedFunds?: FundUncheckedUpdateManyWithoutFundManagerNestedInput
  }

  export type PortfolioHoldingUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioHoldingWhereUniqueInput
    update: XOR<PortfolioHoldingUpdateWithoutPortfolioInput, PortfolioHoldingUncheckedUpdateWithoutPortfolioInput>
    create: XOR<PortfolioHoldingCreateWithoutPortfolioInput, PortfolioHoldingUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioHoldingUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioHoldingWhereUniqueInput
    data: XOR<PortfolioHoldingUpdateWithoutPortfolioInput, PortfolioHoldingUncheckedUpdateWithoutPortfolioInput>
  }

  export type PortfolioHoldingUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioHoldingScalarWhereInput
    data: XOR<PortfolioHoldingUpdateManyMutationInput, PortfolioHoldingUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type TradeUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutPortfolioInput, TradeUncheckedUpdateWithoutPortfolioInput>
    create: XOR<TradeCreateWithoutPortfolioInput, TradeUncheckedCreateWithoutPortfolioInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutPortfolioInput, TradeUncheckedUpdateWithoutPortfolioInput>
  }

  export type TradeUpdateManyWithWhereWithoutPortfolioInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type PortfolioCreateWithoutHoldingsInput = {
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPortfoliosInput
    trades?: TradeCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutHoldingsInput = {
    id?: number
    userId: number
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: TradeUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutHoldingsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutHoldingsInput, PortfolioUncheckedCreateWithoutHoldingsInput>
  }

  export type FundCreateWithoutHoldingsInput = {
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fundManager: UserCreateNestedOneWithoutManagedFundsInput
    trades?: TradeCreateNestedManyWithoutBuyIntoTargetFundInput
    hedgeFunds?: HedgeFundCreateNestedManyWithoutFundInput
  }

  export type FundUncheckedCreateWithoutHoldingsInput = {
    id?: number
    fundManagerId: number
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: TradeUncheckedCreateNestedManyWithoutBuyIntoTargetFundInput
    hedgeFunds?: HedgeFundUncheckedCreateNestedManyWithoutFundInput
  }

  export type FundCreateOrConnectWithoutHoldingsInput = {
    where: FundWhereUniqueInput
    create: XOR<FundCreateWithoutHoldingsInput, FundUncheckedCreateWithoutHoldingsInput>
  }

  export type PortfolioUpsertWithoutHoldingsInput = {
    update: XOR<PortfolioUpdateWithoutHoldingsInput, PortfolioUncheckedUpdateWithoutHoldingsInput>
    create: XOR<PortfolioCreateWithoutHoldingsInput, PortfolioUncheckedCreateWithoutHoldingsInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutHoldingsInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutHoldingsInput, PortfolioUncheckedUpdateWithoutHoldingsInput>
  }

  export type PortfolioUpdateWithoutHoldingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPortfoliosNestedInput
    trades?: TradeUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutHoldingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: TradeUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type FundUpsertWithoutHoldingsInput = {
    update: XOR<FundUpdateWithoutHoldingsInput, FundUncheckedUpdateWithoutHoldingsInput>
    create: XOR<FundCreateWithoutHoldingsInput, FundUncheckedCreateWithoutHoldingsInput>
    where?: FundWhereInput
  }

  export type FundUpdateToOneWithWhereWithoutHoldingsInput = {
    where?: FundWhereInput
    data: XOR<FundUpdateWithoutHoldingsInput, FundUncheckedUpdateWithoutHoldingsInput>
  }

  export type FundUpdateWithoutHoldingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundManager?: UserUpdateOneRequiredWithoutManagedFundsNestedInput
    trades?: TradeUpdateManyWithoutBuyIntoTargetFundNestedInput
    hedgeFunds?: HedgeFundUpdateManyWithoutFundNestedInput
  }

  export type FundUncheckedUpdateWithoutHoldingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundManagerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: TradeUncheckedUpdateManyWithoutBuyIntoTargetFundNestedInput
    hedgeFunds?: HedgeFundUncheckedUpdateManyWithoutFundNestedInput
  }

  export type FundCreateWithoutHedgeFundsInput = {
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fundManager: UserCreateNestedOneWithoutManagedFundsInput
    trades?: TradeCreateNestedManyWithoutBuyIntoTargetFundInput
    holdings?: PortfolioHoldingCreateNestedManyWithoutFundInput
  }

  export type FundUncheckedCreateWithoutHedgeFundsInput = {
    id?: number
    fundManagerId: number
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: TradeUncheckedCreateNestedManyWithoutBuyIntoTargetFundInput
    holdings?: PortfolioHoldingUncheckedCreateNestedManyWithoutFundInput
  }

  export type FundCreateOrConnectWithoutHedgeFundsInput = {
    where: FundWhereUniqueInput
    create: XOR<FundCreateWithoutHedgeFundsInput, FundUncheckedCreateWithoutHedgeFundsInput>
  }

  export type FundUpsertWithoutHedgeFundsInput = {
    update: XOR<FundUpdateWithoutHedgeFundsInput, FundUncheckedUpdateWithoutHedgeFundsInput>
    create: XOR<FundCreateWithoutHedgeFundsInput, FundUncheckedCreateWithoutHedgeFundsInput>
    where?: FundWhereInput
  }

  export type FundUpdateToOneWithWhereWithoutHedgeFundsInput = {
    where?: FundWhereInput
    data: XOR<FundUpdateWithoutHedgeFundsInput, FundUncheckedUpdateWithoutHedgeFundsInput>
  }

  export type FundUpdateWithoutHedgeFundsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundManager?: UserUpdateOneRequiredWithoutManagedFundsNestedInput
    trades?: TradeUpdateManyWithoutBuyIntoTargetFundNestedInput
    holdings?: PortfolioHoldingUpdateManyWithoutFundNestedInput
  }

  export type FundUncheckedUpdateWithoutHedgeFundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundManagerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: TradeUncheckedUpdateManyWithoutBuyIntoTargetFundNestedInput
    holdings?: PortfolioHoldingUncheckedUpdateManyWithoutFundNestedInput
  }

  export type AccountBookCreateManyUserInput = {
    id?: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookCreateManyUserInput = {
    id?: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type ComputerCreateManyUserInput = {
    id?: string
    type?: string
    gameId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
  }

  export type DNSCreateManyUserInput = {
    id?: number
    computerId: string
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type LogsCreateManyUserInput = {
    id?: number
    computerId: string
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type MemoryCreateManyUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationsCreateManyUserInput = {
    id?: number
    type: string
    content: JsonNullValueInput | InputJsonValue
    read?: boolean
  }

  export type ProcessCreateManyUserInput = {
    id?: string
    computerId: string
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateManyUserInput = {
    id?: number
    gameId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SessionCreateManyUserInput = {
    id: string
    token: string
    lastAction: Date | string
    created?: Date | string
    expires: Date | string
  }

  export type SoftwareCreateManyUserInput = {
    id?: string
    computerId: string
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UserQuestsCreateManyUserInput = {
    id?: string
    questsId: string
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type PortfolioCreateManyUserInput = {
    id?: number
    name: string
    totalValue?: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateManyUserInput = {
    id?: number
    marketId: number
    portfolioId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    buyIntoTargetFundid: number
    instructionType: $Enums.InstructionNamedType
  }

  export type FundCreateManyFundManagerInput = {
    id?: number
    name: string
    minimumInvestmentAmount?: bigint | number
    totalFundCharge?: Decimal | DecimalJsLike | number | string
    totalFundCost?: Decimal | DecimalJsLike | number | string
    totalAssets?: bigint | number
    isActive?: boolean
    maxInvestors?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountBookUpdateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookUpdateWithoutUserInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAddressBookNestedInput
    game?: GameUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type ComputerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    game?: GameUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUpdateWithoutUserInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutDnsNestedInput
    game?: GameUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUpdateWithoutUserInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutLogsNestedInput
    game?: GameUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationsUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProcessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutProcessNestedInput
    game?: GameUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    lastAction?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoftwareUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutSoftwareNestedInput
    game?: GameUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UserQuestsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutUserQuestsNestedInput
    quest?: QuestsUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdings?: PortfolioHoldingUpdateManyWithoutPortfolioNestedInput
    trades?: TradeUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdings?: PortfolioHoldingUncheckedUpdateManyWithoutPortfolioNestedInput
    trades?: TradeUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalValue?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUpdateWithoutUserInput = {
    marketId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
    buyIntoTargetFund?: FundUpdateOneRequiredWithoutTradesNestedInput
    portfolio?: PortfolioUpdateOneRequiredWithoutTradesNestedInput
  }

  export type TradeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyIntoTargetFundid?: IntFieldUpdateOperationsInput | number
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type TradeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyIntoTargetFundid?: IntFieldUpdateOperationsInput | number
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type FundUpdateWithoutFundManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: TradeUpdateManyWithoutBuyIntoTargetFundNestedInput
    holdings?: PortfolioHoldingUpdateManyWithoutFundNestedInput
    hedgeFunds?: HedgeFundUpdateManyWithoutFundNestedInput
  }

  export type FundUncheckedUpdateWithoutFundManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: TradeUncheckedUpdateManyWithoutBuyIntoTargetFundNestedInput
    holdings?: PortfolioHoldingUncheckedUpdateManyWithoutFundNestedInput
    hedgeFunds?: HedgeFundUncheckedUpdateManyWithoutFundNestedInput
  }

  export type FundUncheckedUpdateManyWithoutFundManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minimumInvestmentAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    totalFundCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFundCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAssets?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxInvestors?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBookCreateManyGameInput = {
    id?: number
    userId: number
    computerId: string
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookCreateManyGameInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    computerId: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ComputerCreateManyGameInput = {
    id?: string
    userId: number
    type?: string
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    created?: Date | string
    updated?: Date | string
  }

  export type DNSCreateManyGameInput = {
    id?: number
    userId: number
    computerId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type HardwareCreateManyGameInput = {
    id?: number
    computerId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type LogsCreateManyGameInput = {
    id?: number
    userId: number
    computerId: string
    senderId: string
    senderIp: string
    message: string
    created?: Date | string
  }

  export type MemoryCreateManyGameInput = {
    id?: string
    computerId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateManyGameInput = {
    id?: string
    userId: number
    computerId: string
    ip?: string | null
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateManyGameInput = {
    id?: number
    userId: number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type QuestsCreateManyGameInput = {
    id?: string
    type: string
    title: string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open: boolean
  }

  export type SoftwareCreateManyGameInput = {
    id?: string
    userId: number
    computerId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UserQuestsCreateManyGameInput = {
    id?: string
    questsId: string
    userId: number
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type AccountBookUpdateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookUpdateWithoutGameInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAddressBookNestedInput
    user?: UserUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AddressBookUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ComputerUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUpdateManyWithoutComputerNestedInput
    user?: UserUpdateOneRequiredWithoutComputerNestedInput
    dns?: DNSUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUpdateManyWithoutComputerNestedInput
    logs?: LogsUpdateManyWithoutComputerNestedInput
    memory?: MemoryUpdateManyWithoutComputerNestedInput
    process?: ProcessUpdateManyWithoutComputerNestedInput
    software?: SoftwareUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    accountBook?: AccountBookUncheckedUpdateManyWithoutComputerNestedInput
    addressBook?: AddressBookUncheckedUpdateManyWithoutComputerNestedInput
    dns?: DNSUncheckedUpdateManyWithoutComputerNestedInput
    hardware?: HardwareUncheckedUpdateManyWithoutComputerNestedInput
    logs?: LogsUncheckedUpdateManyWithoutComputerNestedInput
    memory?: MemoryUncheckedUpdateManyWithoutComputerNestedInput
    process?: ProcessUncheckedUpdateManyWithoutComputerNestedInput
    software?: SoftwareUncheckedUpdateManyWithoutComputerNestedInput
  }

  export type ComputerUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUpdateWithoutGameInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutDnsNestedInput
    user?: UserUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HardwareUpdateWithoutGameInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
    computer?: ComputerUpdateOneRequiredWithoutHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type LogsUpdateWithoutGameInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    computer?: ComputerUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
    computer?: ComputerUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    computerId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutProcessNestedInput
    user?: UserUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateWithoutGameInput = {
    data?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateManyWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type QuestsUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    userQuests?: UserQuestsUpdateManyWithoutQuestNestedInput
  }

  export type QuestsUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
    userQuests?: UserQuestsUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestsUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: NullableJsonNullValueInput | InputJsonValue
    open?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SoftwareUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutSoftwareNestedInput
    user?: UserUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UserQuestsUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    quest?: QuestsUpdateOneRequiredWithoutUserQuestsNestedInput
    user?: UserUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    questsId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBookCreateManyMemoryInput = {
    id?: number
    userId: number
    computerId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AccountBookUpdateWithoutMemoryInput = {
    data?: JsonNullValueInput | InputJsonValue
    computer?: ComputerUpdateOneRequiredWithoutAccountBookNestedInput
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutMemoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUncheckedUpdateManyWithoutMemoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    computerId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookCreateManyComputerInput = {
    id?: number
    userId: number
    memoryId: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type AddressBookCreateManyComputerInput = {
    id?: number
    userId: number
    access: $Enums.AccessLevel
    ip: string
    data?: JsonNullValueInput | InputJsonValue
    gameId: string
  }

  export type DNSCreateManyComputerInput = {
    id?: number
    userId: number
    gameId: string
    website: string
    tags: string
    description?: string
    updated?: Date | string
    created?: Date | string
  }

  export type HardwareCreateManyComputerInput = {
    id?: number
    gameId: string
    type: $Enums.HardwareTypes
    strength: number
  }

  export type LogsCreateManyComputerInput = {
    id?: number
    userId: number
    senderId: string
    senderIp: string
    gameId: string
    message: string
    created?: Date | string
  }

  export type MemoryCreateManyComputerInput = {
    id?: string
    gameId: string
    userId: number
    type: string
    key: string
    value?: number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessCreateManyComputerInput = {
    id?: string
    userId: number
    ip?: string | null
    gameId: string
    type: string
    started?: Date | string
    completion: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareCreateManyComputerInput = {
    id?: string
    userId: number
    gameId: string
    type: string
    level: number
    size: number
    opacity: number
    installed: boolean
    executed?: Date | string
    created?: Date | string
    updated?: Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AccountBookUpdateWithoutComputerInput = {
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutAccountBookNestedInput
    memory?: MemoryUpdateOneRequiredWithoutAccountBookNestedInput
    user?: UserUpdateOneRequiredWithoutAccountBookNestedInput
  }

  export type AccountBookUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountBookUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memoryId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookUpdateWithoutComputerInput = {
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutAddressBookNestedInput
    user?: UserUpdateOneRequiredWithoutAddressBookNestedInput
  }

  export type AddressBookUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressBookUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    access?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    ip?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type DNSUpdateWithoutComputerInput = {
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutDnsNestedInput
    user?: UserUpdateOneRequiredWithoutDnsNestedInput
  }

  export type DNSUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DNSUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HardwareUpdateWithoutComputerInput = {
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutHardwareNestedInput
  }

  export type HardwareUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type HardwareUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: EnumHardwareTypesFieldUpdateOperationsInput | $Enums.HardwareTypes
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type LogsUpdateWithoutComputerInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyWithoutComputerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
    senderIp?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemoryUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUpdateManyWithoutMemoryNestedInput
    game?: GameUpdateOneRequiredWithoutMemoryNestedInput
    user?: UserUpdateOneRequiredWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
    accountBook?: AccountBookUncheckedUpdateManyWithoutMemoryNestedInput
  }

  export type MemoryUncheckedUpdateManyWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutProcessNestedInput
    user?: UserUpdateOneRequiredWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProcessUncheckedUpdateManyWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    completion?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    game?: GameUpdateOneRequiredWithoutSoftwareNestedInput
    user?: UserUpdateOneRequiredWithoutSoftwareNestedInput
  }

  export type SoftwareUncheckedUpdateWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SoftwareUncheckedUpdateManyWithoutComputerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: FloatFieldUpdateOperationsInput | number
    size?: FloatFieldUpdateOperationsInput | number
    opacity?: FloatFieldUpdateOperationsInput | number
    installed?: BoolFieldUpdateOperationsInput | boolean
    executed?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UserQuestsCreateManyQuestInput = {
    id?: string
    userId: number
    gameId: string
    completed: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type UserQuestsUpdateWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutUserQuestsNestedInput
    user?: UserUpdateOneRequiredWithoutUserQuestsNestedInput
  }

  export type UserQuestsUncheckedUpdateWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestsUncheckedUpdateManyWithoutQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeCreateManyBuyIntoTargetFundInput = {
    id?: number
    userId: number
    marketId: number
    portfolioId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    instructionType: $Enums.InstructionNamedType
  }

  export type PortfolioHoldingCreateManyFundInput = {
    id?: number
    portfolioId: number
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HedgeFundCreateManyFundInput = {
    id?: number
    strategy: string
    riskLevel: string
    minimumLockPeriod?: number
    managementFee?: Decimal | DecimalJsLike | number | string
    performanceFee?: Decimal | DecimalJsLike | number | string
    highWaterMark?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeUpdateWithoutBuyIntoTargetFundInput = {
    marketId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
    user?: UserUpdateOneRequiredWithoutOngoingTradesNestedInput
    portfolio?: PortfolioUpdateOneRequiredWithoutTradesNestedInput
  }

  export type TradeUncheckedUpdateWithoutBuyIntoTargetFundInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type TradeUncheckedUpdateManyWithoutBuyIntoTargetFundInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type PortfolioHoldingUpdateWithoutFundInput = {
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutHoldingsNestedInput
  }

  export type PortfolioHoldingUncheckedUpdateWithoutFundInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioHoldingUncheckedUpdateManyWithoutFundInput = {
    id?: IntFieldUpdateOperationsInput | number
    portfolioId?: IntFieldUpdateOperationsInput | number
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HedgeFundUpdateWithoutFundInput = {
    strategy?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    minimumLockPeriod?: IntFieldUpdateOperationsInput | number
    managementFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HedgeFundUncheckedUpdateWithoutFundInput = {
    id?: IntFieldUpdateOperationsInput | number
    strategy?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    minimumLockPeriod?: IntFieldUpdateOperationsInput | number
    managementFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HedgeFundUncheckedUpdateManyWithoutFundInput = {
    id?: IntFieldUpdateOperationsInput | number
    strategy?: StringFieldUpdateOperationsInput | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    minimumLockPeriod?: IntFieldUpdateOperationsInput | number
    managementFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highWaterMark?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioHoldingCreateManyPortfolioInput = {
    id?: number
    fundId: number
    quantity: bigint | number
    averagePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateManyPortfolioInput = {
    id?: number
    userId: number
    marketId: number
    type: string
    quantity: number
    price: bigint | number
    totalValue: number
    status: string
    executedAt: Date | string
    createdAt?: Date | string
    buyIntoTargetFundid: number
    instructionType: $Enums.InstructionNamedType
  }

  export type PortfolioHoldingUpdateWithoutPortfolioInput = {
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fund?: FundUpdateOneRequiredWithoutHoldingsNestedInput
  }

  export type PortfolioHoldingUncheckedUpdateWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundId?: IntFieldUpdateOperationsInput | number
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioHoldingUncheckedUpdateManyWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundId?: IntFieldUpdateOperationsInput | number
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    averagePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUpdateWithoutPortfolioInput = {
    marketId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
    buyIntoTargetFund?: FundUpdateOneRequiredWithoutTradesNestedInput
    user?: UserUpdateOneRequiredWithoutOngoingTradesNestedInput
  }

  export type TradeUncheckedUpdateWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyIntoTargetFundid?: IntFieldUpdateOperationsInput | number
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }

  export type TradeUncheckedUpdateManyWithoutPortfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    marketId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    totalValue?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyIntoTargetFundid?: IntFieldUpdateOperationsInput | number
    instructionType?: EnumInstructionNamedTypeFieldUpdateOperationsInput | $Enums.InstructionNamedType
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameCountOutputTypeDefaultArgs instead
     */
    export type GameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemoryCountOutputTypeDefaultArgs instead
     */
    export type MemoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComputerCountOutputTypeDefaultArgs instead
     */
    export type ComputerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComputerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestsCountOutputTypeDefaultArgs instead
     */
    export type QuestsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FundCountOutputTypeDefaultArgs instead
     */
    export type FundCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FundCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioCountOutputTypeDefaultArgs instead
     */
    export type PortfolioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameDefaultArgs instead
     */
    export type GameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HardwareDefaultArgs instead
     */
    export type HardwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HardwareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressBookDefaultArgs instead
     */
    export type AddressBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DNSDefaultArgs instead
     */
    export type DNSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DNSDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountBookDefaultArgs instead
     */
    export type AccountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemoryDefaultArgs instead
     */
    export type MemoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComputerDefaultArgs instead
     */
    export type ComputerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComputerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestsDefaultArgs instead
     */
    export type QuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserQuestsDefaultArgs instead
     */
    export type UserQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserQuestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftwareDefaultArgs instead
     */
    export type SoftwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftwareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessDefaultArgs instead
     */
    export type ProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationsDefaultArgs instead
     */
    export type NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogsDefaultArgs instead
     */
    export type LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TradeDefaultArgs instead
     */
    export type TradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FundDefaultArgs instead
     */
    export type FundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioDefaultArgs instead
     */
    export type PortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioHoldingDefaultArgs instead
     */
    export type PortfolioHoldingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioHoldingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HedgeFundDefaultArgs instead
     */
    export type HedgeFundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HedgeFundDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}